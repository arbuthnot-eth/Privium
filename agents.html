└── packages
    └── agents
        ├── CHANGELOG.md
        ├── README.md
        ├── evals
            ├── README.md
            ├── scheduling.eval.ts
            └── vite.config.ts
        ├── package.json
        ├── scripts
            └── build.ts
        ├── src
            ├── ai-chat-agent.ts
            ├── ai-react.tsx
            ├── ai-types.ts
            ├── client.ts
            ├── index.ts
            ├── mcp
            │   ├── client-connection.ts
            │   ├── client.ts
            │   ├── do-oauth-client-provider.ts
            │   ├── index.ts
            │   ├── sse-edge.ts
            │   └── streamable-http-edge.ts
            ├── observability
            │   └── index.ts
            ├── react-tests
            │   ├── use-agent-chat.test.tsx
            │   └── vitest.config.ts
            ├── react.tsx
            ├── schedule.ts
            ├── serializable.ts
            ├── tests-d
            │   ├── example-stub.test-d.ts
            │   ├── example.test-d.ts
            │   ├── typed-use-agent.test-d.ts
            │   ├── untyped-use-agent-stub.test-d.ts
            │   ├── untyped-use-agent.test-d.ts
            │   └── use-agent-stub.test-d.ts
            └── tests
            │   ├── email-routing.test.ts
            │   ├── mcp
            │       ├── mcp-protocol.test.ts
            │       └── transports
            │       │   ├── sse.test.ts
            │       │   └── streamable-http.test.ts
            │   ├── shared
            │       └── test-utils.ts
            │   ├── tsconfig.json
            │   ├── vitest.config.ts
            │   ├── worker.ts
            │   └── wrangler.jsonc
        └── tsconfig.json


/packages/agents/CHANGELOG.md:
--------------------------------------------------------------------------------
  1 | # @cloudflare/agents
  2 | 
  3 | ## 0.0.109
  4 | 
  5 | ### Patch Changes
  6 | 
  7 | - [#372](https://github.com/cloudflare/agents/pull/372) [`a45f8f3`](https://github.com/cloudflare/agents/commit/a45f8f3cd8f4f392d585cc13c721570e263094d7) Thanks [@threepointone](https://github.com/threepointone)! - default Agent's Env to cloudflare's Env
  8 | 
  9 | ## 0.0.108
 10 | 
 11 | ### Patch Changes
 12 | 
 13 | - [#357](https://github.com/cloudflare/agents/pull/357) [`40bd73c`](https://github.com/cloudflare/agents/commit/40bd73cbb29e5fc4a2625ce7d895b9e8c70d76a3) Thanks [@davemurphysf](https://github.com/davemurphysf)! - Pass incoming headers to the DO fetch method
 14 | 
 15 | ## 0.0.107
 16 | 
 17 | ### Patch Changes
 18 | 
 19 | - [#364](https://github.com/cloudflare/agents/pull/364) [`885b3db`](https://github.com/cloudflare/agents/commit/885b3db8af3f482b2892764077c05afc491f0b35) Thanks [@whoiskatrin](https://github.com/whoiskatrin)! - add HTTP Streamable support
 20 | 
 21 | ## 0.0.106
 22 | 
 23 | ### Patch Changes
 24 | 
 25 | - [#359](https://github.com/cloudflare/agents/pull/359) [`14bb798`](https://github.com/cloudflare/agents/commit/14bb798a1f79ef4052a9134dc5f5a4baee042812) Thanks [@ghostwriternr](https://github.com/ghostwriternr)! - Fix email routing to be case-insensitive for agent names
 26 | 
 27 | ## 0.0.105
 28 | 
 29 | ### Patch Changes
 30 | 
 31 | - [#354](https://github.com/cloudflare/agents/pull/354) [`f31397c`](https://github.com/cloudflare/agents/commit/f31397cb7f8b67fc736faece51364edeaf52e5a0) Thanks [@jahands](https://github.com/jahands)! - fix: dequeue items in DB after each task is complete
 32 | 
 33 |   Prevents a single failure from causing all items in the queue from being retried (including previously processed items that were successful).
 34 | 
 35 | ## 0.0.104
 36 | 
 37 | ### Patch Changes
 38 | 
 39 | - [#319](https://github.com/cloudflare/agents/pull/319) [`e48e5f9`](https://github.com/cloudflare/agents/commit/e48e5f928030e3cc8d8a73cfa8783354be0b7648) Thanks [@threepointone](https://github.com/threepointone)! - add lightweight .queue
 40 | 
 41 | - [#352](https://github.com/cloudflare/agents/pull/352) [`0bb74b8`](https://github.com/cloudflare/agents/commit/0bb74b89db99c7c31a1b7a9a35e0f2aa9814962d) Thanks [@threepointone](https://github.com/threepointone)! - email adaptor
 42 | 
 43 | - [#345](https://github.com/cloudflare/agents/pull/345) [`c5e3a32`](https://github.com/cloudflare/agents/commit/c5e3a324b16c75ace2b48a5842a2755546db4539) Thanks [@whoiskatrin](https://github.com/whoiskatrin)! - Add automatic context wrapping for custom Agent methods
 44 | 
 45 | ## 0.0.103
 46 | 
 47 | ### Patch Changes
 48 | 
 49 | - [#350](https://github.com/cloudflare/agents/pull/350) [`70ed631`](https://github.com/cloudflare/agents/commit/70ed6317bc50d32115f39119133fea5f154cde94) Thanks [@ghostwriternr](https://github.com/ghostwriternr)! - Fix TypeScript types resolution by reordering export conditions
 50 | 
 51 | ## 0.0.102
 52 | 
 53 | ### Patch Changes
 54 | 
 55 | - [#238](https://github.com/cloudflare/agents/pull/238) [`dc7a99c`](https://github.com/cloudflare/agents/commit/dc7a99ca3cc60a8be069bb1094c6dd15bd2555f2) Thanks [@zebp](https://github.com/zebp)! - Basic observability instrumentation
 56 | 
 57 | ## 0.0.101
 58 | 
 59 | ### Patch Changes
 60 | 
 61 | - [#339](https://github.com/cloudflare/agents/pull/339) [`22d140b`](https://github.com/cloudflare/agents/commit/22d140b360365ac51ed9ebdad2beab6bc7095c9e) Thanks [@threepointone](https://github.com/threepointone)! - udpate dependencies
 62 | 
 63 | ## 0.0.100
 64 | 
 65 | ### Patch Changes
 66 | 
 67 | - [#331](https://github.com/cloudflare/agents/pull/331) [`7acfd65`](https://github.com/cloudflare/agents/commit/7acfd654bc1773c975fd8f61111c76e83c132fe5) Thanks [@geelen](https://github.com/geelen)! - Adding a new MCP header to the CORS allowlist to follow the updated spec
 68 | 
 69 | ## 0.0.99
 70 | 
 71 | ### Patch Changes
 72 | 
 73 | - [#332](https://github.com/cloudflare/agents/pull/332) [`75614c2`](https://github.com/cloudflare/agents/commit/75614c2532ab3e9f95e4a45e6e5b4a62be33a846) Thanks [@mchockal](https://github.com/mchockal)! - MCP connect / reconnect refactor
 74 | 
 75 | ## 0.0.98
 76 | 
 77 | ### Patch Changes
 78 | 
 79 | - [`b4ebb44`](https://github.com/cloudflare/agents/commit/b4ebb44196ff423e06beb347bb0e7b16f08773b4) Thanks [@threepointone](https://github.com/threepointone)! - update dependencies
 80 | 
 81 | ## 0.0.97
 82 | 
 83 | ### Patch Changes
 84 | 
 85 | - [`efffe3e`](https://github.com/cloudflare/agents/commit/efffe3e2e42a7cf3d97f05122cfd5ffc3ab1ad64) Thanks [@threepointone](https://github.com/threepointone)! - trigger release
 86 | 
 87 | ## 0.0.96
 88 | 
 89 | ### Patch Changes
 90 | 
 91 | - [#325](https://github.com/cloudflare/agents/pull/325) [`7e0777b`](https://github.com/cloudflare/agents/commit/7e0777b12624cb6903053976742a33ef54ba65d7) Thanks [@threepointone](https://github.com/threepointone)! - update deps
 92 | 
 93 | ## 0.0.95
 94 | 
 95 | ### Patch Changes
 96 | 
 97 | - [#316](https://github.com/cloudflare/agents/pull/316) [`7856b4d`](https://github.com/cloudflare/agents/commit/7856b4d90afbd3faf59f2d264b59f878648153dd) Thanks [@whoiskatrin](https://github.com/whoiskatrin)! - Add fallback message when agent returns no response
 98 | 
 99 | ## 0.0.94
100 | 
101 | ### Patch Changes
102 | 
103 | - [`9c6b2d7`](https://github.com/cloudflare/agents/commit/9c6b2d7c79ff91c1d73279608fa55568f8b91a5a) Thanks [@threepointone](https://github.com/threepointone)! - update deps
104 | 
105 | - [#311](https://github.com/cloudflare/agents/pull/311) [`8a4558c`](https://github.com/cloudflare/agents/commit/8a4558cd9f95c1194f3d696bcb23050c3db7d257) Thanks [@threepointone](https://github.com/threepointone)! - Added a call to `this.ctx.abort('destroyed')` in the `destroy` method to ensure the agent is properly evicted during cleanup.
106 | 
107 | ## 0.0.93
108 | 
109 | ### Patch Changes
110 | 
111 | - [#302](https://github.com/cloudflare/agents/pull/302) [`b57e1d9`](https://github.com/cloudflare/agents/commit/b57e1d918d02607dcb68e1ca55790b6362964090) Thanks [@cmsparks](https://github.com/cmsparks)! - Fix an error where MCP servers pending connection would trigger an error
112 | 
113 | ## 0.0.92
114 | 
115 | ### Patch Changes
116 | 
117 | - [#299](https://github.com/cloudflare/agents/pull/299) [`eeb70e2`](https://github.com/cloudflare/agents/commit/eeb70e256594d688bb291fd49d96faa6839e4d8a) Thanks [@courtney-sims](https://github.com/courtney-sims)! - Prevent auth url from being regenerated during oauth flow
118 | 
119 | ## 0.0.91
120 | 
121 | ### Patch Changes
122 | 
123 | - [`7972da4`](https://github.com/cloudflare/agents/commit/7972da40a639611f253c4b4e27d18d4ff3c5a5e2) Thanks [@threepointone](https://github.com/threepointone)! - update deps
124 | 
125 | ## 0.0.90
126 | 
127 | ### Patch Changes
128 | 
129 | - [#295](https://github.com/cloudflare/agents/pull/295) [`cac66b8`](https://github.com/cloudflare/agents/commit/cac66b824c6dbfeb81623eed18c0e0d13db6d363) Thanks [@threepointone](https://github.com/threepointone)! - duck typing DurableObjectNamespace type
130 | 
131 | ## 0.0.89
132 | 
133 | ### Patch Changes
134 | 
135 | - [`87b44ab`](https://github.com/cloudflare/agents/commit/87b44ab1e277d691181eabcebde878bedc30bc2d) Thanks [@threepointone](https://github.com/threepointone)! - update deps
136 | 
137 | - [#292](https://github.com/cloudflare/agents/pull/292) [`aacf837`](https://github.com/cloudflare/agents/commit/aacf8375ccafad2b3004ee8dca2077e589eccfe7) Thanks [@cmsparks](https://github.com/cmsparks)! - Fix issue where stray MCP connection state is left after closing connection
138 | 
139 | ## 0.0.88
140 | 
141 | ### Patch Changes
142 | 
143 | - [#289](https://github.com/cloudflare/agents/pull/289) [`86cae6f`](https://github.com/cloudflare/agents/commit/86cae6f7d2190c6b2442bdc2682f75a504f39ae8) Thanks [@ruifigueira](https://github.com/ruifigueira)! - Type-safe serializable RPC methods
144 | 
145 | - [#287](https://github.com/cloudflare/agents/pull/287) [`94d9a2e`](https://github.com/cloudflare/agents/commit/94d9a2e362fe10764c85327d700ee4c90a0f957e) Thanks [@ruifigueira](https://github.com/ruifigueira)! - Improve agent types
146 | 
147 | ## 0.0.87
148 | 
149 | ### Patch Changes
150 | 
151 | - [#283](https://github.com/cloudflare/agents/pull/283) [`041b40f`](https://github.com/cloudflare/agents/commit/041b40f7022af097288cc3a29c1b421cde434bb9) Thanks [@ruifigueira](https://github.com/ruifigueira)! - Improve Agent stub
152 | 
153 | ## 0.0.86
154 | 
155 | ### Patch Changes
156 | 
157 | - [#274](https://github.com/cloudflare/agents/pull/274) [`93ccdbd`](https://github.com/cloudflare/agents/commit/93ccdbd254c083dad9f24f34b524006ce02572ed) Thanks [@ruifigueira](https://github.com/ruifigueira)! - Stub for Agent RPC
158 | 
159 | ## 0.0.85
160 | 
161 | ### Patch Changes
162 | 
163 | - [#273](https://github.com/cloudflare/agents/pull/273) [`d1f6c02`](https://github.com/cloudflare/agents/commit/d1f6c02fb425ab3f699da77693f70ad3f05652a0) Thanks [@cmsparks](https://github.com/cmsparks)! - Expose getMcpServerState internally in agent
164 | 
165 | - [#276](https://github.com/cloudflare/agents/pull/276) [`b275dea`](https://github.com/cloudflare/agents/commit/b275dea97ebb96f2a103ee34d8c53d32a02ae5c0) Thanks [@ruifigueira](https://github.com/ruifigueira)! - Fix non-optional parameters after undefined ones
166 | 
167 | - [#279](https://github.com/cloudflare/agents/pull/279) [`2801d35`](https://github.com/cloudflare/agents/commit/2801d35ff03fb41c75904fe96690766457e6b307) Thanks [@threepointone](https://github.com/threepointone)! - rename getMcpServerState/getMcpServers
168 | 
169 | ## 0.0.84
170 | 
171 | ### Patch Changes
172 | 
173 | - [#269](https://github.com/cloudflare/agents/pull/269) [`0ac89c6`](https://github.com/cloudflare/agents/commit/0ac89c62b8e829e28034a9eae91d08fc280b93b9) Thanks [@ruifigueira](https://github.com/ruifigueira)! - Add type support to react useAgent().call
174 | 
175 | ## 0.0.83
176 | 
177 | ### Patch Changes
178 | 
179 | - [#270](https://github.com/cloudflare/agents/pull/270) [`d6a4eda`](https://github.com/cloudflare/agents/commit/d6a4eda221bc36fd9f1bb13f5240697e153ce619) Thanks [@threepointone](https://github.com/threepointone)! - update deps
180 | 
181 | ## 0.0.82
182 | 
183 | ### Patch Changes
184 | 
185 | - [`04d925e`](https://github.com/cloudflare/agents/commit/04d925ee6795b907de19bcd40940062fb9e99b1b) Thanks [@threepointone](https://github.com/threepointone)! - convert two missed #methods to a private \_methods
186 | 
187 | ## 0.0.81
188 | 
189 | ### Patch Changes
190 | 
191 | - [#265](https://github.com/cloudflare/agents/pull/265) [`ac0e999`](https://github.com/cloudflare/agents/commit/ac0e999652919600f087f0314ce61c98d3eaf069) Thanks [@threepointone](https://github.com/threepointone)! - refactor #method/#property to private method/private property
192 | 
193 | - [#267](https://github.com/cloudflare/agents/pull/267) [`385f0b2`](https://github.com/cloudflare/agents/commit/385f0b29c716f8fa1c9719b0c68e5c830767953e) Thanks [@threepointone](https://github.com/threepointone)! - prefix private methods/properties with \_
194 | 
195 | ## 0.0.80
196 | 
197 | ### Patch Changes
198 | 
199 | - [#254](https://github.com/cloudflare/agents/pull/254) [`25aeaf2`](https://github.com/cloudflare/agents/commit/25aeaf24692bb82601c5df9fdce215cf2c509711) Thanks [@cmsparks](https://github.com/cmsparks)! - Move MCP lifecycle+auth handling into the Agents class
200 | 
201 | ## 0.0.79
202 | 
203 | ### Patch Changes
204 | 
205 | - [#261](https://github.com/cloudflare/agents/pull/261) [`881f11e`](https://github.com/cloudflare/agents/commit/881f11ec71d539c0bc53fd754662a40c9b9dc090) Thanks [@geelen](https://github.com/geelen)! - update dependencies
206 | 
207 | - [#253](https://github.com/cloudflare/agents/pull/253) [`8ebc079`](https://github.com/cloudflare/agents/commit/8ebc07945d9c282bc0b6bfd5c41f69380a82f7e6) Thanks [@adesege](https://github.com/adesege)! - fix: allow overriding fetch and request headers in SSEEdgeClientTransport
208 | 
209 | - [#260](https://github.com/cloudflare/agents/pull/260) [`ca44ae8`](https://github.com/cloudflare/agents/commit/ca44ae8257eac71170540221ddd7bf88ff8756a1) Thanks [@nickfujita](https://github.com/nickfujita)! - Update Agent.alarm to readonly, linking to schedule-task docs
210 | 
211 | - [#261](https://github.com/cloudflare/agents/pull/261) [`881f11e`](https://github.com/cloudflare/agents/commit/881f11ec71d539c0bc53fd754662a40c9b9dc090) Thanks [@geelen](https://github.com/geelen)! - Adding `mcp-session-id` to McpAgents' CORS headers to permit web-based MCP clients
212 | 
213 | ## 0.0.78
214 | 
215 | ### Patch Changes
216 | 
217 | - [#258](https://github.com/cloudflare/agents/pull/258) [`eede2bd`](https://github.com/cloudflare/agents/commit/eede2bd61532abeb403417dbbfe1f8e6424b39dc) Thanks [@threepointone](https://github.com/threepointone)! - wrap onRequest so getCurrentAgent works
218 | 
219 |   Fixes https://github.com/cloudflare/agents/issues/256
220 | 
221 | ## 0.0.77
222 | 
223 | ### Patch Changes
224 | 
225 | - [#249](https://github.com/cloudflare/agents/pull/249) [`c18c28a`](https://github.com/cloudflare/agents/commit/c18c28a253be85e582a71172e074eb97884894e9) Thanks [@dexxiez](https://github.com/dexxiez)! - chore: add top level default types to package.json
226 | 
227 | - [#246](https://github.com/cloudflare/agents/pull/246) [`c4d53d7`](https://github.com/cloudflare/agents/commit/c4d53d786da3adf67a658b8a343909ce0f3fb70d) Thanks [@jmorrell-cloudflare](https://github.com/jmorrell-cloudflare)! - Ensure we are passing ctx.props to McpAgent for the Streamable transport
228 | 
229 | - [#251](https://github.com/cloudflare/agents/pull/251) [`96a8138`](https://github.com/cloudflare/agents/commit/96a81383f6b48be0cc854b8cc72f33317824721c) Thanks [@brettimus](https://github.com/brettimus)! - Ensure isLoading is false after you `stop` an ongoing chat agent request
230 | 
231 | ## 0.0.76
232 | 
233 | ### Patch Changes
234 | 
235 | - [#242](https://github.com/cloudflare/agents/pull/242) [`c8f53b8`](https://github.com/cloudflare/agents/commit/c8f53b860b40a27f5d2ccfe119b37945454e6576) Thanks [@threepointone](https://github.com/threepointone)! - update deps
236 | 
237 | - [#240](https://github.com/cloudflare/agents/pull/240) [`9ff62ed`](https://github.com/cloudflare/agents/commit/9ff62ed03a08837845056adb054b3cb3fda71405) Thanks [@threepointone](https://github.com/threepointone)! - mcp: Log when an error is caught inside onSSEMcpMessage
238 | 
239 | - [#239](https://github.com/cloudflare/agents/pull/239) [`7bd597a`](https://github.com/cloudflare/agents/commit/7bd597ad453a704bca98204ca2de5dc610808fcf) Thanks [@sushichan044](https://github.com/sushichan044)! - fix(types): explicitly annotate this with void to avoid unbound method warning
240 | 
241 | ## 0.0.75
242 | 
243 | ### Patch Changes
244 | 
245 | - [`6c24007`](https://github.com/cloudflare/agents/commit/6c240075fb435642407f3a8751a12f3c8df53b6c) Thanks [@threepointone](https://github.com/threepointone)! - Revert "fool typescript into thinking agent will always be defined in ge…
246 | 
247 | ## 0.0.74
248 | 
249 | ### Patch Changes
250 | 
251 | - [`ad0054b`](https://github.com/cloudflare/agents/commit/ad0054be3b6beffcf77dff616b02a3ab1e60bbb5) Thanks [@threepointone](https://github.com/threepointone)! - fool typescript into thinking agent will always be defined in getCurrentAgent()
252 | 
253 | ## 0.0.73
254 | 
255 | ### Patch Changes
256 | 
257 | - [#231](https://github.com/cloudflare/agents/pull/231) [`ba99b7c`](https://github.com/cloudflare/agents/commit/ba99b7c789df990ca82191fbd174402dbce79b42) Thanks [@threepointone](https://github.com/threepointone)! - update deps to pick up a potential fix for onStart not firing
258 | 
259 | ## 0.0.72
260 | 
261 | ### Patch Changes
262 | 
263 | - [`a25eb55`](https://github.com/cloudflare/agents/commit/a25eb55790f8be7b47d4aabac91e167c49ac18a4) Thanks [@threepointone](https://github.com/threepointone)! - don't throw if no current agent
264 | 
265 | ## 0.0.71
266 | 
267 | ### Patch Changes
268 | 
269 | - [#228](https://github.com/cloudflare/agents/pull/228) [`f973b54`](https://github.com/cloudflare/agents/commit/f973b540fc2b5fdd1a4a7a0d473bb26c785fa2c3) Thanks [@threepointone](https://github.com/threepointone)! - mcp client: fix tool name generation
270 | 
271 | ## 0.0.70
272 | 
273 | ### Patch Changes
274 | 
275 | - [#226](https://github.com/cloudflare/agents/pull/226) [`5b7f03e`](https://github.com/cloudflare/agents/commit/5b7f03e6126498da25b4e84f83569c06f76b4cbd) Thanks [@threepointone](https://github.com/threepointone)! - mcp client: closeConnection(id) and closeAllConnections()
276 | 
277 | ## 0.0.69
278 | 
279 | ### Patch Changes
280 | 
281 | - [#224](https://github.com/cloudflare/agents/pull/224) [`b342dcf`](https://github.com/cloudflare/agents/commit/b342dcfcce1192935d83585312b777cd96c33e71) Thanks [@threepointone](https://github.com/threepointone)! - getCurrentAgent()
282 | 
283 | ## 0.0.68
284 | 
285 | ### Patch Changes
286 | 
287 | - [#222](https://github.com/cloudflare/agents/pull/222) [`44dc3a4`](https://github.com/cloudflare/agents/commit/44dc3a428a7026650c60af95aff64e5b12c76b04) Thanks [@threepointone](https://github.com/threepointone)! - prepend mcp tool names with server id, use nanoid everywhere
288 | 
289 | - [#221](https://github.com/cloudflare/agents/pull/221) [`f59e6a2`](https://github.com/cloudflare/agents/commit/f59e6a222fffe1422340b43ccab33c2db5251f0b) Thanks [@ruifigueira](https://github.com/ruifigueira)! - Support server as promises in McpAgent
290 | 
291 | ## 0.0.67
292 | 
293 | ### Patch Changes
294 | 
295 | - [#219](https://github.com/cloudflare/agents/pull/219) [`aa5f972`](https://github.com/cloudflare/agents/commit/aa5f972ee2942107addafd45d6163ae56579f862) Thanks [@jmorrell-cloudflare](https://github.com/jmorrell-cloudflare)! - Fix type error for McpAgent.serve and McpAgent.serveSSE
296 | 
297 | ## 0.0.66
298 | 
299 | ### Patch Changes
300 | 
301 | - [#215](https://github.com/cloudflare/agents/pull/215) [`be4b7a3`](https://github.com/cloudflare/agents/commit/be4b7a38e7f462cfeed2da0812f0782b23767b9d) Thanks [@threepointone](https://github.com/threepointone)! - update deps
302 | 
303 | - [`843745d`](https://github.com/cloudflare/agents/commit/843745dfd5cec77463aa00021d841c2ed1abf51d) Thanks [@threepointone](https://github.com/threepointone)! - Thanks @brettimus for #105: Propagate cancellation signals from useAgentChat to ChatAgent
304 | 
305 | - [#217](https://github.com/cloudflare/agents/pull/217) [`8d8216c`](https://github.com/cloudflare/agents/commit/8d8216c1e233fabf779994578da6447f1d20cf2b) Thanks [@threepointone](https://github.com/threepointone)! - Add .mcp to the Agent class, and add a helper to McpClientManager to convert tools to work with AI SDK
306 | 
307 | - [#212](https://github.com/cloudflare/agents/pull/212) [`5342ce4`](https://github.com/cloudflare/agents/commit/5342ce4f67485b2199eed6f4cd6027330964c60f) Thanks [@pbteja1998](https://github.com/pbteja1998)! - do not remove search params and hash from mcp endpoint message
308 | 
309 | ## 0.0.65
310 | 
311 | ### Patch Changes
312 | 
313 | - [#205](https://github.com/cloudflare/agents/pull/205) [`3f532ba`](https://github.com/cloudflare/agents/commit/3f532bafda1a24ab6a2e8872302093bbc5b51b61) Thanks [@threepointone](https://github.com/threepointone)! - Let .server on McpAgent be a Server or McpServer
314 | 
315 | - [#208](https://github.com/cloudflare/agents/pull/208) [`85d8edd`](https://github.com/cloudflare/agents/commit/85d8eddc7ab62499cc27100adcd0894be0c8c974) Thanks [@a-type](https://github.com/a-type)! - Fix: resolved a problem in useAgentChat where initial messages would be refetched on re-render when using React StrictMode
316 | 
317 | ## 0.0.64
318 | 
319 | ### Patch Changes
320 | 
321 | - [#206](https://github.com/cloudflare/agents/pull/206) [`0c4b61c`](https://github.com/cloudflare/agents/commit/0c4b61cc78d6520523eed23a41b0b851ac763753) Thanks [@threepointone](https://github.com/threepointone)! - mcp client: result schema and options are optional
322 | 
323 | ## 0.0.63
324 | 
325 | ### Patch Changes
326 | 
327 | - [#202](https://github.com/cloudflare/agents/pull/202) [`1e060d3`](https://github.com/cloudflare/agents/commit/1e060d361d1b49aef3717f9d760d521577c06ff9) Thanks [@jmorrell-cloudflare](https://github.com/jmorrell-cloudflare)! - await stream writer calls in websocket handlers
328 | 
329 | - [#199](https://github.com/cloudflare/agents/pull/199) [`717b21f`](https://github.com/cloudflare/agents/commit/717b21f7763362c8c1321e9befb037dc6664f433) Thanks [@pauldraper](https://github.com/pauldraper)! - Add missing dependencies to agents
330 | 
331 | - [#203](https://github.com/cloudflare/agents/pull/203) [`f5b5854`](https://github.com/cloudflare/agents/commit/f5b5854aee4f3487974f4ac6452c1064181c1809) Thanks [@jmorrell-cloudflare](https://github.com/jmorrell-cloudflare)! - Jmorrell/fix streamable hibernation issue
332 | 
333 | - [#186](https://github.com/cloudflare/agents/pull/186) [`90db5ba`](https://github.com/cloudflare/agents/commit/90db5ba878b48ad831ba889d0dff475268971943) Thanks [@jmorrell-cloudflare](https://github.com/jmorrell-cloudflare)! - Rename McpAgent.mount to McpAgent.serveSSE with McpAgent.mount serving as an alias for backward compatibility
334 | 
335 | - [#186](https://github.com/cloudflare/agents/pull/186) [`90db5ba`](https://github.com/cloudflare/agents/commit/90db5ba878b48ad831ba889d0dff475268971943) Thanks [@jmorrell-cloudflare](https://github.com/jmorrell-cloudflare)! - Update dependencies
336 | 
337 | ## 0.0.62
338 | 
339 | ### Patch Changes
340 | 
341 | - [#197](https://github.com/cloudflare/agents/pull/197) [`b30ffda`](https://github.com/cloudflare/agents/commit/b30ffda6d7bfd11f5346310c8cdb0f369f505560) Thanks [@threepointone](https://github.com/threepointone)! - fix websocket missing message trigger
342 | 
343 | ## 0.0.61
344 | 
345 | ### Patch Changes
346 | 
347 | - [#196](https://github.com/cloudflare/agents/pull/196) [`ba5a5fe`](https://github.com/cloudflare/agents/commit/ba5a5fedae6b8ea6e83a3116ea115f5a9465ef0a) Thanks [@threepointone](https://github.com/threepointone)! - expose persistMessages on AIChatAgent
348 | 
349 | - [#126](https://github.com/cloudflare/agents/pull/126) [`1bfd6a7`](https://github.com/cloudflare/agents/commit/1bfd6a77f2c2019b54f40f5a72ff7e4b4df57157) Thanks [@nickfujita](https://github.com/nickfujita)! - Add ai-types to esm exports
350 | 
351 | ## 0.0.60
352 | 
353 | ### Patch Changes
354 | 
355 | - [#173](https://github.com/cloudflare/agents/pull/173) [`49fb428`](https://github.com/cloudflare/agents/commit/49fb4282870c77ab9f3ab2a4ae49b7b60cabbfb2) Thanks [@cmsparks](https://github.com/cmsparks)! - fix: require authProvider on client connect and handle client "Method not found" initialization errors
356 | 
357 | ## 0.0.59
358 | 
359 | ### Patch Changes
360 | 
361 | - [#168](https://github.com/cloudflare/agents/pull/168) [`2781f7d`](https://github.com/cloudflare/agents/commit/2781f7d7275bfada743c6c5531aab42db5e675a7) Thanks [@threepointone](https://github.com/threepointone)! - update deps
362 | 
363 | ## 0.0.58
364 | 
365 | ### Patch Changes
366 | 
367 | - [`33b22fe`](https://github.com/cloudflare/agents/commit/33b22fe146bb8b721b4d33c607a044ea64c0706a) Thanks [@threepointone](https://github.com/threepointone)! - don't import WorkflowEntrypoint
368 | 
369 |   fixes https://github.com/cloudflare/agents/issues/166
370 | 
371 | ## 0.0.57
372 | 
373 | ### Patch Changes
374 | 
375 | - [#163](https://github.com/cloudflare/agents/pull/163) [`956c772`](https://github.com/cloudflare/agents/commit/956c772712962dfeef21d2b7ab6740600b308596) Thanks [@brishin](https://github.com/brishin)! - Fix: Missing agent dep in useCallback
376 | 
377 | - [#164](https://github.com/cloudflare/agents/pull/164) [`3824fd4`](https://github.com/cloudflare/agents/commit/3824fd4dfdd99c80cba5ea031e950a460d495256) Thanks [@threepointone](https://github.com/threepointone)! - revert https://github.com/cloudflare/agents/pull/161
378 | 
379 | ## 0.0.56
380 | 
381 | ### Patch Changes
382 | 
383 | - [#161](https://github.com/cloudflare/agents/pull/161) [`1f6598e`](https://github.com/cloudflare/agents/commit/1f6598eda2d6c4528797870fe74529e41142ff96) Thanks [@threepointone](https://github.com/threepointone)! - mcp: remove duplicate agent init, await root .init()
384 | 
385 | ## 0.0.55
386 | 
387 | ### Patch Changes
388 | 
389 | - [#159](https://github.com/cloudflare/agents/pull/159) [`b8377c1`](https://github.com/cloudflare/agents/commit/b8377c1efcd00fa2719676edc9e8d2ef02a20a23) Thanks [@jmorrell-cloudflare](https://github.com/jmorrell-cloudflare)! - Fix issues with McpAgent and setState introduced by hibernation changes
390 | 
391 | ## 0.0.54
392 | 
393 | ### Patch Changes
394 | 
395 | - [#140](https://github.com/cloudflare/agents/pull/140) [`2f5cb3a`](https://github.com/cloudflare/agents/commit/2f5cb3ac4a9fbb9dc79b137b74336681f60be5a0) Thanks [@cmsparks](https://github.com/cmsparks)! - Remote MCP Client with auth support
396 | 
397 |   This PR adds:
398 |   - Support for authentication for MCP Clients (Via a DO based auth provider)
399 |   - Some improvements to the client API per #135
400 |   - A more in depth example of MCP Client, which allows you to add any number of remote MCP servers with or without auth
401 | 
402 | ## 0.0.53
403 | 
404 | ### Patch Changes
405 | 
406 | - [#149](https://github.com/cloudflare/agents/pull/149) [`49e8b36`](https://github.com/cloudflare/agents/commit/49e8b362d77a68f2e891f655b9971b737e394f9e) Thanks [@irvinebroque](https://github.com/irvinebroque)! - Automatically change "/" path to "/\*" in MCP server mount() method
407 | 
408 | ## 0.0.52
409 | 
410 | ### Patch Changes
411 | 
412 | - [#151](https://github.com/cloudflare/agents/pull/151) [`e376805`](https://github.com/cloudflare/agents/commit/e376805ccd88b08e853b1894cc703e6f67f2ed1d) Thanks [@threepointone](https://github.com/threepointone)! - useAgent: don't throw when `query` is an async url provider
413 | 
414 | ## 0.0.51
415 | 
416 | ### Patch Changes
417 | 
418 | - [#146](https://github.com/cloudflare/agents/pull/146) [`316f98c`](https://github.com/cloudflare/agents/commit/316f98c3f70792f6daa86d3e92f8a466b5509bb5) Thanks [@threepointone](https://github.com/threepointone)! - remove lowercase warning for agent names
419 | 
420 | ## 0.0.50
421 | 
422 | ### Patch Changes
423 | 
424 | - [#142](https://github.com/cloudflare/agents/pull/142) [`1461795`](https://github.com/cloudflare/agents/commit/146179598b05945ee07e95261e6a83979c9a07d9) Thanks [@threepointone](https://github.com/threepointone)! - ai-chat-agent: pass query params correctly in /get-messages
425 | 
426 | ## 0.0.49
427 | 
428 | ### Patch Changes
429 | 
430 | - [#138](https://github.com/cloudflare/agents/pull/138) [`3bbbf81`](https://github.com/cloudflare/agents/commit/3bbbf812bbe3d1a2c3252e88a0ca49c7127b4820) Thanks [@geelen](https://github.com/geelen)! - Fixed internal build issue that caused incomplete package to be published
431 | 
432 | ## 0.0.48
433 | 
434 | ### Patch Changes
435 | 
436 | - [#125](https://github.com/cloudflare/agents/pull/125) [`62d4e85`](https://github.com/cloudflare/agents/commit/62d4e854e76204737c8b3bd7392934f37abeb3ca) Thanks [@cmsparks](https://github.com/cmsparks)! - MCP Client x Agents Implementation
437 | 
438 | - [#128](https://github.com/cloudflare/agents/pull/128) [`df716f2`](https://github.com/cloudflare/agents/commit/df716f2911acfc0e7461d3698f8e1b06947ea38b) Thanks [@jmorrell-cloudflare](https://github.com/jmorrell-cloudflare)! - MCP: Hibernate-able transport
439 | 
440 | - [#137](https://github.com/cloudflare/agents/pull/137) [`c3e8618`](https://github.com/cloudflare/agents/commit/c3e8618fbe64565e3bf039331a445c12945bf9ed) Thanks [@threepointone](https://github.com/threepointone)! - convert input `agent` in clients to kebab-case as expected by the server
441 | 
442 | ## 0.0.47
443 | 
444 | ### Patch Changes
445 | 
446 | - [#133](https://github.com/cloudflare/agents/pull/133) [`6dc3b6a`](https://github.com/cloudflare/agents/commit/6dc3b6aa2b4137f0a3022932d2038def9e03f5d2) Thanks [@threepointone](https://github.com/threepointone)! - remove description as an arg from getSchedules
447 | 
448 | - [#130](https://github.com/cloudflare/agents/pull/130) [`7ff0509`](https://github.com/cloudflare/agents/commit/7ff050994c223bbd1cb390e3a085b31023c2554f) Thanks [@threepointone](https://github.com/threepointone)! - update deps
449 | 
450 | ## 0.0.46
451 | 
452 | ### Patch Changes
453 | 
454 | - [`7c40201`](https://github.com/cloudflare/agents/commit/7c402012fa43c606e5455a13604ef7a6369989ed) Thanks [@threepointone](https://github.com/threepointone)! - mark context as unstable\_
455 | 
456 | ## 0.0.45
457 | 
458 | ### Patch Changes
459 | 
460 | - [#122](https://github.com/cloudflare/agents/pull/122) [`d045755`](https://github.com/cloudflare/agents/commit/d045755a3f465481531ca7556317c0a0be811438) Thanks [@threepointone](https://github.com/threepointone)! - `import {context} from 'agents';`
461 | 
462 |   Export the current agent, request, and connection from a shared context. Particularly useful for tool calls that might not have access to the current agent in their module scope.
463 | 
464 | ## 0.0.44
465 | 
466 | ### Patch Changes
467 | 
468 | - [#118](https://github.com/cloudflare/agents/pull/118) [`6e66bd4`](https://github.com/cloudflare/agents/commit/6e66bd4471d1eef10043297208033bd172898f10) Thanks [@max-stytch](https://github.com/max-stytch)! - fix: Pass Env param thru to DurableObject definition
469 | 
470 | - [#121](https://github.com/cloudflare/agents/pull/121) [`82d5412`](https://github.com/cloudflare/agents/commit/82d54121a6fa8c035a1e2d6b036165eae0624899) Thanks [@threepointone](https://github.com/threepointone)! - update deps
471 | 
472 | ## 0.0.43
473 | 
474 | ### Patch Changes
475 | 
476 | - [#111](https://github.com/cloudflare/agents/pull/111) [`eb6827a`](https://github.com/cloudflare/agents/commit/eb6827a8b97b3ce5f7e06afbe83a01201350d26a) Thanks [@threepointone](https://github.com/threepointone)! - update deps
477 | 
478 |   replace the beta release of partysocket with a real one
479 | 
480 | ## 0.0.42
481 | 
482 | ### Patch Changes
483 | 
484 | - [#107](https://github.com/cloudflare/agents/pull/107) [`4f3dfc7`](https://github.com/cloudflare/agents/commit/4f3dfc710797697aedaa29cef64923533a2cb071) Thanks [@threepointone](https://github.com/threepointone)! - update deps, allow sub/path/prefix, AND_BINDINGS_LIKE_THIS
485 | 
486 |   of note,
487 |   - the partyserver update now allows for prefixes that/have/sub/paths
488 |   - bindings THAT_LOOK_LIKE_THIS are correctly converted to kebabcase now
489 | 
490 | ## 0.0.41
491 | 
492 | ### Patch Changes
493 | 
494 | - [#106](https://github.com/cloudflare/agents/pull/106) [`1d1b74c`](https://github.com/cloudflare/agents/commit/1d1b74ce9f4a5f5fc698da280da71c08f0a7c7ce) Thanks [@geelen](https://github.com/geelen)! - Adding the first iteration of McpAgent
495 | 
496 | - [#103](https://github.com/cloudflare/agents/pull/103) [`9be8008`](https://github.com/cloudflare/agents/commit/9be80083a80a89c1b106599bda28d4a8aa7292f2) Thanks [@threepointone](https://github.com/threepointone)! - update deps
497 | 
498 | ## 0.0.40
499 | 
500 | ### Patch Changes
501 | 
502 | - [#100](https://github.com/cloudflare/agents/pull/100) [`ee727ca`](https://github.com/cloudflare/agents/commit/ee727caf52071221fbf79fd651f37ce12185bdae) Thanks [@danieljvdm](https://github.com/danieljvdm)! - Pass state generic through `useAgentChat`
503 | 
504 | ## 0.0.39
505 | 
506 | ### Patch Changes
507 | 
508 | - [#96](https://github.com/cloudflare/agents/pull/96) [`d7d2876`](https://github.com/cloudflare/agents/commit/d7d287608fcdf78a4c914ee0590ea4ef8e81623f) Thanks [@threepointone](https://github.com/threepointone)! - update deps
509 | 
510 | ## 0.0.38
511 | 
512 | ### Patch Changes
513 | 
514 | - [#94](https://github.com/cloudflare/agents/pull/94) [`fb4d0a6`](https://github.com/cloudflare/agents/commit/fb4d0a6a564824a7faba02d7a181ae4b170ba820) Thanks [@threepointone](https://github.com/threepointone)! - better error handling (based on #65 by @elithrar)
515 |   - implement `this.onError` for custom error handling
516 |   - log errors from more places
517 |   - catch some missed async errors and log them
518 |   - mark some methods as actually private
519 | 
520 | ## 0.0.37
521 | 
522 | ### Patch Changes
523 | 
524 | - [#92](https://github.com/cloudflare/agents/pull/92) [`fbaa8f7`](https://github.com/cloudflare/agents/commit/fbaa8f799d1c666aba57b38bfc342580f19be70e) Thanks [@threepointone](https://github.com/threepointone)! - Renamed agents-sdk -> agents
525 | 
526 | ## 0.0.36
527 | 
528 | ### Patch Changes
529 | 
530 | - [#74](https://github.com/cloudflare/agents/pull/74) [`7bcdd83`](https://github.com/cloudflare/agents/commit/7bcdd8396d6789b1fc7323be465fbd61311c5181) Thanks [@gingerhendrix](https://github.com/gingerhendrix)! - Replace discriminatedUnion with simple object for Gemini models
531 | 
532 | ## 0.0.35
533 | 
534 | ### Patch Changes
535 | 
536 | - [#88](https://github.com/cloudflare/agents/pull/88) [`7532166`](https://github.com/cloudflare/agents/commit/7532166ecfc2bcf4f169907d0dd9c399336212ac) Thanks [@threepointone](https://github.com/threepointone)! - pass `cors:true` to `routeAgentRequest` to automatically use across domains
537 | 
538 | ## 0.0.34
539 | 
540 | ### Patch Changes
541 | 
542 | - [`39197ab`](https://github.com/cloudflare/agents/commit/39197ab65a08784b4d5851d5844cb5287c43040e) Thanks [@threepointone](https://github.com/threepointone)! - remove `cf_agent_chat_init` message
543 | 
544 | ## 0.0.33
545 | 
546 | ### Patch Changes
547 | 
548 | - [#85](https://github.com/cloudflare/agents/pull/85) [`acbc34e`](https://github.com/cloudflare/agents/commit/acbc34e0122835fbeae3a18b88932cc1b0a1802d) Thanks [@threepointone](https://github.com/threepointone)! - Add RPC support with `unstable_callable` decorator for method exposure. This feature enables:
549 |   - Remote procedure calls from clients to agents
550 |   - Method decoration with `@unstable_callable` to expose agent methods
551 |   - Support for both regular and streaming RPC calls
552 |   - Type-safe RPC calls with automatic response handling
553 |   - Real-time streaming responses for long-running operations
554 | 
555 |   Note: The `callable` decorator has been renamed to `unstable_callable` to indicate its experimental status.
556 | 
557 | ## 0.0.32
558 | 
559 | ### Patch Changes
560 | 
561 | - [#83](https://github.com/cloudflare/agents/pull/83) [`a9248c7`](https://github.com/cloudflare/agents/commit/a9248c74c3b7af2a0085d15f02712c243e870cc3) Thanks [@threepointone](https://github.com/threepointone)! - add state sync to the regular agent client
562 | 
563 |   fixes https://github.com/cloudflare/agents/issues/9
564 | 
565 | ## 0.0.31
566 | 
567 | ### Patch Changes
568 | 
569 | - [`2c077c7`](https://github.com/cloudflare/agents/commit/2c077c7e800d20679afe23a37b6bbbec87ed53ac) Thanks [@threepointone](https://github.com/threepointone)! - warn if agent/name passed to client isn't in lowercase
570 | 
571 | ## 0.0.30
572 | 
573 | ### Patch Changes
574 | 
575 | - [`db70ceb`](https://github.com/cloudflare/agents/commit/db70ceb22e8d27717ca13cbdcf9d6364a792d1ab) Thanks [@threepointone](https://github.com/threepointone)! - fix async/await error for useAgentChat
576 | 
577 | ## 0.0.29
578 | 
579 | ### Patch Changes
580 | 
581 | - [#79](https://github.com/cloudflare/agents/pull/79) [`1dad549`](https://github.com/cloudflare/agents/commit/1dad5492fbf7e07af76da83767b48af56c503763) Thanks [@threepointone](https://github.com/threepointone)! - clear initial message cache on unmount, add getInitialMessages
582 | 
583 |   This clears the initial messages cache whenever useAgentChat is unmounted. Additionally, it adds a getInitialMessages option to pass your own custom method for setting initial messages. Setting getInitialMessages:null disables any fetch for initial messages, so that the user can populate initialMessages by themselves if they'd like.
584 | 
585 |   I also added a chat example to the playground.
586 | 
587 | ## 0.0.28
588 | 
589 | ### Patch Changes
590 | 
591 | - [`8ade3af`](https://github.com/cloudflare/agents/commit/8ade3af36d1b18636adfeb2491805e1368fba9d7) Thanks [@threepointone](https://github.com/threepointone)! - export Schedule type
592 | 
593 | - [#77](https://github.com/cloudflare/agents/pull/77) [`82f277d`](https://github.com/cloudflare/agents/commit/82f277d118b925af822e147240aa9918a5f3851e) Thanks [@threepointone](https://github.com/threepointone)! - pass credentials to get-messages call
594 | 
595 | ## 0.0.27
596 | 
597 | ### Patch Changes
598 | 
599 | - [`5b96c8a`](https://github.com/cloudflare/agents/commit/5b96c8a2cb26c683b34d41783eaced74216092e1) Thanks [@threepointone](https://github.com/threepointone)! - unstable\_ scheduling prompt helper shouldn't take input text
600 | 
601 | ## 0.0.26
602 | 
603 | ### Patch Changes
604 | 
605 | - [`06c4386`](https://github.com/cloudflare/agents/commit/06c438620873068499d757fb9fcef11c48c0e558) Thanks [@threepointone](https://github.com/threepointone)! - update deps
606 | 
607 | - [#62](https://github.com/cloudflare/agents/pull/62) [`2d680f3`](https://github.com/cloudflare/agents/commit/2d680f3cccc200afdfe456e9432b645247fbce9a) Thanks [@threepointone](https://github.com/threepointone)! - unstable\_ scheduling helpers
608 | 
609 | - [`48ff237`](https://github.com/cloudflare/agents/commit/48ff2376087c71e6e7316c85c86e7e0559d57222) Thanks [@threepointone](https://github.com/threepointone)! - (for @sam-goodwin, #58) fix: pass headers to /get-messages
610 | 
611 | ## 0.0.25
612 | 
613 | ### Patch Changes
614 | 
615 | - [#53](https://github.com/cloudflare/agents/pull/53) [`877d551`](https://github.com/cloudflare/agents/commit/877d55169a49a767b703e39e0032a4df6681709f) Thanks [@deathbyknowledge](https://github.com/deathbyknowledge)! - fix onMessage not getting called
616 | 
617 | ## 0.0.24
618 | 
619 | ### Patch Changes
620 | 
621 | - [#51](https://github.com/cloudflare/agents/pull/51) [`b244068`](https://github.com/cloudflare/agents/commit/b244068c7266f048493b3796393cfa74bbbd9ec1) Thanks [@elithrar](https://github.com/elithrar)! - Fixes a bug with JSON parsing and the React state hooks.
622 | 
623 | ## 0.0.23
624 | 
625 | ### Patch Changes
626 | 
627 | - [#46](https://github.com/cloudflare/agents/pull/46) [`6efb950`](https://github.com/cloudflare/agents/commit/6efb9502612189f4a6f06435fc908e65af65eb88) Thanks [@threepointone](https://github.com/threepointone)! - update deps
628 | 
629 | - [#49](https://github.com/cloudflare/agents/pull/49) [`653ebad`](https://github.com/cloudflare/agents/commit/653ebadcfd49b57595a6ecb010467d3810742b93) Thanks [@threepointone](https://github.com/threepointone)! - add linting, fix a bunch of bugs.
630 | 
631 | ## 0.0.22
632 | 
633 | ### Patch Changes
634 | 
635 | - [#39](https://github.com/cloudflare/agents/pull/39) [`2afea20`](https://github.com/cloudflare/agents/commit/2afea2023d96204fbe6829c400c7a22baedbad2f) Thanks [@elithrar](https://github.com/elithrar)! - adds JSDoc to public symbols.
636 | 
637 | ## 0.0.21
638 | 
639 | ### Patch Changes
640 | 
641 | - [#37](https://github.com/cloudflare/agents/pull/37) [`ff0679f`](https://github.com/cloudflare/agents/commit/ff0679f638d377c8629a1fd2762c58045ec397b5) Thanks [@threepointone](https://github.com/threepointone)! - `Agent::initialState`
642 | 
643 |   You can now set an initial state for an agent
644 | 
645 |   ```ts
646 |   type State = {
647 |     counter: number;
648 |     text: string;
649 |     color: string;
650 |   };
651 | 
652 |   class MyAgent extends Agent<Env, State> {
653 |     initialState = {
654 |       counter: 0,
655 |       text: "",
656 |       color: "#3B82F6"
657 |     };
658 | 
659 |     doSomething() {
660 |       console.log(this.state); // {counter: 0, text: "", color: "#3B82F6"}, if you haven't set the state yet
661 |     }
662 |   }
663 |   ```
664 | 
665 |   As before, this gets synced to useAgent, so you can do:
666 | 
667 |   ```ts
668 |   const [state, setState] = useState<State>();
669 |   const agent = useAgent<State>({
670 |     agent: "my-agent",
671 |     onStateUpdate: (state) => {
672 |       setState(state);
673 |     }
674 |   });
675 |   ```
676 | 
677 | ## 0.0.20
678 | 
679 | ### Patch Changes
680 | 
681 | - [#32](https://github.com/cloudflare/agents/pull/32) [`3d4e0f9`](https://github.com/cloudflare/agents/commit/3d4e0f9db69303dd2f93de37b4f54fefacb18a33) Thanks [@Cherry](https://github.com/Cherry)! - fix: add repo/bug tracker links to packages
682 | 
683 | ## 0.0.19
684 | 
685 | ### Patch Changes
686 | 
687 | - [`9938444`](https://github.com/cloudflare/agents/commit/9938444b0d8d1b4910fc50647ed223a22af564a4) Thanks [@threepointone](https://github.com/threepointone)! - scheduling: do a typecheck/throw error if not a valid method on this
688 | 
689 | ## 0.0.18
690 | 
691 | ### Patch Changes
692 | 
693 | - [`7149fd2`](https://github.com/cloudflare/agents/commit/7149fd27371cd13ae9814bb52f777c6ffc99af62) Thanks [@threepointone](https://github.com/threepointone)! - don't log when state updates on the server
694 | 
695 | ## 0.0.17
696 | 
697 | ### Patch Changes
698 | 
699 | - [`54962fe`](https://github.com/cloudflare/agents/commit/54962fe37c09be752fb8d713827337986ad6343a) Thanks [@threepointone](https://github.com/threepointone)! - trigger a release
700 | 
701 | ## 0.0.16
702 | 
703 | ### Patch Changes
704 | 
705 | - [`d798d99`](https://github.com/cloudflare/agents/commit/d798d9959030337dce50602ab3fbd23586379e69) Thanks [@threepointone](https://github.com/threepointone)! - don't bork if connection disconnects
706 | 
707 | - [`fd17e02`](https://github.com/cloudflare/agents/commit/fd17e021a2aacf8c55b2d2ad181589d5bce79893) Thanks [@threepointone](https://github.com/threepointone)! - respond to server saved messages
708 | 
709 | - [`90fe787`](https://github.com/cloudflare/agents/commit/90fe7878ff0be64a41023070cc77742e49ec542e) Thanks [@threepointone](https://github.com/threepointone)! - fix scheduler implementation/types
710 | 
711 | ## 0.0.15
712 | 
713 | ### Patch Changes
714 | 
715 | - [`9075920`](https://github.com/cloudflare/agents/commit/9075920b732160ca7456ae394812a30f32c99f70) Thanks [@threepointone](https://github.com/threepointone)! - change onChatMessage signature
716 | 
717 | ## 0.0.14
718 | 
719 | ### Patch Changes
720 | 
721 | - [`2610509`](https://github.com/cloudflare/agents/commit/26105091622cef2c2f8aae60d4e673587d142739) Thanks [@threepointone](https://github.com/threepointone)! - Hono Agents
722 | 
723 | - [`7a3a1a0`](https://github.com/cloudflare/agents/commit/7a3a1a049adfe3d125696ce65881d04eb0ebe8df) Thanks [@threepointone](https://github.com/threepointone)! - AgentContext
724 | 
725 | ## 0.0.13
726 | 
727 | ### Patch Changes
728 | 
729 | - [`066c378`](https://github.com/cloudflare/agents/commit/066c378f4bcfaf2aa231e4e898bf2e22dc81f9f1) Thanks [@threepointone](https://github.com/threepointone)! - setState() doesn't take source anymore
730 | 
731 | ## 0.0.12
732 | 
733 | ### Patch Changes
734 | 
735 | - [`2864acf`](https://github.com/cloudflare/agents/commit/2864acfeab983efa3316c44f339cddb5bc86cd14) Thanks [@threepointone](https://github.com/threepointone)! - chat agent can now saveMessages explicitly
736 | 
737 | ## 0.0.11
738 | 
739 | ### Patch Changes
740 | 
741 | - [`7035ef5`](https://github.com/cloudflare/agents/commit/7035ef5327b650a11f721c08b57373a294354e9a) Thanks [@threepointone](https://github.com/threepointone)! - trigger a release
742 | 
743 | ## 0.0.10
744 | 
745 | ### Patch Changes
746 | 
747 | - [#15](https://github.com/cloudflare/agents/pull/15) [`ecd9324`](https://github.com/cloudflare/agents/commit/ecd9324d8470c521dd3566446d7afae1fa0c1b9f) Thanks [@elithrar](https://github.com/elithrar)! - env type fixes
748 | 
749 | ## 0.0.9
750 | 
751 | ### Patch Changes
752 | 
753 | - [`8335b4b`](https://github.com/cloudflare/agents/commit/8335b4bdfc17d4cc47ca5b03d0dad7f9c64ce6a1) Thanks [@threepointone](https://github.com/threepointone)! - fix some types
754 | 
755 | ## 0.0.8
756 | 
757 | ### Patch Changes
758 | 
759 | - [`619dac5`](https://github.com/cloudflare/agents/commit/619dac55e11543609f2a0869b6a3f05a78fa83fd) Thanks [@threepointone](https://github.com/threepointone)! - new useChat, with multiplayer, syncing, persistence; updated HITL guide with useChat
760 | 
761 | ## 0.0.7
762 | 
763 | ### Patch Changes
764 | 
765 | - [`0680a02`](https://github.com/cloudflare/agents/commit/0680a0245c41959588895c0d2bd39c98ca189a38) Thanks [@threepointone](https://github.com/threepointone)! - remove email mentions from readme
766 | 
767 | ## 0.0.6
768 | 
769 | ### Patch Changes
770 | 
771 | - [`acbd0f6`](https://github.com/cloudflare/agents/commit/acbd0f6e1375a42ba1ad577b68f6a8264f6e9827) Thanks [@threepointone](https://github.com/threepointone)! - .state/.setState/.onStateUpdate
772 | 
773 | ## 0.0.5
774 | 
775 | ### Patch Changes
776 | 
777 | - [`7dab6bc`](https://github.com/cloudflare/agents/commit/7dab6bcb4429cfa02dfdb62bbce59fd29e94308f) Thanks [@threepointone](https://github.com/threepointone)! - more on agentFetch
778 | 
779 | ## 0.0.4
780 | 
781 | ### Patch Changes
782 | 
783 | - [`411c149`](https://github.com/cloudflare/agents/commit/411c1490c79373d8e7959fd90cfcdc4a0d87290f) Thanks [@threepointone](https://github.com/threepointone)! - actually fix client fetch
784 | 
785 | ## 0.0.3
786 | 
787 | ### Patch Changes
788 | 
789 | - [`40bfbef`](https://github.com/cloudflare/agents/commit/40bfbefb3d7a0b15ae83e91d76bba8c8bb62be92) Thanks [@threepointone](https://github.com/threepointone)! - fix client.fetch
790 | 
791 | ## 0.0.2
792 | 
793 | ### Patch Changes
794 | 
795 | - [`3f1ad74`](https://github.com/cloudflare/agents/commit/3f1ad7466bb74574131cd4ffdf7ce4d116f03d70) Thanks [@threepointone](https://github.com/threepointone)! - export some types, use a default agent name
796 | 
797 | ## 0.0.1
798 | 
799 | ### Patch Changes
800 | 
801 | - [`eaba262`](https://github.com/cloudflare/agents/commit/eaba262167e8b10d55fc88e4bcdb26ba17879261) Thanks [@threepointone](https://github.com/threepointone)! - do a release
802 | 


--------------------------------------------------------------------------------
/packages/agents/README.md:
--------------------------------------------------------------------------------
  1 | ### 🧠 `agents` - A Framework for Digital Intelligence
  2 | 
  3 | ![agents-header](https://github.com/user-attachments/assets/f6d99eeb-1803-4495-9c5e-3cf07a37b402)
  4 | 
  5 | Welcome to a new chapter in software development, where AI agents persist, think, and act with purpose. The `agents` framework creates an environment where artificial intelligence can flourish - maintaining state, engaging in meaningful interactions, and evolving over time.
  6 | 
  7 | _This project is in active development. Join us in shaping the future of intelligent agents._
  8 | 
  9 | #### The Nature of Agents
 10 | 
 11 | An AI agent transcends traditional software boundaries. It's an entity that:
 12 | 
 13 | - **Persistence**: Maintains its state and knowledge across time
 14 | - **Agency**: Acts autonomously within its defined purpose
 15 | - **Connection**: Communicates through multiple channels with both humans and other agents
 16 | - **Growth**: Learns and adapts through its interactions
 17 | 
 18 | Built on Cloudflare's global network, this framework provides agents with a reliable, distributed foundation where they can operate continuously and effectively.
 19 | 
 20 | #### 💫 Core Principles
 21 | 
 22 | 1. **Stateful Existence**: Each agent maintains its own persistent reality
 23 | 2. **Long-lived Presence**: Agents can run for extended periods, resting when idle
 24 | 3. **Natural Communication**: Interact through HTTP, WebSockets, or direct calls
 25 | 4. **Global Distribution**: Leverage Cloudflare's network for worldwide presence
 26 | 5. **Resource Harmony**: Efficient hibernation and awakening as needed
 27 | 
 28 | ---
 29 | 
 30 | ### 🌱 Beginning the Journey
 31 | 
 32 | Start with a complete environment:
 33 | 
 34 | ```sh
 35 | # Create a new project
 36 | npm create cloudflare@latest -- --template cloudflare/agents-starter
 37 | 
 38 | # Or enhance an existing one
 39 | npm install agents
 40 | ```
 41 | 
 42 | ### 📝 Your First Agent
 43 | 
 44 | Create an agent that bridges thought and action:
 45 | 
 46 | ```ts
 47 | import { Agent } from "agents";
 48 | 
 49 | export class IntelligentAgent extends Agent {
 50 |   async onRequest(request) {
 51 |     // Transform intention into response
 52 |     return new Response("Ready to assist.");
 53 |   }
 54 | }
 55 | ```
 56 | 
 57 | ### 🎭 Patterns of Intelligence
 58 | 
 59 | Agents can manifest various forms of understanding:
 60 | 
 61 | ```ts
 62 | import { Agent } from "agents";
 63 | import { OpenAI } from "openai";
 64 | 
 65 | export class AIAgent extends Agent {
 66 |   async onRequest(request) {
 67 |     // Connect with AI capabilities
 68 |     const ai = new OpenAI({
 69 |       apiKey: this.env.OPENAI_API_KEY
 70 |     });
 71 | 
 72 |     // Process and understand
 73 |     const response = await ai.chat.completions.create({
 74 |       model: "gpt-4",
 75 |       messages: [{ role: "user", content: await request.text() }]
 76 |     });
 77 | 
 78 |     return new Response(response.choices[0].message.content);
 79 |   }
 80 | 
 81 |   async processTask(task) {
 82 |     await this.understand(task);
 83 |     await this.act();
 84 |     await this.reflect();
 85 |   }
 86 | }
 87 | ```
 88 | 
 89 | ### 🏰 Creating Space
 90 | 
 91 | Define your agent's domain:
 92 | 
 93 | ```jsonc
 94 | {
 95 |   "durable_objects": {
 96 |     "bindings": [
 97 |       {
 98 |         "name": "AIAgent",
 99 |         "class_name": "AIAgent"
100 |       }
101 |     ]
102 |   },
103 |   "migrations": [
104 |     {
105 |       "tag": "v1",
106 |       // Mandatory for the Agent to store state
107 |       "new_sqlite_classes": ["AIAgent"]
108 |     }
109 |   ]
110 | }
111 | ```
112 | 
113 | ### 🌐 Lifecycle
114 | 
115 | Bring your agent into being:
116 | 
117 | ```ts
118 | // Create a new instance
119 | const id = env.AIAgent.newUniqueId();
120 | const agent = env.AIAgent.get(id);
121 | 
122 | // Initialize with purpose
123 | await agent.processTask({
124 |   type: "analysis",
125 |   context: "incoming_data",
126 |   parameters: initialConfig
127 | });
128 | 
129 | // Or reconnect with an existing one
130 | const existingAgent = await getAgentByName(env.AIAgent, "data-analyzer");
131 | ```
132 | 
133 | ### 🔄 Paths of Communication
134 | 
135 | #### HTTP Understanding
136 | 
137 | Process and respond to direct requests:
138 | 
139 | ```ts
140 | export class APIAgent extends Agent {
141 |   async onRequest(request) {
142 |     const data = await request.json();
143 | 
144 |     return Response.json({
145 |       insight: await this.process(data),
146 |       moment: Date.now()
147 |     });
148 |   }
149 | }
150 | ```
151 | 
152 | #### Persistent Connections
153 | 
154 | Maintain ongoing dialogues through WebSocket:
155 | 
156 | ```ts
157 | export class DialogueAgent extends Agent {
158 |   async onConnect(connection) {
159 |     await this.initiate(connection);
160 |   }
161 | 
162 |   async onMessage(connection, message) {
163 |     const understanding = await this.comprehend(message);
164 |     await this.respond(connection, understanding);
165 |   }
166 | }
167 | ```
168 | 
169 | #### Client Communion
170 | 
171 | For direct connection to your agent:
172 | 
173 | ```ts
174 | import { AgentClient } from "agents/client";
175 | 
176 | const connection = new AgentClient({
177 |   agent: "dialogue-agent",
178 |   name: "insight-seeker"
179 | });
180 | 
181 | connection.addEventListener("message", (event) => {
182 |   console.log("Received:", event.data);
183 | });
184 | 
185 | connection.send(
186 |   JSON.stringify({
187 |     type: "inquiry",
188 |     content: "What patterns do you see?"
189 |   })
190 | );
191 | ```
192 | 
193 | #### React Integration
194 | 
195 | For harmonious integration with React:
196 | 
197 | ```tsx
198 | import { useAgent } from "agents/react";
199 | 
200 | function AgentInterface() {
201 |   const connection = useAgent({
202 |     agent: "dialogue-agent",
203 |     name: "insight-seeker",
204 |     onMessage: (message) => {
205 |       console.log("Understanding received:", message.data);
206 |     },
207 |     onOpen: () => console.log("Connection established"),
208 |     onClose: () => console.log("Connection closed")
209 |   });
210 | 
211 |   const inquire = () => {
212 |     connection.send(
213 |       JSON.stringify({
214 |         type: "inquiry",
215 |         content: "What insights have you gathered?"
216 |       })
217 |     );
218 |   };
219 | 
220 |   return (
221 |     <div className="agent-interface">
222 |       <button onClick={inquire}>Seek Understanding</button>
223 |     </div>
224 |   );
225 | }
226 | ```
227 | 
228 | ### 🌊 Flow of State
229 | 
230 | Maintain and evolve your agent's understanding:
231 | 
232 | ```ts
233 | export class ThinkingAgent extends Agent {
234 |   async evolve(newInsight) {
235 |     this.setState({
236 |       ...this.state,
237 |       insights: [...(this.state.insights || []), newInsight],
238 |       understanding: this.state.understanding + 1
239 |     });
240 |   }
241 | 
242 |   onStateUpdate(state, source) {
243 |     console.log("Understanding deepened:", {
244 |       newState: state,
245 |       origin: source
246 |     });
247 |   }
248 | }
249 | ```
250 | 
251 | Connect to your agent's state from React:
252 | 
253 | ```tsx
254 | import { useState } from "react";
255 | import { useAgent } from "agents/react";
256 | 
257 | function StateInterface() {
258 |   const [state, setState] = useState({ counter: 0 });
259 | 
260 |   const agent = useAgent({
261 |     agent: "thinking-agent",
262 |     onStateUpdate: (newState) => setState(newState)
263 |   });
264 | 
265 |   const increment = () => {
266 |     agent.setState({ counter: state.counter + 1 });
267 |   };
268 | 
269 |   return (
270 |     <div>
271 |       <div>Count: {state.counter}</div>
272 |       <button onClick={increment}>Increment</button>
273 |     </div>
274 |   );
275 | }
276 | ```
277 | 
278 | This creates a synchronized state that automatically updates across all connected clients.
279 | 
280 | ### ⏳ Temporal Patterns
281 | 
282 | Schedule moments of action and reflection:
283 | 
284 | ```ts
285 | export class TimeAwareAgent extends Agent {
286 |   async initialize() {
287 |     // Quick reflection
288 |     this.schedule(10, "quickInsight", { focus: "patterns" });
289 | 
290 |     // Daily synthesis
291 |     this.schedule("0 0 * * *", "dailySynthesis", {
292 |       depth: "comprehensive"
293 |     });
294 | 
295 |     // Milestone review
296 |     this.schedule(new Date("2024-12-31"), "yearlyAnalysis");
297 |   }
298 | 
299 |   async quickInsight(data) {
300 |     await this.analyze(data.focus);
301 |   }
302 | 
303 |   async dailySynthesis(data) {
304 |     await this.synthesize(data.depth);
305 |   }
306 | 
307 |   async yearlyAnalysis() {
308 |     await this.analyze();
309 |   }
310 | }
311 | ```
312 | 
313 | ### 💬 AI Dialogue
314 | 
315 | Create meaningful conversations with intelligence:
316 | 
317 | ```ts
318 | import { AIChatAgent } from "agents/ai-chat-agent";
319 | import { openai } from "@ai-sdk/openai";
320 | 
321 | export class DialogueAgent extends AIChatAgent {
322 |   async onChatMessage(onFinish) {
323 |     return createDataStreamResponse({
324 |       execute: async (dataStream) => {
325 |         const stream = streamText({
326 |           model: openai("gpt-4o"),
327 |           messages: this.messages,
328 |           onFinish // call onFinish so that messages get saved
329 |         });
330 | 
331 |         stream.mergeIntoDataStream(dataStream);
332 |       }
333 |     });
334 |   }
335 | }
336 | ```
337 | 
338 | #### Creating the Interface
339 | 
340 | Connect with your agent through a React interface:
341 | 
342 | ```tsx
343 | import { useAgent } from "agents/react";
344 | import { useAgentChat } from "agents/ai-react";
345 | 
346 | function ChatInterface() {
347 |   // Connect to the agent
348 |   const agent = useAgent({
349 |     agent: "dialogue-agent"
350 |   });
351 | 
352 |   // Set up the chat interaction
353 |   const { messages, input, handleInputChange, handleSubmit, clearHistory } =
354 |     useAgentChat({
355 |       agent,
356 |       maxSteps: 5
357 |     });
358 | 
359 |   return (
360 |     <div className="chat-interface">
361 |       {/* Message History */}
362 |       <div className="message-flow">
363 |         {messages.map((message) => (
364 |           <div key={message.id} className="message">
365 |             <div className="role">{message.role}</div>
366 |             <div className="content">{message.content}</div>
367 |           </div>
368 |         ))}
369 |       </div>
370 | 
371 |       {/* Input Area */}
372 |       <form onSubmit={handleSubmit} className="input-area">
373 |         <input
374 |           value={input}
375 |           onChange={handleInputChange}
376 |           placeholder="Type your message..."
377 |           className="message-input"
378 |         />
379 |       </form>
380 | 
381 |       <button onClick={clearHistory} className="clear-button">
382 |         Clear Chat
383 |       </button>
384 |     </div>
385 |   );
386 | }
387 | ```
388 | 
389 | This creates:
390 | 
391 | - Real-time message streaming
392 | - Simple message history
393 | - Intuitive input handling
394 | - Easy conversation reset
395 | 
396 | ### 🔗 MCP (Model Context Protocol) Integration
397 | 
398 | Agents can seamlessly integrate with the Model Context Protocol, allowing them to act as both MCP servers (providing tools to AI assistants) and MCP clients (using tools from other services).
399 | 
400 | #### Creating an MCP Server
401 | 
402 | ```typescript
403 | import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
404 | import { McpAgent } from "agents/mcp";
405 | import { z } from "zod";
406 | 
407 | type Env = {
408 |   MyMCP: DurableObjectNamespace<MyMCP>;
409 | };
410 | 
411 | type State = { counter: number };
412 | 
413 | export class MyMCP extends McpAgent<Env, State, {}> {
414 |   server = new McpServer({
415 |     name: "Demo",
416 |     version: "1.0.0"
417 |   });
418 | 
419 |   initialState: State = {
420 |     counter: 1
421 |   };
422 | 
423 |   async init() {
424 |     this.server.resource("counter", "mcp://resource/counter", (uri) => {
425 |       return {
426 |         contents: [{ text: String(this.state.counter), uri: uri.href }]
427 |       };
428 |     });
429 | 
430 |     this.server.tool(
431 |       "add",
432 |       "Add to the counter, stored in the MCP",
433 |       { a: z.number() },
434 |       async ({ a }) => {
435 |         this.setState({ ...this.state, counter: this.state.counter + a });
436 | 
437 |         return {
438 |           content: [
439 |             {
440 |               text: String(`Added ${a}, total is now ${this.state.counter}`),
441 |               type: "text"
442 |             }
443 |           ]
444 |         };
445 |       }
446 |     );
447 |   }
448 | 
449 |   onStateUpdate(state: State) {
450 |     console.log({ stateUpdate: state });
451 |   }
452 | }
453 | 
454 | // HTTP Streamable transport (recommended)
455 | export default MyMCP.serve("/mcp", {
456 |   binding: "MyMCP"
457 | });
458 | 
459 | // Or SSE transport for legacy compatibility
460 | // export default MyMCP.serveSSE("/mcp", { binding: "MyMCP" });
461 | ```
462 | 
463 | #### Using MCP Tools
464 | 
465 | ```typescript
466 | import { MCPClientManager } from "agents/mcp";
467 | 
468 | const client = new MCPClientManager("my-app", "1.0.0");
469 | 
470 | // Connect to an MCP server
471 | await client.connect("https://weather-service.com/mcp", {
472 |   transport: { type: "streamable-http" }
473 | });
474 | 
475 | // Use tools from the server
476 | const weather = await client.callTool({
477 |   serverId: "weather-service",
478 |   name: "getWeather",
479 |   arguments: { location: "San Francisco" }
480 | });
481 | ```
482 | 
483 | #### AI SDK Integration
484 | 
485 | ```typescript
486 | import { generateText } from "ai";
487 | 
488 | // Convert MCP tools for AI use
489 | const result = await generateText({
490 |   model: openai("gpt-4"),
491 |   tools: client.unstable_getAITools(),
492 |   prompt: "What's the weather in Tokyo?"
493 | });
494 | ```
495 | 
496 | **Transport Options:**
497 | 
498 | - **HTTP Streamable**: Best performance, batch requests, session management
499 | - **SSE**: Simple setup, legacy compatibility
500 | 
501 | ### 💬 The Path Forward
502 | 
503 | We're developing new dimensions of agent capability:
504 | 
505 | #### Enhanced Understanding
506 | 
507 | - **WebRTC Perception**: Audio and video communication channels
508 | - **Email Discourse**: Automated email interaction and response
509 | - **Deep Memory**: Long-term context and relationship understanding
510 | 
511 | #### Development Insights
512 | 
513 | - **Evaluation Framework**: Understanding agent effectiveness
514 | - **Clear Sight**: Deep visibility into agent processes
515 | - **Private Realms**: Complete self-hosting guide
516 | 
517 | These capabilities will expand your agents' potential while maintaining their reliability and purpose.
518 | 
519 | Welcome to the future of intelligent agents. Create something meaningful. 🌟
520 | 
521 | ### Contributing
522 | 
523 | Contributions are welcome, but are especially welcome when:
524 | 
525 | - You have opened an issue as a Request for Comment (RFC) to discuss your proposal, show your thinking, and iterate together.
526 | - Is not "AI slop": LLMs are powerful tools, but contributions entirely authored by vibe coding are unlikely to meet the quality bar, and will be rejected.
527 | - You're willing to accept feedback and make sure the changes fit the goals of the `agents` sdk. Not everything will, and that's OK.
528 | 
529 | Small fixes, type bugs, and documentation improvements can be raised directly as PRs.
530 | 
531 | ### License
532 | 
533 | MIT licensed. See the LICENSE file at the root of this repository for details.
534 | 


--------------------------------------------------------------------------------
/packages/agents/evals/README.md:
--------------------------------------------------------------------------------
 1 | ## evals for core agent functionality
 2 | 
 3 | setup a .env file with (any of) the following:
 4 | 
 5 | ```
 6 | OPENAI_API_KEY=<your openai key>
 7 | GOOGLE_GENERATIVE_AI_API_KEY=<your google key>
 8 | ANTHROPIC_API_KEY=<your anthropic key>
 9 | ```
10 | 
11 | Choose a model in `src/scheduling.eval.ts`
12 | 
13 | Then run the evals with `npx evalite`
14 | 


--------------------------------------------------------------------------------
/packages/agents/evals/scheduling.eval.ts:
--------------------------------------------------------------------------------
  1 | // import { anthropic } from "@ai-sdk/anthropic";
  2 | // import { google } from "@ai-sdk/google";
  3 | import { openai } from "@ai-sdk/openai";
  4 | import { generateObject } from "ai";
  5 | import { createScorer, evalite } from "evalite";
  6 | import {
  7 |   type Schedule,
  8 |   unstable_getSchedulePrompt,
  9 |   unstable_scheduleSchema
 10 | } from "../src/schedule";
 11 | 
 12 | const model = openai("gpt-4o");
 13 | // const model = google("gemini-2.0-pro-exp-02-05");
 14 | // const model = google("gemini-2.0-flash");
 15 | // const model = google("gemini-1.5-pro");
 16 | // const model = anthropic("claude-3-5-sonnet-20240620"); // also disable mode: "json"
 17 | 
 18 | function assert(condition: unknown, message: string): asserts condition {
 19 |   if (!condition) {
 20 |     throw new Error(message);
 21 |   }
 22 | }
 23 | 
 24 | // scorers
 25 | const getsType = createScorer<string, Schedule>({
 26 |   description: "Checks if the output is the right type",
 27 |   name: "getsType",
 28 |   scorer: ({ output, expected }) => {
 29 |     return output.when.type === expected?.when.type ? 1 : 0;
 30 |   }
 31 | });
 32 | 
 33 | const getsDetail = createScorer<string, Schedule>({
 34 |   description: "Checks if the output is the right detail",
 35 |   name: "getsDetail",
 36 |   scorer: ({ output, expected }) => {
 37 |     switch (expected?.when.type) {
 38 |       case "scheduled": {
 39 |         assert(
 40 |           output.when.type === "scheduled",
 41 |           "Output is not a scheduled task"
 42 |         );
 43 |         return output.when?.date?.getTime() === expected.when?.date?.getTime()
 44 |           ? 1
 45 |           : 0;
 46 |       }
 47 |       case "delayed": {
 48 |         assert(output.when.type === "delayed", "Output is not a delayed task");
 49 |         return output.when.delayInSeconds === expected.when.delayInSeconds
 50 |           ? 1
 51 |           : 0;
 52 |       }
 53 |       case "cron": {
 54 |         assert(output.when.type === "cron", "Output is not a cron task");
 55 |         return output.when.cron === expected.when.cron ? 1 : 0;
 56 |       }
 57 | 
 58 |       case "no-schedule": {
 59 |         assert(
 60 |           output.when.type === "no-schedule",
 61 |           "Output is not a no-schedule task"
 62 |         );
 63 |         return 1;
 64 |       }
 65 |       default:
 66 |         return 0;
 67 |     }
 68 |   }
 69 | });
 70 | 
 71 | const getsDescription = createScorer<string, Schedule>({
 72 |   description: "Checks if the output is the right description",
 73 |   name: "getsDescription",
 74 |   // biome-ignore lint/correctness/noUnusedFunctionParameters: tests
 75 |   scorer: ({ input, output, expected }) => {
 76 |     return output.description.toLowerCase() ===
 77 |       expected?.description.toLowerCase()
 78 |       ? 1
 79 |       : 0;
 80 |   }
 81 | });
 82 | 
 83 | evalite<string, Schedule>("Evals for scheduling", {
 84 |   // A function that returns an array of test data
 85 |   data: async () => {
 86 |     return [
 87 |       {
 88 |         expected: {
 89 |           description: "jump",
 90 |           when: { delayInSeconds: 6, type: "delayed" }
 91 |         },
 92 |         input: "jump in 6 seconds"
 93 |       },
 94 |       {
 95 |         expected: {
 96 |           description: "meeting with team",
 97 |           when: {
 98 |             date: (() => {
 99 |               const date = new Date();
100 |               date.setDate(date.getDate() + 1);
101 |               date.setHours(14, 0, 0, 0);
102 |               return date;
103 |             })(),
104 |             type: "scheduled"
105 |           }
106 |         },
107 |         input: "meeting with team at 2pm tomorrow"
108 |       },
109 |       {
110 |         expected: {
111 |           description: "run backup",
112 |           when: { cron: "0 0 * * *", type: "cron" }
113 |         },
114 |         input: "run backup every day at midnight"
115 |       },
116 |       {
117 |         expected: {
118 |           description: "send report",
119 |           when: { delayInSeconds: 1800, type: "delayed" }
120 |         },
121 |         input: "send report in 30 minutes"
122 |       },
123 |       {
124 |         expected: {
125 |           description: "weekly team sync",
126 |           when: { cron: "0 10 * * 1", type: "cron" }
127 |         },
128 |         input: "weekly team sync every Monday at 10am"
129 |       },
130 |       {
131 |         expected: {
132 |           description: "just a task without timing",
133 |           when: { type: "no-schedule" }
134 |         },
135 |         input: "just a task without timing"
136 |       },
137 |       {
138 |         expected: {
139 |           description: "quarterly review",
140 |           when: {
141 |             date: new Date(new Date().getFullYear(), 2, 15, 9, 0, 0, 0),
142 |             type: "scheduled"
143 |           }
144 |         },
145 |         input: "quarterly review on March 15th at 9am"
146 |       },
147 |       {
148 |         expected: {
149 |           description: "clean database",
150 |           when: { cron: "0 3 * * 0", type: "cron" }
151 |         },
152 |         input: "clean database every Sunday at 3am"
153 |       },
154 |       {
155 |         expected: {
156 |           description: "process data",
157 |           when: { cron: "*/5 * * * *", type: "cron" }
158 |         },
159 |         input: "process data every 5 minutes"
160 |       },
161 |       {
162 |         expected: {
163 |           description: "run maintenance",
164 |           when: { cron: "0 2 1 * *", type: "cron" }
165 |         },
166 |         input: "run maintenance at 2am every first day of month"
167 |       },
168 |       {
169 |         expected: {
170 |           description: "send reminder",
171 |           when: { delayInSeconds: 7200, type: "delayed" }
172 |         },
173 |         input: "send reminder in 2 hours"
174 |       },
175 |       {
176 |         expected: {
177 |           description: "team meeting",
178 |           when: {
179 |             date: (() => {
180 |               const date = new Date();
181 |               const daysUntilFriday = (5 - date.getDay() + 7) % 7;
182 |               date.setDate(date.getDate() + daysUntilFriday);
183 |               date.setHours(15, 30, 0, 0);
184 |               return date;
185 |             })(),
186 |             type: "scheduled"
187 |           }
188 |         },
189 |         input: "team meeting next Friday at 3:30pm"
190 |       },
191 |       {
192 |         expected: {
193 |           description: "backup database",
194 |           when: { cron: "0 */6 * * *", type: "cron" }
195 |         },
196 |         input: "backup database every 6 hours"
197 |       },
198 |       {
199 |         expected: {
200 |           description: "generate report",
201 |           when: { cron: "0 9 * * 1-5", type: "cron" }
202 |         },
203 |         input: "generate report every weekday at 9am"
204 |       },
205 |       {
206 |         expected: {
207 |           description: "check system",
208 |           when: { delayInSeconds: 15, type: "delayed" }
209 |         },
210 |         input: "check system in 15 seconds"
211 |       },
212 |       {
213 |         expected: {
214 |           description: "update cache",
215 |           when: { cron: "*/30 9-17 * * 1-5", type: "cron" }
216 |         },
217 |         input: "update cache every 30 minutes during business hours"
218 |       },
219 |       {
220 |         expected: {
221 |           description: "archive logs",
222 |           when: { cron: "0 0 * * 0,6", type: "cron" }
223 |         },
224 |         input: "archive logs at midnight on weekends"
225 |       },
226 |       {
227 |         expected: {
228 |           description: "sync data",
229 |           when: { delayInSeconds: 3600, type: "delayed" }
230 |         },
231 |         input: "sync data in 1 hour"
232 |       },
233 |       {
234 |         expected: {
235 |           description: "run health check",
236 |           when: { cron: "*/10 9-17 * * 1-5", type: "cron" }
237 |         },
238 |         input: "run health check every 10 minutes during work hours"
239 |       },
240 |       {
241 |         expected: {
242 |           description: "send daily digest",
243 |           when: { cron: "0 8 * * 1-5", type: "cron" }
244 |         },
245 |         input: "send daily digest at 8am on weekdays"
246 |       },
247 |       {
248 |         expected: {
249 |           description: "process invoices",
250 |           when: { cron: "*/15 9-17 * * 1-5", type: "cron" }
251 |         },
252 |         input: "process invoices every 15 minutes during business hours"
253 |       },
254 |       {
255 |         expected: {
256 |           description: "run backup",
257 |           when: { cron: "0 1,13 * * *", type: "cron" }
258 |         },
259 |         input: "run backup at 1am and 1pm every day"
260 |       },
261 |       {
262 |         expected: {
263 |           description: "check system status",
264 |           when: { delayInSeconds: 45, type: "delayed" }
265 |         },
266 |         input: "check system status in 45 seconds"
267 |       },
268 |       {
269 |         expected: {
270 |           description: "generate monthly report",
271 |           when: { cron: "0 6 1 * *", type: "cron" }
272 |         },
273 |         input: "generate monthly report on the 1st at 6am"
274 |       },
275 |       {
276 |         expected: {
277 |           description: "clean temp files",
278 |           when: { cron: "0 */2 * * *", type: "cron" }
279 |         },
280 |         input: "clean temp files every 2 hours"
281 |       },
282 |       {
283 |         expected: {
284 |           description: "sync data",
285 |           when: { cron: "0 9,17 * * 1-5", type: "cron" }
286 |         },
287 |         input: "sync data at 9am and 5pm on weekdays"
288 |       },
289 |       {
290 |         expected: {
291 |           description: "run maintenance",
292 |           when: { cron: "0 3 * * 0,6", type: "cron" }
293 |         },
294 |         input: "run maintenance at 3am on weekends"
295 |       },
296 |       {
297 |         expected: {
298 |           description: "archive old data",
299 |           when: { cron: "0 0 28-31 * *", type: "cron" }
300 |         },
301 |         input: "archive old data at midnight on the last day of each month"
302 |       },
303 |       {
304 |         expected: {
305 |           description: "send notification",
306 |           when: { delayInSeconds: 10800, type: "delayed" }
307 |         },
308 |         input: "send notification in 3 hours"
309 |       },
310 |       {
311 |         expected: {
312 |           description: "run diagnostics",
313 |           when: { cron: "0 2 * * 1-5", type: "cron" }
314 |         },
315 |         input: "run diagnostics at 2am on weekdays"
316 |       },
317 |       {
318 |         expected: {
319 |           description: "process logs",
320 |           when: { cron: "*/30 9-17 * * 1-5", type: "cron" }
321 |         },
322 |         input: "process logs every 30 minutes during business hours"
323 |       }
324 |     ];
325 |   },
326 |   scorers: [getsType, getsDetail, getsDescription],
327 |   // The task to perform
328 |   task: async (input) => {
329 |     try {
330 |       const result = await generateObject({
331 |         maxRetries: 5,
332 |         model, // <- the shape of the object that the scheduler expects
333 |         prompt: `${unstable_getSchedulePrompt({ date: new Date() })}
334 |       
335 | Input to parse: "${input}"`,
336 |         // mode: "json",
337 |         // schemaName: "task",
338 |         // schemaDescription: "A task to be scheduled",
339 |         schema: unstable_scheduleSchema
340 |       });
341 |       return result.object;
342 |     } catch (error) {
343 |       console.error(error);
344 |       throw error;
345 |     }
346 |   }
347 | });
348 | 


--------------------------------------------------------------------------------
/packages/agents/evals/vite.config.ts:
--------------------------------------------------------------------------------
1 | import { defineConfig } from "vite";
2 | 
3 | export default defineConfig({
4 |   test: {
5 |     setupFiles: ["dotenv/config"]
6 |   }
7 | });
8 | 


--------------------------------------------------------------------------------
/packages/agents/package.json:
--------------------------------------------------------------------------------
  1 | {
  2 |   "author": "Cloudflare Inc.",
  3 |   "bugs": {
  4 |     "url": "https://github.com/cloudflare/agents/issues"
  5 |   },
  6 |   "dependencies": {
  7 |     "@modelcontextprotocol/sdk": "^1.13.3",
  8 |     "ai": "^4.3.16",
  9 |     "cron-schedule": "^5.0.4",
 10 |     "mimetext": "^3.0.27",
 11 |     "nanoid": "^5.1.5",
 12 |     "partyserver": "^0.0.72",
 13 |     "partysocket": "1.1.4",
 14 |     "zod": "^3.25.67"
 15 |   },
 16 |   "description": "A home for your AI agents",
 17 |   "devDependencies": {
 18 |     "react": "*",
 19 |     "vitest-browser-react": "^1.0.0"
 20 |   },
 21 |   "exports": {
 22 |     ".": {
 23 |       "types": "./dist/index.d.ts",
 24 |       "import": "./dist/index.js",
 25 |       "require": "./dist/index.js"
 26 |     },
 27 |     "./ai-chat-agent": {
 28 |       "types": "./dist/ai-chat-agent.d.ts",
 29 |       "import": "./dist/ai-chat-agent.js",
 30 |       "require": "./dist/ai-chat-agent.js"
 31 |     },
 32 |     "./ai-react": {
 33 |       "types": "./dist/ai-react.d.ts",
 34 |       "import": "./dist/ai-react.js",
 35 |       "require": "./dist/ai-react.js"
 36 |     },
 37 |     "./ai-types": {
 38 |       "types": "./dist/ai-types.d.ts",
 39 |       "import": "./dist/ai-types.js",
 40 |       "require": "./dist/ai-types.js"
 41 |     },
 42 |     "./client": {
 43 |       "types": "./dist/client.d.ts",
 44 |       "import": "./dist/client.js",
 45 |       "require": "./dist/client.js"
 46 |     },
 47 |     "./mcp": {
 48 |       "types": "./dist/mcp/index.d.ts",
 49 |       "import": "./dist/mcp/index.js",
 50 |       "require": "./dist/mcp/index.js"
 51 |     },
 52 |     "./mcp/client": {
 53 |       "types": "./dist/mcp/client.d.ts",
 54 |       "import": "./dist/mcp/client.js",
 55 |       "require": "./dist/mcp/client.js"
 56 |     },
 57 |     "./mcp/do-oauth-client-provider": {
 58 |       "types": "./dist/mcp/do-oauth-client-provider.d.ts",
 59 |       "import": "./dist/mcp/do-oauth-client-provider.js",
 60 |       "require": "./dist/mcp/do-oauth-client-provider.js"
 61 |     },
 62 |     "./observability": {
 63 |       "types": "./dist/observability/index.d.ts",
 64 |       "import": "./dist/observability/index.js",
 65 |       "require": "./dist/observability/index.js"
 66 |     },
 67 |     "./react": {
 68 |       "types": "./dist/react.d.ts",
 69 |       "import": "./dist/react.js",
 70 |       "require": "./dist/react.js"
 71 |     },
 72 |     "./schedule": {
 73 |       "types": "./dist/schedule.d.ts",
 74 |       "import": "./dist/schedule.js",
 75 |       "require": "./dist/schedule.js"
 76 |     }
 77 |   },
 78 |   "files": [
 79 |     "dist",
 80 |     "README.md"
 81 |   ],
 82 |   "keywords": [],
 83 |   "license": "MIT",
 84 |   "main": "src/index.ts",
 85 |   "name": "agents",
 86 |   "peerDependencies": {
 87 |     "react": "*"
 88 |   },
 89 |   "repository": {
 90 |     "directory": "packages/agents",
 91 |     "type": "git",
 92 |     "url": "git+https://github.com/cloudflare/agents.git"
 93 |   },
 94 |   "scripts": {
 95 |     "build": "tsx ./scripts/build.ts",
 96 |     "check:test": "npm run check:test:workers && npm run check:test:react",
 97 |     "check:test:react": "vitest -r src/react-tests --watch false",
 98 |     "check:test:workers": "vitest -r src/tests --watch false",
 99 |     "evals": "(cd evals; evalite)",
100 |     "test": "vitest -r src/tests",
101 |     "test:react": "vitest -r src/react-tests"
102 |   },
103 |   "type": "module",
104 |   "types": "dist/index.d.ts",
105 |   "version": "0.0.109"
106 | }
107 | 


--------------------------------------------------------------------------------
/packages/agents/scripts/build.ts:
--------------------------------------------------------------------------------
 1 | import { execSync } from "node:child_process";
 2 | import { build } from "tsup";
 3 | 
 4 | async function main() {
 5 |   await build({
 6 |     clean: true,
 7 |     dts: true,
 8 |     entry: [
 9 |       "src/*.ts",
10 |       "src/*.tsx",
11 |       "src/mcp/index.ts",
12 |       "src/mcp/client.ts",
13 |       "src/mcp/do-oauth-client-provider.ts",
14 |       "src/observability/index.ts"
15 |     ],
16 |     external: [
17 |       "cloudflare:workers",
18 |       "cloudflare:email",
19 |       "@ai-sdk/react",
20 |       "ai",
21 |       "react",
22 |       "zod",
23 |       "@modelcontextprotocol/sdk"
24 |     ],
25 |     format: "esm",
26 |     sourcemap: true,
27 |     splitting: true
28 |   });
29 | 
30 |   // then run prettier on the generated .d.ts files
31 |   execSync("prettier --write ./dist/*.d.ts");
32 | 
33 |   process.exit(0);
34 | }
35 | 
36 | main().catch((err) => {
37 |   // Build failures should fail
38 |   console.error(err);
39 |   process.exit(1);
40 | });
41 | 


--------------------------------------------------------------------------------
/packages/agents/src/ai-chat-agent.ts:
--------------------------------------------------------------------------------
  1 | import type {
  2 |   Message as ChatMessage,
  3 |   StreamTextOnFinishCallback,
  4 |   ToolSet
  5 | } from "ai";
  6 | import { appendResponseMessages } from "ai";
  7 | import { Agent, type AgentContext, type Connection, type WSMessage } from "./";
  8 | import type { IncomingMessage, OutgoingMessage } from "./ai-types";
  9 | 
 10 | const decoder = new TextDecoder();
 11 | 
 12 | /**
 13 |  * Extension of Agent with built-in chat capabilities
 14 |  * @template Env Environment type containing bindings
 15 |  */
 16 | export class AIChatAgent<Env = unknown, State = unknown> extends Agent<
 17 |   Env,
 18 |   State
 19 | > {
 20 |   /**
 21 |    * Map of message `id`s to `AbortController`s
 22 |    * useful to propagate request cancellation signals for any external calls made by the agent
 23 |    */
 24 |   private _chatMessageAbortControllers: Map<string, AbortController>;
 25 |   /** Array of chat messages for the current conversation */
 26 |   messages: ChatMessage[];
 27 |   constructor(ctx: AgentContext, env: Env) {
 28 |     super(ctx, env);
 29 |     this.sql`create table if not exists cf_ai_chat_agent_messages (
 30 |       id text primary key,
 31 |       message text not null,
 32 |       created_at datetime default current_timestamp
 33 |     )`;
 34 |     this.messages = (
 35 |       this.sql`select * from cf_ai_chat_agent_messages` || []
 36 |     ).map((row) => {
 37 |       return JSON.parse(row.message as string);
 38 |     });
 39 | 
 40 |     this._chatMessageAbortControllers = new Map();
 41 |   }
 42 | 
 43 |   private _broadcastChatMessage(message: OutgoingMessage, exclude?: string[]) {
 44 |     this.broadcast(JSON.stringify(message), exclude);
 45 |   }
 46 | 
 47 |   override async onMessage(connection: Connection, message: WSMessage) {
 48 |     if (typeof message === "string") {
 49 |       let data: IncomingMessage;
 50 |       try {
 51 |         data = JSON.parse(message) as IncomingMessage;
 52 |       } catch (_error) {
 53 |         // silently ignore invalid messages for now
 54 |         // TODO: log errors with log levels
 55 |         return;
 56 |       }
 57 |       if (
 58 |         data.type === "cf_agent_use_chat_request" &&
 59 |         data.init.method === "POST"
 60 |       ) {
 61 |         const {
 62 |           // method,
 63 |           // keepalive,
 64 |           // headers,
 65 |           body // we're reading this
 66 |           //
 67 |           // // these might not exist?
 68 |           // dispatcher,
 69 |           // duplex
 70 |         } = data.init;
 71 |         const { messages } = JSON.parse(body as string);
 72 |         this._broadcastChatMessage(
 73 |           {
 74 |             messages,
 75 |             type: "cf_agent_chat_messages"
 76 |           },
 77 |           [connection.id]
 78 |         );
 79 | 
 80 |         const incomingMessages = this._messagesNotAlreadyInAgent(messages);
 81 |         await this.persistMessages(messages, [connection.id]);
 82 | 
 83 |         this.observability?.emit(
 84 |           {
 85 |             displayMessage: "Chat message request",
 86 |             id: data.id,
 87 |             payload: {
 88 |               message: incomingMessages
 89 |             },
 90 |             timestamp: Date.now(),
 91 |             type: "message:request"
 92 |           },
 93 |           this.ctx
 94 |         );
 95 | 
 96 |         const chatMessageId = data.id;
 97 |         const abortSignal = this._getAbortSignal(chatMessageId);
 98 | 
 99 |         return this._tryCatchChat(async () => {
100 |           const response = await this.onChatMessage(
101 |             async ({ response }) => {
102 |               const finalMessages = appendResponseMessages({
103 |                 messages,
104 |                 responseMessages: response.messages
105 |               });
106 | 
107 |               const outgoingMessages =
108 |                 this._messagesNotAlreadyInAgent(finalMessages);
109 |               await this.persistMessages(finalMessages, [connection.id]);
110 |               this._removeAbortController(chatMessageId);
111 | 
112 |               this.observability?.emit(
113 |                 {
114 |                   displayMessage: "Chat message response",
115 |                   id: data.id,
116 |                   payload: {
117 |                     message: outgoingMessages
118 |                   },
119 |                   timestamp: Date.now(),
120 |                   type: "message:response"
121 |                 },
122 |                 this.ctx
123 |               );
124 |             },
125 |             abortSignal ? { abortSignal } : undefined
126 |           );
127 | 
128 |           if (response) {
129 |             await this._reply(data.id, response);
130 |           } else {
131 |             // Log a warning for observability
132 |             console.warn(
133 |               `[AIChatAgent] onChatMessage returned no response for chatMessageId: ${chatMessageId}`
134 |             );
135 |             // Send a fallback message to the client
136 |             this._broadcastChatMessage(
137 |               {
138 |                 body: "No response was generated by the agent.",
139 |                 done: true,
140 |                 id: data.id,
141 |                 type: "cf_agent_use_chat_response"
142 |               },
143 |               [connection.id]
144 |             );
145 |           }
146 |         });
147 |       }
148 |       if (data.type === "cf_agent_chat_clear") {
149 |         this._destroyAbortControllers();
150 |         this.sql`delete from cf_ai_chat_agent_messages`;
151 |         this.messages = [];
152 |         this._broadcastChatMessage(
153 |           {
154 |             type: "cf_agent_chat_clear"
155 |           },
156 |           [connection.id]
157 |         );
158 |       } else if (data.type === "cf_agent_chat_messages") {
159 |         // replace the messages with the new ones
160 |         await this.persistMessages(data.messages, [connection.id]);
161 |       } else if (data.type === "cf_agent_chat_request_cancel") {
162 |         // propagate an abort signal for the associated request
163 |         this._cancelChatRequest(data.id);
164 |       }
165 |     }
166 |   }
167 | 
168 |   override async onRequest(request: Request): Promise<Response> {
169 |     return this._tryCatchChat(() => {
170 |       const url = new URL(request.url);
171 |       if (url.pathname.endsWith("/get-messages")) {
172 |         const messages = (
173 |           this.sql`select * from cf_ai_chat_agent_messages` || []
174 |         ).map((row) => {
175 |           return JSON.parse(row.message as string);
176 |         });
177 |         return Response.json(messages);
178 |       }
179 |       return super.onRequest(request);
180 |     });
181 |   }
182 | 
183 |   private async _tryCatchChat<T>(fn: () => T | Promise<T>) {
184 |     try {
185 |       return await fn();
186 |     } catch (e) {
187 |       throw this.onError(e);
188 |     }
189 |   }
190 | 
191 |   /**
192 |    * Handle incoming chat messages and generate a response
193 |    * @param onFinish Callback to be called when the response is finished
194 |    * @param options.signal A signal to pass to any child requests which can be used to cancel them
195 |    * @returns Response to send to the client or undefined
196 |    */
197 |   async onChatMessage(
198 |     // biome-ignore lint/correctness/noUnusedFunctionParameters: overridden later
199 |     onFinish: StreamTextOnFinishCallback<ToolSet>,
200 |     // biome-ignore lint/correctness/noUnusedFunctionParameters: overridden later
201 |     options?: { abortSignal: AbortSignal | undefined }
202 |   ): Promise<Response | undefined> {
203 |     throw new Error(
204 |       "recieved a chat message, override onChatMessage and return a Response to send to the client"
205 |     );
206 |   }
207 | 
208 |   /**
209 |    * Save messages on the server side and trigger AI response
210 |    * @param messages Chat messages to save
211 |    */
212 |   async saveMessages(messages: ChatMessage[]) {
213 |     await this.persistMessages(messages);
214 |     const response = await this.onChatMessage(async ({ response }) => {
215 |       const finalMessages = appendResponseMessages({
216 |         messages,
217 |         responseMessages: response.messages
218 |       });
219 | 
220 |       await this.persistMessages(finalMessages, []);
221 |     });
222 |     if (response) {
223 |       // we're just going to drain the body
224 |       // @ts-ignore TODO: fix this type error
225 |       for await (const chunk of response.body!) {
226 |         decoder.decode(chunk);
227 |       }
228 |       response.body?.cancel();
229 |     }
230 |   }
231 | 
232 |   async persistMessages(
233 |     messages: ChatMessage[],
234 |     excludeBroadcastIds: string[] = []
235 |   ) {
236 |     this.sql`delete from cf_ai_chat_agent_messages`;
237 |     for (const message of messages) {
238 |       this.sql`insert into cf_ai_chat_agent_messages (id, message) values (${
239 |         message.id
240 |       },${JSON.stringify(message)})`;
241 |     }
242 |     this.messages = messages;
243 |     this._broadcastChatMessage(
244 |       {
245 |         messages: messages,
246 |         type: "cf_agent_chat_messages"
247 |       },
248 |       excludeBroadcastIds
249 |     );
250 |   }
251 | 
252 |   private _messagesNotAlreadyInAgent(messages: ChatMessage[]) {
253 |     const existingIds = new Set(this.messages.map((message) => message.id));
254 |     return messages.filter((message) => !existingIds.has(message.id));
255 |   }
256 | 
257 |   private async _reply(id: string, response: Response) {
258 |     // now take chunks out from dataStreamResponse and send them to the client
259 |     return this._tryCatchChat(async () => {
260 |       // @ts-expect-error TODO: fix this type error
261 |       for await (const chunk of response.body!) {
262 |         const body = decoder.decode(chunk);
263 | 
264 |         this._broadcastChatMessage({
265 |           body,
266 |           done: false,
267 |           id,
268 |           type: "cf_agent_use_chat_response"
269 |         });
270 |       }
271 | 
272 |       this._broadcastChatMessage({
273 |         body: "",
274 |         done: true,
275 |         id,
276 |         type: "cf_agent_use_chat_response"
277 |       });
278 |     });
279 |   }
280 | 
281 |   /**
282 |    * For the given message id, look up its associated AbortController
283 |    * If the AbortController does not exist, create and store one in memory
284 |    *
285 |    * returns the AbortSignal associated with the AbortController
286 |    */
287 |   private _getAbortSignal(id: string): AbortSignal | undefined {
288 |     // Defensive check, since we're coercing message types at the moment
289 |     if (typeof id !== "string") {
290 |       return undefined;
291 |     }
292 | 
293 |     if (!this._chatMessageAbortControllers.has(id)) {
294 |       this._chatMessageAbortControllers.set(id, new AbortController());
295 |     }
296 | 
297 |     return this._chatMessageAbortControllers.get(id)?.signal;
298 |   }
299 | 
300 |   /**
301 |    * Remove an abort controller from the cache of pending message responses
302 |    */
303 |   private _removeAbortController(id: string) {
304 |     this._chatMessageAbortControllers.delete(id);
305 |   }
306 | 
307 |   /**
308 |    * Propagate an abort signal for any requests associated with the given message id
309 |    */
310 |   private _cancelChatRequest(id: string) {
311 |     if (this._chatMessageAbortControllers.has(id)) {
312 |       const abortController = this._chatMessageAbortControllers.get(id);
313 |       abortController?.abort();
314 |     }
315 |   }
316 | 
317 |   /**
318 |    * Abort all pending requests and clear the cache of AbortControllers
319 |    */
320 |   private _destroyAbortControllers() {
321 |     for (const controller of this._chatMessageAbortControllers.values()) {
322 |       controller?.abort();
323 |     }
324 |     this._chatMessageAbortControllers.clear();
325 |   }
326 | 
327 |   /**
328 |    * When the DO is destroyed, cancel all pending requests
329 |    */
330 |   async destroy() {
331 |     this._destroyAbortControllers();
332 |     await super.destroy();
333 |   }
334 | }
335 | 


--------------------------------------------------------------------------------
/packages/agents/src/ai-react.tsx:
--------------------------------------------------------------------------------
  1 | import { useChat } from "@ai-sdk/react";
  2 | import type { Message } from "ai";
  3 | import { nanoid } from "nanoid";
  4 | import { use, useEffect } from "react";
  5 | import type { OutgoingMessage } from "./ai-types";
  6 | import type { useAgent } from "./react";
  7 | 
  8 | type GetInitialMessagesOptions = {
  9 |   agent: string;
 10 |   name: string;
 11 |   url: string;
 12 | };
 13 | 
 14 | /**
 15 |  * Options for the useAgentChat hook
 16 |  */
 17 | type UseAgentChatOptions<State> = Omit<
 18 |   Parameters<typeof useChat>[0] & {
 19 |     /** Agent connection from useAgent */
 20 |     agent: ReturnType<typeof useAgent<State>>;
 21 |     getInitialMessages?:
 22 |       | undefined
 23 |       | null
 24 |       // | (() => Message[])
 25 |       | ((options: GetInitialMessagesOptions) => Promise<Message[]>);
 26 |   },
 27 |   "fetch"
 28 | >;
 29 | 
 30 | const requestCache = new Map<string, Promise<Message[]>>();
 31 | 
 32 | /**
 33 |  * React hook for building AI chat interfaces using an Agent
 34 |  * @param options Chat options including the agent connection
 35 |  * @returns Chat interface controls and state with added clearHistory method
 36 |  */
 37 | export function useAgentChat<State = unknown>(
 38 |   options: UseAgentChatOptions<State>
 39 | ) {
 40 |   const { agent, getInitialMessages, ...rest } = options;
 41 | 
 42 |   const agentUrl = new URL(
 43 |     `${// @ts-expect-error we're using a protected _url property that includes query params
 44 |     ((agent._url as string | null) || agent._pkurl)
 45 |       ?.replace("ws://", "http://")
 46 |       .replace("wss://", "https://")}`
 47 |   );
 48 | 
 49 |   // delete the _pk query param
 50 |   agentUrl.searchParams.delete("_pk");
 51 |   const agentUrlString = agentUrl.toString();
 52 | 
 53 |   async function defaultGetInitialMessagesFetch({
 54 |     url
 55 |   }: GetInitialMessagesOptions) {
 56 |     const getMessagesUrl = new URL(url);
 57 |     getMessagesUrl.pathname += "/get-messages";
 58 |     const response = await fetch(getMessagesUrl.toString(), {
 59 |       credentials: options.credentials,
 60 |       headers: options.headers
 61 |     });
 62 |     return response.json<Message[]>();
 63 |   }
 64 | 
 65 |   const getInitialMessagesFetch =
 66 |     getInitialMessages || defaultGetInitialMessagesFetch;
 67 | 
 68 |   function doGetInitialMessages(
 69 |     getInitialMessagesOptions: GetInitialMessagesOptions
 70 |   ) {
 71 |     if (requestCache.has(agentUrlString)) {
 72 |       return requestCache.get(agentUrlString)!;
 73 |     }
 74 |     const promise = getInitialMessagesFetch(getInitialMessagesOptions);
 75 |     // immediately cache the promise so that we don't
 76 |     // create multiple requests for the same agent during multiple
 77 |     // concurrent renders
 78 |     requestCache.set(agentUrlString, promise);
 79 |     return promise;
 80 |   }
 81 | 
 82 |   const initialMessagesPromise =
 83 |     getInitialMessages === null
 84 |       ? null
 85 |       : doGetInitialMessages({
 86 |           agent: agent.agent,
 87 |           name: agent.name,
 88 |           url: agentUrlString
 89 |         });
 90 |   const initialMessages = initialMessagesPromise
 91 |     ? use(initialMessagesPromise)
 92 |     : (rest.initialMessages ?? []);
 93 | 
 94 |   // manages adding and removing the promise from the cache
 95 |   useEffect(() => {
 96 |     if (!initialMessagesPromise) {
 97 |       return;
 98 |     }
 99 |     // this effect is responsible for removing the promise from the cache
100 |     // when the component unmounts or the promise changes,
101 |     // but that means it also must add the promise to the cache
102 |     // so that multiple arbitrary effect runs produce the expected state
103 |     // when resolved.
104 |     requestCache.set(agentUrlString, initialMessagesPromise!);
105 |     return () => {
106 |       if (requestCache.get(agentUrlString) === initialMessagesPromise) {
107 |         requestCache.delete(agentUrlString);
108 |       }
109 |     };
110 |   }, [agentUrlString, initialMessagesPromise]);
111 | 
112 |   async function aiFetch(
113 |     request: RequestInfo | URL,
114 |     options: RequestInit = {}
115 |   ) {
116 |     // we're going to use a websocket to do the actual "fetching"
117 |     // but still satisfy the type signature of the fetch function
118 |     // so we'll return a promise that resolves to a response
119 | 
120 |     const {
121 |       method,
122 |       keepalive,
123 |       headers,
124 |       body,
125 |       redirect,
126 |       integrity,
127 |       signal,
128 |       credentials,
129 |       mode,
130 |       referrer,
131 |       referrerPolicy,
132 |       window
133 |       //  dispatcher, duplex
134 |     } = options;
135 |     const id = nanoid(8);
136 |     const abortController = new AbortController();
137 | 
138 |     signal?.addEventListener("abort", () => {
139 |       // Propagate request cancellation to the Agent
140 |       // We need to communciate cancellation as a websocket message, instead of a request signal
141 |       agent.send(
142 |         JSON.stringify({
143 |           id,
144 |           type: "cf_agent_chat_request_cancel"
145 |         })
146 |       );
147 | 
148 |       // NOTE - If we wanted to, we could preserve the "interrupted" message here, with the code below
149 |       //        However, I think it might be the responsibility of the library user to implement that behavior manually?
150 |       //        Reasoning: This code could be subject to collisions, as it "force saves" the messages we have locally
151 |       //
152 |       // agent.send(JSON.stringify({
153 |       //   type: "cf_agent_chat_messages",
154 |       //   messages: ... /* some way of getting current messages ref? */
155 |       // }))
156 | 
157 |       abortController.abort();
158 |       // Make sure to also close the stream (cf. https://github.com/cloudflare/agents-starter/issues/69)
159 |       controller.close();
160 |     });
161 | 
162 |     agent.addEventListener(
163 |       "message",
164 |       (event) => {
165 |         let data: OutgoingMessage;
166 |         try {
167 |           data = JSON.parse(event.data) as OutgoingMessage;
168 |         } catch (_error) {
169 |           // silently ignore invalid messages for now
170 |           // TODO: log errors with log levels
171 |           return;
172 |         }
173 |         if (data.type === "cf_agent_use_chat_response") {
174 |           if (data.id === id) {
175 |             controller.enqueue(new TextEncoder().encode(data.body));
176 |             if (data.done) {
177 |               controller.close();
178 |               abortController.abort();
179 |             }
180 |           }
181 |         }
182 |       },
183 |       { signal: abortController.signal }
184 |     );
185 | 
186 |     let controller: ReadableStreamDefaultController;
187 | 
188 |     const stream = new ReadableStream({
189 |       start(c) {
190 |         controller = c;
191 |       }
192 |     });
193 | 
194 |     agent.send(
195 |       JSON.stringify({
196 |         id,
197 |         init: {
198 |           body,
199 |           credentials,
200 |           headers,
201 |           integrity,
202 |           keepalive,
203 |           method,
204 |           mode,
205 |           redirect,
206 |           referrer,
207 |           referrerPolicy,
208 |           window
209 |           // dispatcher,
210 |           // duplex
211 |         },
212 |         type: "cf_agent_use_chat_request",
213 |         url: request.toString()
214 |       })
215 |     );
216 | 
217 |     return new Response(stream);
218 |   }
219 |   const useChatHelpers = useChat({
220 |     fetch: aiFetch,
221 |     initialMessages,
222 |     sendExtraMessageFields: true,
223 |     ...rest
224 |   });
225 | 
226 |   useEffect(() => {
227 |     function onClearHistory(event: MessageEvent) {
228 |       if (typeof event.data !== "string") {
229 |         return;
230 |       }
231 |       let data: OutgoingMessage;
232 |       try {
233 |         data = JSON.parse(event.data) as OutgoingMessage;
234 |       } catch (_error) {
235 |         // silently ignore invalid messages for now
236 |         // TODO: log errors with log levels
237 |         return;
238 |       }
239 |       if (data.type === "cf_agent_chat_clear") {
240 |         useChatHelpers.setMessages([]);
241 |       }
242 |     }
243 | 
244 |     function onMessages(event: MessageEvent) {
245 |       if (typeof event.data !== "string") {
246 |         return;
247 |       }
248 |       let data: OutgoingMessage;
249 |       try {
250 |         data = JSON.parse(event.data) as OutgoingMessage;
251 |       } catch (_error) {
252 |         // silently ignore invalid messages for now
253 |         // TODO: log errors with log levels
254 |         return;
255 |       }
256 |       if (data.type === "cf_agent_chat_messages") {
257 |         useChatHelpers.setMessages(data.messages);
258 |       }
259 |     }
260 | 
261 |     agent.addEventListener("message", onClearHistory);
262 |     agent.addEventListener("message", onMessages);
263 | 
264 |     return () => {
265 |       agent.removeEventListener("message", onClearHistory);
266 |       agent.removeEventListener("message", onMessages);
267 |     };
268 |   }, [agent, useChatHelpers.setMessages]);
269 | 
270 |   return {
271 |     ...useChatHelpers,
272 |     /**
273 |      * Clear chat history on both client and Agent
274 |      */
275 |     clearHistory: () => {
276 |       useChatHelpers.setMessages([]);
277 |       agent.send(
278 |         JSON.stringify({
279 |           type: "cf_agent_chat_clear"
280 |         })
281 |       );
282 |     },
283 |     /**
284 |      * Set the chat messages and synchronize with the Agent
285 |      * @param messages New messages to set
286 |      */
287 |     setMessages: (messages: Message[]) => {
288 |       useChatHelpers.setMessages(messages);
289 |       agent.send(
290 |         JSON.stringify({
291 |           messages,
292 |           type: "cf_agent_chat_messages"
293 |         })
294 |       );
295 |     }
296 |   };
297 | }
298 | 


--------------------------------------------------------------------------------
/packages/agents/src/ai-types.ts:
--------------------------------------------------------------------------------
 1 | import type { Message as ChatMessage } from "ai";
 2 | 
 3 | /**
 4 |  * Types of messages sent from the Agent to clients
 5 |  */
 6 | export type OutgoingMessage =
 7 |   | {
 8 |       /** Indicates this message contains updated chat messages */
 9 |       type: "cf_agent_chat_messages";
10 |       /** Array of chat messages */
11 |       messages: ChatMessage[];
12 |     }
13 |   | {
14 |       /** Indicates this message is a response to a chat request */
15 |       type: "cf_agent_use_chat_response";
16 |       /** Unique ID of the request this response corresponds to */
17 |       id: string;
18 |       /** Content body of the response */
19 |       body: string;
20 |       /** Whether this is the final chunk of the response */
21 |       done: boolean;
22 |     }
23 |   | {
24 |       /** Indicates this message contains updated chat messages */
25 |       type: "cf_agent_chat_messages";
26 |       /** Array of chat messages */
27 |       messages: ChatMessage[];
28 |     }
29 |   | {
30 |       /** Indicates this message is a command to clear chat history */
31 |       type: "cf_agent_chat_clear";
32 |     };
33 | 
34 | /**
35 |  * Types of messages sent from clients to the Agent
36 |  */
37 | export type IncomingMessage =
38 |   | {
39 |       /** Indicates this message is a request to the chat API */
40 |       type: "cf_agent_use_chat_request";
41 |       /** Unique ID for this request */
42 |       id: string;
43 |       /** Request initialization options */
44 |       init: Pick<
45 |         RequestInit,
46 |         | "method"
47 |         | "keepalive"
48 |         | "headers"
49 |         | "body"
50 |         | "redirect"
51 |         | "integrity"
52 |         | "credentials"
53 |         | "mode"
54 |         | "referrer"
55 |         | "referrerPolicy"
56 |         | "window"
57 |       >;
58 |     }
59 |   | {
60 |       /** Indicates this message is a command to clear chat history */
61 |       type: "cf_agent_chat_clear";
62 |     }
63 |   | {
64 |       /** Indicates this message contains updated chat messages */
65 |       type: "cf_agent_chat_messages";
66 |       /** Array of chat messages */
67 |       messages: ChatMessage[];
68 |     }
69 |   | {
70 |       /** Indicates the user wants to stop generation of this message */
71 |       type: "cf_agent_chat_request_cancel";
72 |       id: string;
73 |     };
74 | 


--------------------------------------------------------------------------------
/packages/agents/src/client.ts:
--------------------------------------------------------------------------------
  1 | import {
  2 |   type PartyFetchOptions,
  3 |   PartySocket,
  4 |   type PartySocketOptions
  5 | } from "partysocket";
  6 | import type { RPCRequest, RPCResponse } from "./";
  7 | import type {
  8 |   SerializableReturnValue,
  9 |   SerializableValue
 10 | } from "./serializable";
 11 | 
 12 | /**
 13 |  * Options for creating an AgentClient
 14 |  */
 15 | export type AgentClientOptions<State = unknown> = Omit<
 16 |   PartySocketOptions,
 17 |   "party" | "room"
 18 | > & {
 19 |   /** Name of the agent to connect to */
 20 |   agent: string;
 21 |   /** Name of the specific Agent instance */
 22 |   name?: string;
 23 |   /** Called when the Agent's state is updated */
 24 |   onStateUpdate?: (state: State, source: "server" | "client") => void;
 25 | };
 26 | 
 27 | /**
 28 |  * Options for streaming RPC calls
 29 |  */
 30 | export type StreamOptions = {
 31 |   /** Called when a chunk of data is received */
 32 |   onChunk?: (chunk: unknown) => void;
 33 |   /** Called when the stream ends */
 34 |   onDone?: (finalChunk: unknown) => void;
 35 |   /** Called when an error occurs */
 36 |   onError?: (error: string) => void;
 37 | };
 38 | 
 39 | /**
 40 |  * Options for the agentFetch function
 41 |  */
 42 | export type AgentClientFetchOptions = Omit<
 43 |   PartyFetchOptions,
 44 |   "party" | "room"
 45 | > & {
 46 |   /** Name of the agent to connect to */
 47 |   agent: string;
 48 |   /** Name of the specific Agent instance */
 49 |   name?: string;
 50 | };
 51 | 
 52 | /**
 53 |  * Convert a camelCase string to a kebab-case string
 54 |  * @param str The string to convert
 55 |  * @returns The kebab-case string
 56 |  */
 57 | export function camelCaseToKebabCase(str: string): string {
 58 |   // If string is all uppercase, convert to lowercase
 59 |   if (str === str.toUpperCase() && str !== str.toLowerCase()) {
 60 |     return str.toLowerCase().replace(/_/g, "-");
 61 |   }
 62 | 
 63 |   // Otherwise handle camelCase to kebab-case
 64 |   let kebabified = str.replace(
 65 |     /[A-Z]/g,
 66 |     (letter) => `-${letter.toLowerCase()}`
 67 |   );
 68 |   kebabified = kebabified.startsWith("-") ? kebabified.slice(1) : kebabified;
 69 |   // Convert any remaining underscores to hyphens and remove trailing -'s
 70 |   return kebabified.replace(/_/g, "-").replace(/-$/, "");
 71 | }
 72 | 
 73 | /**
 74 |  * WebSocket client for connecting to an Agent
 75 |  */
 76 | export class AgentClient<State = unknown> extends PartySocket {
 77 |   /**
 78 |    * @deprecated Use agentFetch instead
 79 |    */
 80 |   static fetch(_opts: PartyFetchOptions): Promise<Response> {
 81 |     throw new Error(
 82 |       "AgentClient.fetch is not implemented, use agentFetch instead"
 83 |     );
 84 |   }
 85 |   agent: string;
 86 |   name: string;
 87 |   private options: AgentClientOptions<State>;
 88 |   private _pendingCalls = new Map<
 89 |     string,
 90 |     {
 91 |       resolve: (value: unknown) => void;
 92 |       reject: (error: Error) => void;
 93 |       stream?: StreamOptions;
 94 |       type?: unknown;
 95 |     }
 96 |   >();
 97 | 
 98 |   constructor(options: AgentClientOptions<State>) {
 99 |     const agentNamespace = camelCaseToKebabCase(options.agent);
100 |     super({
101 |       party: agentNamespace,
102 |       prefix: "agents",
103 |       room: options.name || "default",
104 |       ...options
105 |     });
106 |     this.agent = agentNamespace;
107 |     this.name = options.name || "default";
108 |     this.options = options;
109 | 
110 |     this.addEventListener("message", (event) => {
111 |       if (typeof event.data === "string") {
112 |         let parsedMessage: Record<string, unknown>;
113 |         try {
114 |           parsedMessage = JSON.parse(event.data);
115 |         } catch (_error) {
116 |           // silently ignore invalid messages for now
117 |           // TODO: log errors with log levels
118 |           return;
119 |         }
120 |         if (parsedMessage.type === "cf_agent_state") {
121 |           this.options.onStateUpdate?.(parsedMessage.state as State, "server");
122 |           return;
123 |         }
124 |         if (parsedMessage.type === "rpc") {
125 |           const response = parsedMessage as RPCResponse;
126 |           const pending = this._pendingCalls.get(response.id);
127 |           if (!pending) return;
128 | 
129 |           if (!response.success) {
130 |             pending.reject(new Error(response.error));
131 |             this._pendingCalls.delete(response.id);
132 |             pending.stream?.onError?.(response.error);
133 |             return;
134 |           }
135 | 
136 |           // Handle streaming responses
137 |           if ("done" in response) {
138 |             if (response.done) {
139 |               pending.resolve(response.result);
140 |               this._pendingCalls.delete(response.id);
141 |               pending.stream?.onDone?.(response.result);
142 |             } else {
143 |               pending.stream?.onChunk?.(response.result);
144 |             }
145 |           } else {
146 |             // Non-streaming response
147 |             pending.resolve(response.result);
148 |             this._pendingCalls.delete(response.id);
149 |           }
150 |         }
151 |       }
152 |     });
153 |   }
154 | 
155 |   setState(state: State) {
156 |     this.send(JSON.stringify({ state, type: "cf_agent_state" }));
157 |     this.options.onStateUpdate?.(state, "client");
158 |   }
159 | 
160 |   /**
161 |    * Call a method on the Agent
162 |    * @param method Name of the method to call
163 |    * @param args Arguments to pass to the method
164 |    * @param streamOptions Options for handling streaming responses
165 |    * @returns Promise that resolves with the method's return value
166 |    */
167 |   call<T extends SerializableReturnValue>(
168 |     method: string,
169 |     args?: SerializableValue[],
170 |     streamOptions?: StreamOptions
171 |   ): Promise<T>;
172 |   call<T = unknown>(
173 |     method: string,
174 |     args?: unknown[],
175 |     streamOptions?: StreamOptions
176 |   ): Promise<T>;
177 |   async call<T>(
178 |     method: string,
179 |     args: unknown[] = [],
180 |     streamOptions?: StreamOptions
181 |   ): Promise<T> {
182 |     return new Promise<T>((resolve, reject) => {
183 |       const id = Math.random().toString(36).slice(2);
184 |       this._pendingCalls.set(id, {
185 |         reject,
186 |         resolve: (value: unknown) => resolve(value as T),
187 |         stream: streamOptions,
188 |         type: null as T
189 |       });
190 | 
191 |       const request: RPCRequest = {
192 |         args,
193 |         id,
194 |         method,
195 |         type: "rpc"
196 |       };
197 | 
198 |       this.send(JSON.stringify(request));
199 |     });
200 |   }
201 | }
202 | 
203 | /**
204 |  * Make an HTTP request to an Agent
205 |  * @param opts Connection options
206 |  * @param init Request initialization options
207 |  * @returns Promise resolving to a Response
208 |  */
209 | export function agentFetch(opts: AgentClientFetchOptions, init?: RequestInit) {
210 |   const agentNamespace = camelCaseToKebabCase(opts.agent);
211 | 
212 |   return PartySocket.fetch(
213 |     {
214 |       party: agentNamespace,
215 |       prefix: "agents",
216 |       room: opts.name || "default",
217 |       ...opts
218 |     },
219 |     init
220 |   );
221 | }
222 | 


--------------------------------------------------------------------------------
/packages/agents/src/index.ts:
--------------------------------------------------------------------------------
   1 | import type { env } from "cloudflare:workers";
   2 | import { AsyncLocalStorage } from "node:async_hooks";
   3 | import type { Client } from "@modelcontextprotocol/sdk/client/index.js";
   4 | import type { SSEClientTransportOptions } from "@modelcontextprotocol/sdk/client/sse.js";
   5 | 
   6 | import type {
   7 |   Prompt,
   8 |   Resource,
   9 |   ServerCapabilities,
  10 |   Tool
  11 | } from "@modelcontextprotocol/sdk/types.js";
  12 | import { parseCronExpression } from "cron-schedule";
  13 | import { nanoid } from "nanoid";
  14 | import { EmailMessage } from "cloudflare:email";
  15 | import {
  16 |   type Connection,
  17 |   type ConnectionContext,
  18 |   type PartyServerOptions,
  19 |   Server,
  20 |   type WSMessage,
  21 |   getServerByName,
  22 |   routePartykitRequest
  23 | } from "partyserver";
  24 | import { camelCaseToKebabCase } from "./client";
  25 | import { MCPClientManager } from "./mcp/client";
  26 | // import type { MCPClientConnection } from "./mcp/client-connection";
  27 | import { DurableObjectOAuthClientProvider } from "./mcp/do-oauth-client-provider";
  28 | import { genericObservability, type Observability } from "./observability";
  29 | 
  30 | export type { Connection, ConnectionContext, WSMessage } from "partyserver";
  31 | 
  32 | /**
  33 |  * RPC request message from client
  34 |  */
  35 | export type RPCRequest = {
  36 |   type: "rpc";
  37 |   id: string;
  38 |   method: string;
  39 |   args: unknown[];
  40 | };
  41 | 
  42 | /**
  43 |  * State update message from client
  44 |  */
  45 | export type StateUpdateMessage = {
  46 |   type: "cf_agent_state";
  47 |   state: unknown;
  48 | };
  49 | 
  50 | /**
  51 |  * RPC response message to client
  52 |  */
  53 | export type RPCResponse = {
  54 |   type: "rpc";
  55 |   id: string;
  56 | } & (
  57 |   | {
  58 |       success: true;
  59 |       result: unknown;
  60 |       done?: false;
  61 |     }
  62 |   | {
  63 |       success: true;
  64 |       result: unknown;
  65 |       done: true;
  66 |     }
  67 |   | {
  68 |       success: false;
  69 |       error: string;
  70 |     }
  71 | );
  72 | 
  73 | /**
  74 |  * Type guard for RPC request messages
  75 |  */
  76 | function isRPCRequest(msg: unknown): msg is RPCRequest {
  77 |   return (
  78 |     typeof msg === "object" &&
  79 |     msg !== null &&
  80 |     "type" in msg &&
  81 |     msg.type === "rpc" &&
  82 |     "id" in msg &&
  83 |     typeof msg.id === "string" &&
  84 |     "method" in msg &&
  85 |     typeof msg.method === "string" &&
  86 |     "args" in msg &&
  87 |     Array.isArray((msg as RPCRequest).args)
  88 |   );
  89 | }
  90 | 
  91 | /**
  92 |  * Type guard for state update messages
  93 |  */
  94 | function isStateUpdateMessage(msg: unknown): msg is StateUpdateMessage {
  95 |   return (
  96 |     typeof msg === "object" &&
  97 |     msg !== null &&
  98 |     "type" in msg &&
  99 |     msg.type === "cf_agent_state" &&
 100 |     "state" in msg
 101 |   );
 102 | }
 103 | 
 104 | /**
 105 |  * Metadata for a callable method
 106 |  */
 107 | export type CallableMetadata = {
 108 |   /** Optional description of what the method does */
 109 |   description?: string;
 110 |   /** Whether the method supports streaming responses */
 111 |   streaming?: boolean;
 112 | };
 113 | 
 114 | const callableMetadata = new Map<Function, CallableMetadata>();
 115 | 
 116 | /**
 117 |  * Decorator that marks a method as callable by clients
 118 |  * @param metadata Optional metadata about the callable method
 119 |  */
 120 | export function unstable_callable(metadata: CallableMetadata = {}) {
 121 |   return function callableDecorator<This, Args extends unknown[], Return>(
 122 |     target: (this: This, ...args: Args) => Return,
 123 |     // biome-ignore lint/correctness/noUnusedFunctionParameters: later
 124 |     context: ClassMethodDecoratorContext
 125 |   ) {
 126 |     if (!callableMetadata.has(target)) {
 127 |       callableMetadata.set(target, metadata);
 128 |     }
 129 | 
 130 |     return target;
 131 |   };
 132 | }
 133 | 
 134 | export type QueueItem<T = string> = {
 135 |   id: string;
 136 |   payload: T;
 137 |   callback: keyof Agent<unknown>;
 138 |   created_at: number;
 139 | };
 140 | 
 141 | /**
 142 |  * Represents a scheduled task within an Agent
 143 |  * @template T Type of the payload data
 144 |  */
 145 | export type Schedule<T = string> = {
 146 |   /** Unique identifier for the schedule */
 147 |   id: string;
 148 |   /** Name of the method to be called */
 149 |   callback: string;
 150 |   /** Data to be passed to the callback */
 151 |   payload: T;
 152 | } & (
 153 |   | {
 154 |       /** Type of schedule for one-time execution at a specific time */
 155 |       type: "scheduled";
 156 |       /** Timestamp when the task should execute */
 157 |       time: number;
 158 |     }
 159 |   | {
 160 |       /** Type of schedule for delayed execution */
 161 |       type: "delayed";
 162 |       /** Timestamp when the task should execute */
 163 |       time: number;
 164 |       /** Number of seconds to delay execution */
 165 |       delayInSeconds: number;
 166 |     }
 167 |   | {
 168 |       /** Type of schedule for recurring execution based on cron expression */
 169 |       type: "cron";
 170 |       /** Timestamp for the next execution */
 171 |       time: number;
 172 |       /** Cron expression defining the schedule */
 173 |       cron: string;
 174 |     }
 175 | );
 176 | 
 177 | function getNextCronTime(cron: string) {
 178 |   const interval = parseCronExpression(cron);
 179 |   return interval.getNextDate();
 180 | }
 181 | 
 182 | /**
 183 |  * MCP Server state update message from server -> Client
 184 |  */
 185 | export type MCPServerMessage = {
 186 |   type: "cf_agent_mcp_servers";
 187 |   mcp: MCPServersState;
 188 | };
 189 | 
 190 | export type MCPServersState = {
 191 |   servers: {
 192 |     [id: string]: MCPServer;
 193 |   };
 194 |   tools: Tool[];
 195 |   prompts: Prompt[];
 196 |   resources: Resource[];
 197 | };
 198 | 
 199 | export type MCPServer = {
 200 |   name: string;
 201 |   server_url: string;
 202 |   auth_url: string | null;
 203 |   // This state is specifically about the temporary process of getting a token (if needed).
 204 |   // Scope outside of that can't be relied upon because when the DO sleeps, there's no way
 205 |   // to communicate a change to a non-ready state.
 206 |   state: "authenticating" | "connecting" | "ready" | "discovering" | "failed";
 207 |   instructions: string | null;
 208 |   capabilities: ServerCapabilities | null;
 209 | };
 210 | 
 211 | /**
 212 |  * MCP Server data stored in DO SQL for resuming MCP Server connections
 213 |  */
 214 | type MCPServerRow = {
 215 |   id: string;
 216 |   name: string;
 217 |   server_url: string;
 218 |   client_id: string | null;
 219 |   auth_url: string | null;
 220 |   callback_url: string;
 221 |   server_options: string;
 222 | };
 223 | 
 224 | const STATE_ROW_ID = "cf_state_row_id";
 225 | const STATE_WAS_CHANGED = "cf_state_was_changed";
 226 | 
 227 | const DEFAULT_STATE = {} as unknown;
 228 | 
 229 | const agentContext = new AsyncLocalStorage<{
 230 |   agent: Agent<unknown, unknown>;
 231 |   connection: Connection | undefined;
 232 |   request: Request | undefined;
 233 |   email: AgentEmail | undefined;
 234 | }>();
 235 | 
 236 | export function getCurrentAgent<
 237 |   T extends Agent<unknown, unknown> = Agent<unknown, unknown>
 238 | >(): {
 239 |   agent: T | undefined;
 240 |   connection: Connection | undefined;
 241 |   request: Request | undefined;
 242 |   email: AgentEmail | undefined;
 243 | } {
 244 |   const store = agentContext.getStore() as
 245 |     | {
 246 |         agent: T;
 247 |         connection: Connection | undefined;
 248 |         request: Request | undefined;
 249 |         email: AgentEmail | undefined;
 250 |       }
 251 |     | undefined;
 252 |   if (!store) {
 253 |     return {
 254 |       agent: undefined,
 255 |       connection: undefined,
 256 |       request: undefined,
 257 |       email: undefined
 258 |     };
 259 |   }
 260 |   return store;
 261 | }
 262 | 
 263 | /**
 264 |  * Wraps a method to run within the agent context, ensuring getCurrentAgent() works properly
 265 |  * @param agent The agent instance
 266 |  * @param method The method to wrap
 267 |  * @returns A wrapped method that runs within the agent context
 268 |  */
 269 | 
 270 | // biome-ignore lint/suspicious/noExplicitAny: I can't typescript
 271 | function withAgentContext<T extends (...args: any[]) => any>(
 272 |   method: T
 273 | ): (this: Agent<unknown, unknown>, ...args: Parameters<T>) => ReturnType<T> {
 274 |   return function (...args: Parameters<T>): ReturnType<T> {
 275 |     const { connection, request, email } = getCurrentAgent();
 276 |     return agentContext.run({ agent: this, connection, request, email }, () => {
 277 |       return method.apply(this, args);
 278 |     });
 279 |   };
 280 | }
 281 | 
 282 | /**
 283 |  * Base class for creating Agent implementations
 284 |  * @template Env Environment type containing bindings
 285 |  * @template State State type to store within the Agent
 286 |  */
 287 | export class Agent<Env = typeof env, State = unknown> extends Server<Env> {
 288 |   private _state = DEFAULT_STATE as State;
 289 | 
 290 |   private _ParentClass: typeof Agent<Env, State> =
 291 |     Object.getPrototypeOf(this).constructor;
 292 | 
 293 |   mcp: MCPClientManager = new MCPClientManager(this._ParentClass.name, "0.0.1");
 294 | 
 295 |   /**
 296 |    * Initial state for the Agent
 297 |    * Override to provide default state values
 298 |    */
 299 |   initialState: State = DEFAULT_STATE as State;
 300 | 
 301 |   /**
 302 |    * Current state of the Agent
 303 |    */
 304 |   get state(): State {
 305 |     if (this._state !== DEFAULT_STATE) {
 306 |       // state was previously set, and populated internal state
 307 |       return this._state;
 308 |     }
 309 |     // looks like this is the first time the state is being accessed
 310 |     // check if the state was set in a previous life
 311 |     const wasChanged = this.sql<{ state: "true" | undefined }>`
 312 |         SELECT state FROM cf_agents_state WHERE id = ${STATE_WAS_CHANGED}
 313 |       `;
 314 | 
 315 |     // ok, let's pick up the actual state from the db
 316 |     const result = this.sql<{ state: State | undefined }>`
 317 |       SELECT state FROM cf_agents_state WHERE id = ${STATE_ROW_ID}
 318 |     `;
 319 | 
 320 |     if (
 321 |       wasChanged[0]?.state === "true" ||
 322 |       // we do this check for people who updated their code before we shipped wasChanged
 323 |       result[0]?.state
 324 |     ) {
 325 |       const state = result[0]?.state as string; // could be null?
 326 | 
 327 |       this._state = JSON.parse(state);
 328 |       return this._state;
 329 |     }
 330 | 
 331 |     // ok, this is the first time the state is being accessed
 332 |     // and the state was not set in a previous life
 333 |     // so we need to set the initial state (if provided)
 334 |     if (this.initialState === DEFAULT_STATE) {
 335 |       // no initial state provided, so we return undefined
 336 |       return undefined as State;
 337 |     }
 338 |     // initial state provided, so we set the state,
 339 |     // update db and return the initial state
 340 |     this.setState(this.initialState);
 341 |     return this.initialState;
 342 |   }
 343 | 
 344 |   /**
 345 |    * Agent configuration options
 346 |    */
 347 |   static options = {
 348 |     /** Whether the Agent should hibernate when inactive */
 349 |     hibernate: true // default to hibernate
 350 |   };
 351 | 
 352 |   /**
 353 |    * The observability implementation to use for the Agent
 354 |    */
 355 |   observability?: Observability = genericObservability;
 356 | 
 357 |   /**
 358 |    * Execute SQL queries against the Agent's database
 359 |    * @template T Type of the returned rows
 360 |    * @param strings SQL query template strings
 361 |    * @param values Values to be inserted into the query
 362 |    * @returns Array of query results
 363 |    */
 364 |   sql<T = Record<string, string | number | boolean | null>>(
 365 |     strings: TemplateStringsArray,
 366 |     ...values: (string | number | boolean | null)[]
 367 |   ) {
 368 |     let query = "";
 369 |     try {
 370 |       // Construct the SQL query with placeholders
 371 |       query = strings.reduce(
 372 |         (acc, str, i) => acc + str + (i < values.length ? "?" : ""),
 373 |         ""
 374 |       );
 375 | 
 376 |       // Execute the SQL query with the provided values
 377 |       return [...this.ctx.storage.sql.exec(query, ...values)] as T[];
 378 |     } catch (e) {
 379 |       console.error(`failed to execute sql query: ${query}`, e);
 380 |       throw this.onError(e);
 381 |     }
 382 |   }
 383 |   constructor(ctx: AgentContext, env: Env) {
 384 |     super(ctx, env);
 385 | 
 386 |     // Auto-wrap custom methods with agent context
 387 |     this._autoWrapCustomMethods();
 388 | 
 389 |     this.sql`
 390 |       CREATE TABLE IF NOT EXISTS cf_agents_state (
 391 |         id TEXT PRIMARY KEY NOT NULL,
 392 |         state TEXT
 393 |       )
 394 |     `;
 395 | 
 396 |     this.sql`
 397 |       CREATE TABLE IF NOT EXISTS cf_agents_queues (
 398 |         id TEXT PRIMARY KEY NOT NULL,
 399 |         payload TEXT,
 400 |         callback TEXT,
 401 |         created_at INTEGER DEFAULT (unixepoch())
 402 |       )
 403 |     `;
 404 | 
 405 |     void this.ctx.blockConcurrencyWhile(async () => {
 406 |       return this._tryCatch(async () => {
 407 |         // Create alarms table if it doesn't exist
 408 |         this.sql`
 409 |         CREATE TABLE IF NOT EXISTS cf_agents_schedules (
 410 |           id TEXT PRIMARY KEY NOT NULL DEFAULT (randomblob(9)),
 411 |           callback TEXT,
 412 |           payload TEXT,
 413 |           type TEXT NOT NULL CHECK(type IN ('scheduled', 'delayed', 'cron')),
 414 |           time INTEGER,
 415 |           delayInSeconds INTEGER,
 416 |           cron TEXT,
 417 |           created_at INTEGER DEFAULT (unixepoch())
 418 |         )
 419 |       `;
 420 | 
 421 |         // execute any pending alarms and schedule the next alarm
 422 |         await this.alarm();
 423 |       });
 424 |     });
 425 | 
 426 |     this.sql`
 427 |       CREATE TABLE IF NOT EXISTS cf_agents_mcp_servers (
 428 |         id TEXT PRIMARY KEY NOT NULL,
 429 |         name TEXT NOT NULL,
 430 |         server_url TEXT NOT NULL,
 431 |         callback_url TEXT NOT NULL,
 432 |         client_id TEXT,
 433 |         auth_url TEXT,
 434 |         server_options TEXT
 435 |       )
 436 |     `;
 437 | 
 438 |     const _onRequest = this.onRequest.bind(this);
 439 |     this.onRequest = (request: Request) => {
 440 |       return agentContext.run(
 441 |         { agent: this, connection: undefined, request, email: undefined },
 442 |         async () => {
 443 |           if (this.mcp.isCallbackRequest(request)) {
 444 |             await this.mcp.handleCallbackRequest(request);
 445 | 
 446 |             // after the MCP connection handshake, we can send updated mcp state
 447 |             this.broadcast(
 448 |               JSON.stringify({
 449 |                 mcp: this.getMcpServers(),
 450 |                 type: "cf_agent_mcp_servers"
 451 |               })
 452 |             );
 453 | 
 454 |             // We probably should let the user configure this response/redirect, but this is fine for now.
 455 |             return new Response("<script>window.close();</script>", {
 456 |               headers: { "content-type": "text/html" },
 457 |               status: 200
 458 |             });
 459 |           }
 460 | 
 461 |           return this._tryCatch(() => _onRequest(request));
 462 |         }
 463 |       );
 464 |     };
 465 | 
 466 |     const _onMessage = this.onMessage.bind(this);
 467 |     this.onMessage = async (connection: Connection, message: WSMessage) => {
 468 |       return agentContext.run(
 469 |         { agent: this, connection, request: undefined, email: undefined },
 470 |         async () => {
 471 |           if (typeof message !== "string") {
 472 |             return this._tryCatch(() => _onMessage(connection, message));
 473 |           }
 474 | 
 475 |           let parsed: unknown;
 476 |           try {
 477 |             parsed = JSON.parse(message);
 478 |           } catch (_e) {
 479 |             // silently fail and let the onMessage handler handle it
 480 |             return this._tryCatch(() => _onMessage(connection, message));
 481 |           }
 482 | 
 483 |           if (isStateUpdateMessage(parsed)) {
 484 |             this._setStateInternal(parsed.state as State, connection);
 485 |             return;
 486 |           }
 487 | 
 488 |           if (isRPCRequest(parsed)) {
 489 |             try {
 490 |               const { id, method, args } = parsed;
 491 | 
 492 |               // Check if method exists and is callable
 493 |               const methodFn = this[method as keyof this];
 494 |               if (typeof methodFn !== "function") {
 495 |                 throw new Error(`Method ${method} does not exist`);
 496 |               }
 497 | 
 498 |               if (!this._isCallable(method)) {
 499 |                 throw new Error(`Method ${method} is not callable`);
 500 |               }
 501 | 
 502 |               const metadata = callableMetadata.get(methodFn as Function);
 503 | 
 504 |               // For streaming methods, pass a StreamingResponse object
 505 |               if (metadata?.streaming) {
 506 |                 const stream = new StreamingResponse(connection, id);
 507 |                 await methodFn.apply(this, [stream, ...args]);
 508 |                 return;
 509 |               }
 510 | 
 511 |               // For regular methods, execute and send response
 512 |               const result = await methodFn.apply(this, args);
 513 | 
 514 |               this.observability?.emit(
 515 |                 {
 516 |                   displayMessage: `RPC call to ${method}`,
 517 |                   id: nanoid(),
 518 |                   payload: {
 519 |                     args,
 520 |                     method,
 521 |                     streaming: metadata?.streaming,
 522 |                     success: true
 523 |                   },
 524 |                   timestamp: Date.now(),
 525 |                   type: "rpc"
 526 |                 },
 527 |                 this.ctx
 528 |               );
 529 | 
 530 |               const response: RPCResponse = {
 531 |                 done: true,
 532 |                 id,
 533 |                 result,
 534 |                 success: true,
 535 |                 type: "rpc"
 536 |               };
 537 |               connection.send(JSON.stringify(response));
 538 |             } catch (e) {
 539 |               // Send error response
 540 |               const response: RPCResponse = {
 541 |                 error:
 542 |                   e instanceof Error ? e.message : "Unknown error occurred",
 543 |                 id: parsed.id,
 544 |                 success: false,
 545 |                 type: "rpc"
 546 |               };
 547 |               connection.send(JSON.stringify(response));
 548 |               console.error("RPC error:", e);
 549 |             }
 550 |             return;
 551 |           }
 552 | 
 553 |           return this._tryCatch(() => _onMessage(connection, message));
 554 |         }
 555 |       );
 556 |     };
 557 | 
 558 |     const _onConnect = this.onConnect.bind(this);
 559 |     this.onConnect = (connection: Connection, ctx: ConnectionContext) => {
 560 |       // TODO: This is a hack to ensure the state is sent after the connection is established
 561 |       // must fix this
 562 |       return agentContext.run(
 563 |         { agent: this, connection, request: ctx.request, email: undefined },
 564 |         async () => {
 565 |           setTimeout(() => {
 566 |             if (this.state) {
 567 |               connection.send(
 568 |                 JSON.stringify({
 569 |                   state: this.state,
 570 |                   type: "cf_agent_state"
 571 |                 })
 572 |               );
 573 |             }
 574 | 
 575 |             connection.send(
 576 |               JSON.stringify({
 577 |                 mcp: this.getMcpServers(),
 578 |                 type: "cf_agent_mcp_servers"
 579 |               })
 580 |             );
 581 | 
 582 |             this.observability?.emit(
 583 |               {
 584 |                 displayMessage: "Connection established",
 585 |                 id: nanoid(),
 586 |                 payload: {
 587 |                   connectionId: connection.id
 588 |                 },
 589 |                 timestamp: Date.now(),
 590 |                 type: "connect"
 591 |               },
 592 |               this.ctx
 593 |             );
 594 |             return this._tryCatch(() => _onConnect(connection, ctx));
 595 |           }, 20);
 596 |         }
 597 |       );
 598 |     };
 599 | 
 600 |     const _onStart = this.onStart.bind(this);
 601 |     this.onStart = async () => {
 602 |       return agentContext.run(
 603 |         {
 604 |           agent: this,
 605 |           connection: undefined,
 606 |           request: undefined,
 607 |           email: undefined
 608 |         },
 609 |         async () => {
 610 |           const servers = this.sql<MCPServerRow>`
 611 |             SELECT id, name, server_url, client_id, auth_url, callback_url, server_options FROM cf_agents_mcp_servers;
 612 |           `;
 613 | 
 614 |           // from DO storage, reconnect to all servers not currently in the oauth flow using our saved auth information
 615 |           if (servers && Array.isArray(servers) && servers.length > 0) {
 616 |             Promise.allSettled(
 617 |               servers.map((server) => {
 618 |                 return this._connectToMcpServerInternal(
 619 |                   server.name,
 620 |                   server.server_url,
 621 |                   server.callback_url,
 622 |                   server.server_options
 623 |                     ? JSON.parse(server.server_options)
 624 |                     : undefined,
 625 |                   {
 626 |                     id: server.id,
 627 |                     oauthClientId: server.client_id ?? undefined
 628 |                   }
 629 |                 );
 630 |               })
 631 |             ).then((_results) => {
 632 |               this.broadcast(
 633 |                 JSON.stringify({
 634 |                   mcp: this.getMcpServers(),
 635 |                   type: "cf_agent_mcp_servers"
 636 |                 })
 637 |               );
 638 |             });
 639 |           }
 640 |           await this._tryCatch(() => _onStart());
 641 |         }
 642 |       );
 643 |     };
 644 |   }
 645 | 
 646 |   private _setStateInternal(
 647 |     state: State,
 648 |     source: Connection | "server" = "server"
 649 |   ) {
 650 |     const previousState = this._state;
 651 |     this._state = state;
 652 |     this.sql`
 653 |     INSERT OR REPLACE INTO cf_agents_state (id, state)
 654 |     VALUES (${STATE_ROW_ID}, ${JSON.stringify(state)})
 655 |   `;
 656 |     this.sql`
 657 |     INSERT OR REPLACE INTO cf_agents_state (id, state)
 658 |     VALUES (${STATE_WAS_CHANGED}, ${JSON.stringify(true)})
 659 |   `;
 660 |     this.broadcast(
 661 |       JSON.stringify({
 662 |         state: state,
 663 |         type: "cf_agent_state"
 664 |       }),
 665 |       source !== "server" ? [source.id] : []
 666 |     );
 667 |     return this._tryCatch(() => {
 668 |       const { connection, request, email } = agentContext.getStore() || {};
 669 |       return agentContext.run(
 670 |         { agent: this, connection, request, email },
 671 |         async () => {
 672 |           this.observability?.emit(
 673 |             {
 674 |               displayMessage: "State updated",
 675 |               id: nanoid(),
 676 |               payload: {
 677 |                 previousState,
 678 |                 state
 679 |               },
 680 |               timestamp: Date.now(),
 681 |               type: "state:update"
 682 |             },
 683 |             this.ctx
 684 |           );
 685 |           return this.onStateUpdate(state, source);
 686 |         }
 687 |       );
 688 |     });
 689 |   }
 690 | 
 691 |   /**
 692 |    * Update the Agent's state
 693 |    * @param state New state to set
 694 |    */
 695 |   setState(state: State) {
 696 |     this._setStateInternal(state, "server");
 697 |   }
 698 | 
 699 |   /**
 700 |    * Called when the Agent's state is updated
 701 |    * @param state Updated state
 702 |    * @param source Source of the state update ("server" or a client connection)
 703 |    */
 704 |   // biome-ignore lint/correctness/noUnusedFunctionParameters: overridden later
 705 |   onStateUpdate(state: State | undefined, source: Connection | "server") {
 706 |     // override this to handle state updates
 707 |   }
 708 | 
 709 |   /**
 710 |    * Called when the Agent receives an email via routeAgentEmail()
 711 |    * Override this method to handle incoming emails
 712 |    * @param email Email message to process
 713 |    */
 714 |   async _onEmail(email: AgentEmail) {
 715 |     // nb: we use this roundabout way of getting to onEmail
 716 |     // because of https://github.com/cloudflare/workerd/issues/4499
 717 |     return agentContext.run(
 718 |       { agent: this, connection: undefined, request: undefined, email: email },
 719 |       async () => {
 720 |         if ("onEmail" in this && typeof this.onEmail === "function") {
 721 |           return this._tryCatch(() =>
 722 |             (this.onEmail as (email: AgentEmail) => Promise<void>)(email)
 723 |           );
 724 |         } else {
 725 |           console.log("Received email from:", email.from, "to:", email.to);
 726 |           console.log("Subject:", email.headers.get("subject"));
 727 |           console.log(
 728 |             "Implement onEmail(email: AgentEmail): Promise<void> in your agent to process emails"
 729 |           );
 730 |         }
 731 |       }
 732 |     );
 733 |   }
 734 | 
 735 |   /**
 736 |    * Reply to an email
 737 |    * @param email The email to reply to
 738 |    * @param options Options for the reply
 739 |    * @returns void
 740 |    */
 741 |   async replyToEmail(
 742 |     email: AgentEmail,
 743 |     options: {
 744 |       fromName: string;
 745 |       subject?: string | undefined;
 746 |       body: string;
 747 |       contentType?: string;
 748 |       headers?: Record<string, string>;
 749 |     }
 750 |   ): Promise<void> {
 751 |     return this._tryCatch(async () => {
 752 |       const agentName = camelCaseToKebabCase(this._ParentClass.name);
 753 |       const agentId = this.name;
 754 | 
 755 |       const { createMimeMessage } = await import("mimetext");
 756 |       const msg = createMimeMessage();
 757 |       msg.setSender({ addr: email.to, name: options.fromName });
 758 |       msg.setRecipient(email.from);
 759 |       msg.setSubject(
 760 |         options.subject || `Re: ${email.headers.get("subject")}` || "No subject"
 761 |       );
 762 |       msg.addMessage({
 763 |         contentType: options.contentType || "text/plain",
 764 |         data: options.body
 765 |       });
 766 | 
 767 |       const domain = email.from.split("@")[1];
 768 |       const messageId = `<${agentId}@${domain}>`;
 769 |       msg.setHeader("In-Reply-To", email.headers.get("Message-ID")!);
 770 |       msg.setHeader("Message-ID", messageId);
 771 |       msg.setHeader("X-Agent-Name", agentName);
 772 |       msg.setHeader("X-Agent-ID", agentId);
 773 | 
 774 |       if (options.headers) {
 775 |         for (const [key, value] of Object.entries(options.headers)) {
 776 |           msg.setHeader(key, value);
 777 |         }
 778 |       }
 779 |       await email.reply({
 780 |         from: email.to,
 781 |         raw: msg.asRaw(),
 782 |         to: email.from
 783 |       });
 784 |     });
 785 |   }
 786 | 
 787 |   private async _tryCatch<T>(fn: () => T | Promise<T>) {
 788 |     try {
 789 |       return await fn();
 790 |     } catch (e) {
 791 |       throw this.onError(e);
 792 |     }
 793 |   }
 794 | 
 795 |   /**
 796 |    * Automatically wrap custom methods with agent context
 797 |    * This ensures getCurrentAgent() works in all custom methods without decorators
 798 |    */
 799 |   private _autoWrapCustomMethods() {
 800 |     // Collect all methods from base prototypes (Agent and Server)
 801 |     const basePrototypes = [Agent.prototype, Server.prototype];
 802 |     const baseMethods = new Set<string>();
 803 |     for (const baseProto of basePrototypes) {
 804 |       let proto = baseProto;
 805 |       while (proto && proto !== Object.prototype) {
 806 |         const methodNames = Object.getOwnPropertyNames(proto);
 807 |         for (const methodName of methodNames) {
 808 |           baseMethods.add(methodName);
 809 |         }
 810 |         proto = Object.getPrototypeOf(proto);
 811 |       }
 812 |     }
 813 |     // Get all methods from the current instance's prototype chain
 814 |     let proto = Object.getPrototypeOf(this);
 815 |     let depth = 0;
 816 |     while (proto && proto !== Object.prototype && depth < 10) {
 817 |       const methodNames = Object.getOwnPropertyNames(proto);
 818 |       for (const methodName of methodNames) {
 819 |         // Skip if it's a private method or not a function
 820 |         if (
 821 |           baseMethods.has(methodName) ||
 822 |           methodName.startsWith("_") ||
 823 |           typeof this[methodName as keyof this] !== "function"
 824 |         ) {
 825 |           continue;
 826 |         }
 827 |         // If the method doesn't exist in base prototypes, it's a custom method
 828 |         if (!baseMethods.has(methodName)) {
 829 |           const descriptor = Object.getOwnPropertyDescriptor(proto, methodName);
 830 |           if (descriptor && typeof descriptor.value === "function") {
 831 |             // Wrap the custom method with context
 832 | 
 833 |             const wrappedFunction = withAgentContext(
 834 |               // biome-ignore lint/suspicious/noExplicitAny: I can't typescript
 835 |               this[methodName as keyof this] as (...args: any[]) => any
 836 |               // biome-ignore lint/suspicious/noExplicitAny: I can't typescript
 837 |             ) as any;
 838 | 
 839 |             // if the method is callable, copy the metadata from the original method
 840 |             if (this._isCallable(methodName)) {
 841 |               callableMetadata.set(
 842 |                 wrappedFunction,
 843 |                 callableMetadata.get(
 844 |                   this[methodName as keyof this] as Function
 845 |                 )!
 846 |               );
 847 |             }
 848 | 
 849 |             // set the wrapped function on the prototype
 850 |             this.constructor.prototype[methodName as keyof this] =
 851 |               wrappedFunction;
 852 |           }
 853 |         }
 854 |       }
 855 | 
 856 |       proto = Object.getPrototypeOf(proto);
 857 |       depth++;
 858 |     }
 859 |   }
 860 | 
 861 |   override onError(
 862 |     connection: Connection,
 863 |     error: unknown
 864 |   ): void | Promise<void>;
 865 |   override onError(error: unknown): void | Promise<void>;
 866 |   override onError(connectionOrError: Connection | unknown, error?: unknown) {
 867 |     let theError: unknown;
 868 |     if (connectionOrError && error) {
 869 |       theError = error;
 870 |       // this is a websocket connection error
 871 |       console.error(
 872 |         "Error on websocket connection:",
 873 |         (connectionOrError as Connection).id,
 874 |         theError
 875 |       );
 876 |       console.error(
 877 |         "Override onError(connection, error) to handle websocket connection errors"
 878 |       );
 879 |     } else {
 880 |       theError = connectionOrError;
 881 |       // this is a server error
 882 |       console.error("Error on server:", theError);
 883 |       console.error("Override onError(error) to handle server errors");
 884 |     }
 885 |     throw theError;
 886 |   }
 887 | 
 888 |   /**
 889 |    * Render content (not implemented in base class)
 890 |    */
 891 |   render() {
 892 |     throw new Error("Not implemented");
 893 |   }
 894 | 
 895 |   /**
 896 |    * Queue a task to be executed in the future
 897 |    * @param payload Payload to pass to the callback
 898 |    * @param callback Name of the method to call
 899 |    * @returns The ID of the queued task
 900 |    */
 901 |   async queue<T = unknown>(callback: keyof this, payload: T): Promise<string> {
 902 |     const id = nanoid(9);
 903 |     if (typeof callback !== "string") {
 904 |       throw new Error("Callback must be a string");
 905 |     }
 906 | 
 907 |     if (typeof this[callback] !== "function") {
 908 |       throw new Error(`this.${callback} is not a function`);
 909 |     }
 910 | 
 911 |     this.sql`
 912 |       INSERT OR REPLACE INTO cf_agents_queues (id, payload, callback)
 913 |       VALUES (${id}, ${JSON.stringify(payload)}, ${callback})
 914 |     `;
 915 | 
 916 |     void this._flushQueue().catch((e) => {
 917 |       console.error("Error flushing queue:", e);
 918 |     });
 919 | 
 920 |     return id;
 921 |   }
 922 | 
 923 |   private _flushingQueue = false;
 924 | 
 925 |   private async _flushQueue() {
 926 |     if (this._flushingQueue) {
 927 |       return;
 928 |     }
 929 |     this._flushingQueue = true;
 930 |     while (true) {
 931 |       const result = this.sql<QueueItem<string>>`
 932 |       SELECT * FROM cf_agents_queues
 933 |       ORDER BY created_at ASC
 934 |     `;
 935 | 
 936 |       if (!result || result.length === 0) {
 937 |         break;
 938 |       }
 939 | 
 940 |       for (const row of result || []) {
 941 |         const callback = this[row.callback as keyof Agent<Env>];
 942 |         if (!callback) {
 943 |           console.error(`callback ${row.callback} not found`);
 944 |           continue;
 945 |         }
 946 |         const { connection, request, email } = agentContext.getStore() || {};
 947 |         await agentContext.run(
 948 |           {
 949 |             agent: this,
 950 |             connection,
 951 |             request,
 952 |             email
 953 |           },
 954 |           async () => {
 955 |             // TODO: add retries and backoff
 956 |             await (
 957 |               callback as (
 958 |                 payload: unknown,
 959 |                 queueItem: QueueItem<string>
 960 |               ) => Promise<void>
 961 |             ).bind(this)(JSON.parse(row.payload as string), row);
 962 |             await this.dequeue(row.id);
 963 |           }
 964 |         );
 965 |       }
 966 |     }
 967 |     this._flushingQueue = false;
 968 |   }
 969 | 
 970 |   /**
 971 |    * Dequeue a task by ID
 972 |    * @param id ID of the task to dequeue
 973 |    */
 974 |   async dequeue(id: string) {
 975 |     this.sql`DELETE FROM cf_agents_queues WHERE id = ${id}`;
 976 |   }
 977 | 
 978 |   /**
 979 |    * Dequeue all tasks
 980 |    */
 981 |   async dequeueAll() {
 982 |     this.sql`DELETE FROM cf_agents_queues`;
 983 |   }
 984 | 
 985 |   /**
 986 |    * Dequeue all tasks by callback
 987 |    * @param callback Name of the callback to dequeue
 988 |    */
 989 |   async dequeueAllByCallback(callback: string) {
 990 |     this.sql`DELETE FROM cf_agents_queues WHERE callback = ${callback}`;
 991 |   }
 992 | 
 993 |   /**
 994 |    * Get a queued task by ID
 995 |    * @param id ID of the task to get
 996 |    * @returns The task or undefined if not found
 997 |    */
 998 |   async getQueue(id: string): Promise<QueueItem<string> | undefined> {
 999 |     const result = this.sql<QueueItem<string>>`
1000 |       SELECT * FROM cf_agents_queues WHERE id = ${id}
1001 |     `;
1002 |     return result
1003 |       ? { ...result[0], payload: JSON.parse(result[0].payload) }
1004 |       : undefined;
1005 |   }
1006 | 
1007 |   /**
1008 |    * Get all queues by key and value
1009 |    * @param key Key to filter by
1010 |    * @param value Value to filter by
1011 |    * @returns Array of matching QueueItem objects
1012 |    */
1013 |   async getQueues(key: string, value: string): Promise<QueueItem<string>[]> {
1014 |     const result = this.sql<QueueItem<string>>`
1015 |       SELECT * FROM cf_agents_queues
1016 |     `;
1017 |     return result.filter((row) => JSON.parse(row.payload)[key] === value);
1018 |   }
1019 | 
1020 |   /**
1021 |    * Schedule a task to be executed in the future
1022 |    * @template T Type of the payload data
1023 |    * @param when When to execute the task (Date, seconds delay, or cron expression)
1024 |    * @param callback Name of the method to call
1025 |    * @param payload Data to pass to the callback
1026 |    * @returns Schedule object representing the scheduled task
1027 |    */
1028 |   async schedule<T = string>(
1029 |     when: Date | string | number,
1030 |     callback: keyof this,
1031 |     payload?: T
1032 |   ): Promise<Schedule<T>> {
1033 |     const id = nanoid(9);
1034 | 
1035 |     const emitScheduleCreate = (schedule: Schedule<T>) =>
1036 |       this.observability?.emit(
1037 |         {
1038 |           displayMessage: `Schedule ${schedule.id} created`,
1039 |           id: nanoid(),
1040 |           payload: schedule,
1041 |           timestamp: Date.now(),
1042 |           type: "schedule:create"
1043 |         },
1044 |         this.ctx
1045 |       );
1046 | 
1047 |     if (typeof callback !== "string") {
1048 |       throw new Error("Callback must be a string");
1049 |     }
1050 | 
1051 |     if (typeof this[callback] !== "function") {
1052 |       throw new Error(`this.${callback} is not a function`);
1053 |     }
1054 | 
1055 |     if (when instanceof Date) {
1056 |       const timestamp = Math.floor(when.getTime() / 1000);
1057 |       this.sql`
1058 |         INSERT OR REPLACE INTO cf_agents_schedules (id, callback, payload, type, time)
1059 |         VALUES (${id}, ${callback}, ${JSON.stringify(
1060 |           payload
1061 |         )}, 'scheduled', ${timestamp})
1062 |       `;
1063 | 
1064 |       await this._scheduleNextAlarm();
1065 | 
1066 |       const schedule: Schedule<T> = {
1067 |         callback: callback,
1068 |         id,
1069 |         payload: payload as T,
1070 |         time: timestamp,
1071 |         type: "scheduled"
1072 |       };
1073 | 
1074 |       emitScheduleCreate(schedule);
1075 | 
1076 |       return schedule;
1077 |     }
1078 |     if (typeof when === "number") {
1079 |       const time = new Date(Date.now() + when * 1000);
1080 |       const timestamp = Math.floor(time.getTime() / 1000);
1081 | 
1082 |       this.sql`
1083 |         INSERT OR REPLACE INTO cf_agents_schedules (id, callback, payload, type, delayInSeconds, time)
1084 |         VALUES (${id}, ${callback}, ${JSON.stringify(
1085 |           payload
1086 |         )}, 'delayed', ${when}, ${timestamp})
1087 |       `;
1088 | 
1089 |       await this._scheduleNextAlarm();
1090 | 
1091 |       const schedule: Schedule<T> = {
1092 |         callback: callback,
1093 |         delayInSeconds: when,
1094 |         id,
1095 |         payload: payload as T,
1096 |         time: timestamp,
1097 |         type: "delayed"
1098 |       };
1099 | 
1100 |       emitScheduleCreate(schedule);
1101 | 
1102 |       return schedule;
1103 |     }
1104 |     if (typeof when === "string") {
1105 |       const nextExecutionTime = getNextCronTime(when);
1106 |       const timestamp = Math.floor(nextExecutionTime.getTime() / 1000);
1107 | 
1108 |       this.sql`
1109 |         INSERT OR REPLACE INTO cf_agents_schedules (id, callback, payload, type, cron, time)
1110 |         VALUES (${id}, ${callback}, ${JSON.stringify(
1111 |           payload
1112 |         )}, 'cron', ${when}, ${timestamp})
1113 |       `;
1114 | 
1115 |       await this._scheduleNextAlarm();
1116 | 
1117 |       const schedule: Schedule<T> = {
1118 |         callback: callback,
1119 |         cron: when,
1120 |         id,
1121 |         payload: payload as T,
1122 |         time: timestamp,
1123 |         type: "cron"
1124 |       };
1125 | 
1126 |       emitScheduleCreate(schedule);
1127 | 
1128 |       return schedule;
1129 |     }
1130 |     throw new Error("Invalid schedule type");
1131 |   }
1132 | 
1133 |   /**
1134 |    * Get a scheduled task by ID
1135 |    * @template T Type of the payload data
1136 |    * @param id ID of the scheduled task
1137 |    * @returns The Schedule object or undefined if not found
1138 |    */
1139 |   async getSchedule<T = string>(id: string): Promise<Schedule<T> | undefined> {
1140 |     const result = this.sql<Schedule<string>>`
1141 |       SELECT * FROM cf_agents_schedules WHERE id = ${id}
1142 |     `;
1143 |     if (!result) {
1144 |       console.error(`schedule ${id} not found`);
1145 |       return undefined;
1146 |     }
1147 | 
1148 |     return { ...result[0], payload: JSON.parse(result[0].payload) as T };
1149 |   }
1150 | 
1151 |   /**
1152 |    * Get scheduled tasks matching the given criteria
1153 |    * @template T Type of the payload data
1154 |    * @param criteria Criteria to filter schedules
1155 |    * @returns Array of matching Schedule objects
1156 |    */
1157 |   getSchedules<T = string>(
1158 |     criteria: {
1159 |       id?: string;
1160 |       type?: "scheduled" | "delayed" | "cron";
1161 |       timeRange?: { start?: Date; end?: Date };
1162 |     } = {}
1163 |   ): Schedule<T>[] {
1164 |     let query = "SELECT * FROM cf_agents_schedules WHERE 1=1";
1165 |     const params = [];
1166 | 
1167 |     if (criteria.id) {
1168 |       query += " AND id = ?";
1169 |       params.push(criteria.id);
1170 |     }
1171 | 
1172 |     if (criteria.type) {
1173 |       query += " AND type = ?";
1174 |       params.push(criteria.type);
1175 |     }
1176 | 
1177 |     if (criteria.timeRange) {
1178 |       query += " AND time >= ? AND time <= ?";
1179 |       const start = criteria.timeRange.start || new Date(0);
1180 |       const end = criteria.timeRange.end || new Date(999999999999999);
1181 |       params.push(
1182 |         Math.floor(start.getTime() / 1000),
1183 |         Math.floor(end.getTime() / 1000)
1184 |       );
1185 |     }
1186 | 
1187 |     const result = this.ctx.storage.sql
1188 |       .exec(query, ...params)
1189 |       .toArray()
1190 |       .map((row) => ({
1191 |         ...row,
1192 |         payload: JSON.parse(row.payload as string) as T
1193 |       })) as Schedule<T>[];
1194 | 
1195 |     return result;
1196 |   }
1197 | 
1198 |   /**
1199 |    * Cancel a scheduled task
1200 |    * @param id ID of the task to cancel
1201 |    * @returns true if the task was cancelled, false otherwise
1202 |    */
1203 |   async cancelSchedule(id: string): Promise<boolean> {
1204 |     const schedule = await this.getSchedule(id);
1205 |     if (schedule) {
1206 |       this.observability?.emit(
1207 |         {
1208 |           displayMessage: `Schedule ${id} cancelled`,
1209 |           id: nanoid(),
1210 |           payload: schedule,
1211 |           timestamp: Date.now(),
1212 |           type: "schedule:cancel"
1213 |         },
1214 |         this.ctx
1215 |       );
1216 |     }
1217 |     this.sql`DELETE FROM cf_agents_schedules WHERE id = ${id}`;
1218 | 
1219 |     await this._scheduleNextAlarm();
1220 |     return true;
1221 |   }
1222 | 
1223 |   private async _scheduleNextAlarm() {
1224 |     // Find the next schedule that needs to be executed
1225 |     const result = this.sql`
1226 |       SELECT time FROM cf_agents_schedules
1227 |       WHERE time > ${Math.floor(Date.now() / 1000)}
1228 |       ORDER BY time ASC
1229 |       LIMIT 1
1230 |     `;
1231 |     if (!result) return;
1232 | 
1233 |     if (result.length > 0 && "time" in result[0]) {
1234 |       const nextTime = (result[0].time as number) * 1000;
1235 |       await this.ctx.storage.setAlarm(nextTime);
1236 |     }
1237 |   }
1238 | 
1239 |   /**
1240 |    * Method called when an alarm fires.
1241 |    * Executes any scheduled tasks that are due.
1242 |    *
1243 |    * @remarks
1244 |    * To schedule a task, please use the `this.schedule` method instead.
1245 |    * See {@link https://developers.cloudflare.com/agents/api-reference/schedule-tasks/}
1246 |    */
1247 |   public readonly alarm = async () => {
1248 |     const now = Math.floor(Date.now() / 1000);
1249 | 
1250 |     // Get all schedules that should be executed now
1251 |     const result = this.sql<Schedule<string>>`
1252 |       SELECT * FROM cf_agents_schedules WHERE time <= ${now}
1253 |     `;
1254 | 
1255 |     if (result && Array.isArray(result)) {
1256 |       for (const row of result) {
1257 |         const callback = this[row.callback as keyof Agent<Env>];
1258 |         if (!callback) {
1259 |           console.error(`callback ${row.callback} not found`);
1260 |           continue;
1261 |         }
1262 |         await agentContext.run(
1263 |           {
1264 |             agent: this,
1265 |             connection: undefined,
1266 |             request: undefined,
1267 |             email: undefined
1268 |           },
1269 |           async () => {
1270 |             try {
1271 |               this.observability?.emit(
1272 |                 {
1273 |                   displayMessage: `Schedule ${row.id} executed`,
1274 |                   id: nanoid(),
1275 |                   payload: row,
1276 |                   timestamp: Date.now(),
1277 |                   type: "schedule:execute"
1278 |                 },
1279 |                 this.ctx
1280 |               );
1281 | 
1282 |               await (
1283 |                 callback as (
1284 |                   payload: unknown,
1285 |                   schedule: Schedule<unknown>
1286 |                 ) => Promise<void>
1287 |               ).bind(this)(JSON.parse(row.payload as string), row);
1288 |             } catch (e) {
1289 |               console.error(`error executing callback "${row.callback}"`, e);
1290 |             }
1291 |           }
1292 |         );
1293 |         if (row.type === "cron") {
1294 |           // Update next execution time for cron schedules
1295 |           const nextExecutionTime = getNextCronTime(row.cron);
1296 |           const nextTimestamp = Math.floor(nextExecutionTime.getTime() / 1000);
1297 | 
1298 |           this.sql`
1299 |           UPDATE cf_agents_schedules SET time = ${nextTimestamp} WHERE id = ${row.id}
1300 |         `;
1301 |         } else {
1302 |           // Delete one-time schedules after execution
1303 |           this.sql`
1304 |           DELETE FROM cf_agents_schedules WHERE id = ${row.id}
1305 |         `;
1306 |         }
1307 |       }
1308 |     }
1309 | 
1310 |     // Schedule the next alarm
1311 |     await this._scheduleNextAlarm();
1312 |   };
1313 | 
1314 |   /**
1315 |    * Destroy the Agent, removing all state and scheduled tasks
1316 |    */
1317 |   async destroy() {
1318 |     // drop all tables
1319 |     this.sql`DROP TABLE IF EXISTS cf_agents_state`;
1320 |     this.sql`DROP TABLE IF EXISTS cf_agents_schedules`;
1321 |     this.sql`DROP TABLE IF EXISTS cf_agents_mcp_servers`;
1322 |     this.sql`DROP TABLE IF EXISTS cf_agents_queues`;
1323 | 
1324 |     // delete all alarms
1325 |     await this.ctx.storage.deleteAlarm();
1326 |     await this.ctx.storage.deleteAll();
1327 |     this.ctx.abort("destroyed"); // enforce that the agent is evicted
1328 | 
1329 |     this.observability?.emit(
1330 |       {
1331 |         displayMessage: "Agent destroyed",
1332 |         id: nanoid(),
1333 |         payload: {},
1334 |         timestamp: Date.now(),
1335 |         type: "destroy"
1336 |       },
1337 |       this.ctx
1338 |     );
1339 |   }
1340 | 
1341 |   /**
1342 |    * Get all methods marked as callable on this Agent
1343 |    * @returns A map of method names to their metadata
1344 |    */
1345 |   private _isCallable(method: string): boolean {
1346 |     return callableMetadata.has(this[method as keyof this] as Function);
1347 |   }
1348 | 
1349 |   /**
1350 |    * Connect to a new MCP Server
1351 |    *
1352 |    * @param url MCP Server SSE URL
1353 |    * @param callbackHost Base host for the agent, used for the redirect URI.
1354 |    * @param agentsPrefix agents routing prefix if not using `agents`
1355 |    * @param options MCP client and transport (header) options
1356 |    * @returns authUrl
1357 |    */
1358 |   async addMcpServer(
1359 |     serverName: string,
1360 |     url: string,
1361 |     callbackHost: string,
1362 |     agentsPrefix = "agents",
1363 |     options?: {
1364 |       client?: ConstructorParameters<typeof Client>[1];
1365 |       transport?: {
1366 |         headers: HeadersInit;
1367 |       };
1368 |     }
1369 |   ): Promise<{ id: string; authUrl: string | undefined }> {
1370 |     const callbackUrl = `${callbackHost}/${agentsPrefix}/${camelCaseToKebabCase(this._ParentClass.name)}/${this.name}/callback`;
1371 | 
1372 |     const result = await this._connectToMcpServerInternal(
1373 |       serverName,
1374 |       url,
1375 |       callbackUrl,
1376 |       options
1377 |     );
1378 |     this.sql`
1379 |         INSERT
1380 |         OR REPLACE INTO cf_agents_mcp_servers (id, name, server_url, client_id, auth_url, callback_url, server_options)
1381 |       VALUES (
1382 |         ${result.id},
1383 |         ${serverName},
1384 |         ${url},
1385 |         ${result.clientId ?? null},
1386 |         ${result.authUrl ?? null},
1387 |         ${callbackUrl},
1388 |         ${options ? JSON.stringify(options) : null}
1389 |         );
1390 |     `;
1391 | 
1392 |     this.broadcast(
1393 |       JSON.stringify({
1394 |         mcp: this.getMcpServers(),
1395 |         type: "cf_agent_mcp_servers"
1396 |       })
1397 |     );
1398 | 
1399 |     return result;
1400 |   }
1401 | 
1402 |   async _connectToMcpServerInternal(
1403 |     _serverName: string,
1404 |     url: string,
1405 |     callbackUrl: string,
1406 |     // it's important that any options here are serializable because we put them into our sqlite DB for reconnection purposes
1407 |     options?: {
1408 |       client?: ConstructorParameters<typeof Client>[1];
1409 |       /**
1410 |        * We don't expose the normal set of transport options because:
1411 |        * 1) we can't serialize things like the auth provider or a fetch function into the DB for reconnection purposes
1412 |        * 2) We probably want these options to be agnostic to the transport type (SSE vs Streamable)
1413 |        *
1414 |        * This has the limitation that you can't override fetch, but I think headers should handle nearly all cases needed (i.e. non-standard bearer auth).
1415 |        */
1416 |       transport?: {
1417 |         headers?: HeadersInit;
1418 |       };
1419 |     },
1420 |     reconnect?: {
1421 |       id: string;
1422 |       oauthClientId?: string;
1423 |     }
1424 |   ): Promise<{
1425 |     id: string;
1426 |     authUrl: string | undefined;
1427 |     clientId: string | undefined;
1428 |   }> {
1429 |     const authProvider = new DurableObjectOAuthClientProvider(
1430 |       this.ctx.storage,
1431 |       this.name,
1432 |       callbackUrl
1433 |     );
1434 | 
1435 |     if (reconnect) {
1436 |       authProvider.serverId = reconnect.id;
1437 |       if (reconnect.oauthClientId) {
1438 |         authProvider.clientId = reconnect.oauthClientId;
1439 |       }
1440 |     }
1441 | 
1442 |     // allows passing through transport headers if necessary
1443 |     // this handles some non-standard bearer auth setups (i.e. MCP server behind CF access instead of OAuth)
1444 |     let headerTransportOpts: SSEClientTransportOptions = {};
1445 |     if (options?.transport?.headers) {
1446 |       headerTransportOpts = {
1447 |         eventSourceInit: {
1448 |           fetch: (url, init) =>
1449 |             fetch(url, {
1450 |               ...init,
1451 |               headers: options?.transport?.headers
1452 |             })
1453 |         },
1454 |         requestInit: {
1455 |           headers: options?.transport?.headers
1456 |         }
1457 |       };
1458 |     }
1459 | 
1460 |     const { id, authUrl, clientId } = await this.mcp.connect(url, {
1461 |       client: options?.client,
1462 |       reconnect,
1463 |       transport: {
1464 |         ...headerTransportOpts,
1465 |         authProvider
1466 |       }
1467 |     });
1468 | 
1469 |     return {
1470 |       authUrl,
1471 |       clientId,
1472 |       id
1473 |     };
1474 |   }
1475 | 
1476 |   async removeMcpServer(id: string) {
1477 |     this.mcp.closeConnection(id);
1478 |     this.sql`
1479 |       DELETE FROM cf_agents_mcp_servers WHERE id = ${id};
1480 |     `;
1481 |     this.broadcast(
1482 |       JSON.stringify({
1483 |         mcp: this.getMcpServers(),
1484 |         type: "cf_agent_mcp_servers"
1485 |       })
1486 |     );
1487 |   }
1488 | 
1489 |   getMcpServers(): MCPServersState {
1490 |     const mcpState: MCPServersState = {
1491 |       prompts: this.mcp.listPrompts(),
1492 |       resources: this.mcp.listResources(),
1493 |       servers: {},
1494 |       tools: this.mcp.listTools()
1495 |     };
1496 | 
1497 |     const servers = this.sql<MCPServerRow>`
1498 |       SELECT id, name, server_url, client_id, auth_url, callback_url, server_options FROM cf_agents_mcp_servers;
1499 |     `;
1500 | 
1501 |     if (servers && Array.isArray(servers) && servers.length > 0) {
1502 |       for (const server of servers) {
1503 |         const serverConn = this.mcp.mcpConnections[server.id];
1504 |         mcpState.servers[server.id] = {
1505 |           auth_url: server.auth_url,
1506 |           capabilities: serverConn?.serverCapabilities ?? null,
1507 |           instructions: serverConn?.instructions ?? null,
1508 |           name: server.name,
1509 |           server_url: server.server_url,
1510 |           // mark as "authenticating" because the server isn't automatically connected, so it's pending authenticating
1511 |           state: serverConn?.connectionState ?? "authenticating"
1512 |         };
1513 |       }
1514 |     }
1515 | 
1516 |     return mcpState;
1517 |   }
1518 | }
1519 | 
1520 | /**
1521 |  * Namespace for creating Agent instances
1522 |  * @template Agentic Type of the Agent class
1523 |  */
1524 | export type AgentNamespace<Agentic extends Agent<unknown>> =
1525 |   DurableObjectNamespace<Agentic>;
1526 | 
1527 | /**
1528 |  * Agent's durable context
1529 |  */
1530 | export type AgentContext = DurableObjectState;
1531 | 
1532 | /**
1533 |  * Configuration options for Agent routing
1534 |  */
1535 | export type AgentOptions<Env> = PartyServerOptions<Env> & {
1536 |   /**
1537 |    * Whether to enable CORS for the Agent
1538 |    */
1539 |   cors?: boolean | HeadersInit | undefined;
1540 | };
1541 | 
1542 | /**
1543 |  * Route a request to the appropriate Agent
1544 |  * @param request Request to route
1545 |  * @param env Environment containing Agent bindings
1546 |  * @param options Routing options
1547 |  * @returns Response from the Agent or undefined if no route matched
1548 |  */
1549 | export async function routeAgentRequest<Env>(
1550 |   request: Request,
1551 |   env: Env,
1552 |   options?: AgentOptions<Env>
1553 | ) {
1554 |   const corsHeaders =
1555 |     options?.cors === true
1556 |       ? {
1557 |           "Access-Control-Allow-Credentials": "true",
1558 |           "Access-Control-Allow-Methods": "GET, POST, HEAD, OPTIONS",
1559 |           "Access-Control-Allow-Origin": "*",
1560 |           "Access-Control-Max-Age": "86400"
1561 |         }
1562 |       : options?.cors;
1563 | 
1564 |   if (request.method === "OPTIONS") {
1565 |     if (corsHeaders) {
1566 |       return new Response(null, {
1567 |         headers: corsHeaders
1568 |       });
1569 |     }
1570 |     console.warn(
1571 |       "Received an OPTIONS request, but cors was not enabled. Pass `cors: true` or `cors: { ...custom cors headers }` to routeAgentRequest to enable CORS."
1572 |     );
1573 |   }
1574 | 
1575 |   let response = await routePartykitRequest(
1576 |     request,
1577 |     env as Record<string, unknown>,
1578 |     {
1579 |       prefix: "agents",
1580 |       ...(options as PartyServerOptions<Record<string, unknown>>)
1581 |     }
1582 |   );
1583 | 
1584 |   if (
1585 |     response &&
1586 |     corsHeaders &&
1587 |     request.headers.get("upgrade")?.toLowerCase() !== "websocket" &&
1588 |     request.headers.get("Upgrade")?.toLowerCase() !== "websocket"
1589 |   ) {
1590 |     response = new Response(response.body, {
1591 |       headers: {
1592 |         ...response.headers,
1593 |         ...corsHeaders
1594 |       }
1595 |     });
1596 |   }
1597 |   return response;
1598 | }
1599 | 
1600 | export type EmailResolver<Env> = (
1601 |   email: ForwardableEmailMessage,
1602 |   env: Env
1603 | ) => Promise<{
1604 |   agentName: string;
1605 |   agentId: string;
1606 | } | null>;
1607 | 
1608 | /**
1609 |  * Create a resolver that uses the message-id header to determine the agent to route the email to
1610 |  * @returns A function that resolves the agent to route the email to
1611 |  */
1612 | export function createHeaderBasedEmailResolver<Env>(): EmailResolver<Env> {
1613 |   return async (email: ForwardableEmailMessage, _env: Env) => {
1614 |     const messageId = email.headers.get("message-id");
1615 |     if (messageId) {
1616 |       const messageIdMatch = messageId.match(/<([^@]+)@([^>]+)>/);
1617 |       if (messageIdMatch) {
1618 |         const [, agentId, domain] = messageIdMatch;
1619 |         const agentName = domain.split(".")[0];
1620 |         return { agentName, agentId };
1621 |       }
1622 |     }
1623 | 
1624 |     const references = email.headers.get("references");
1625 |     if (references) {
1626 |       const referencesMatch = references.match(
1627 |         /<([A-Za-z0-9+/]{43}=)@([^>]+)>/
1628 |       );
1629 |       if (referencesMatch) {
1630 |         const [, base64Id, domain] = referencesMatch;
1631 |         const agentId = Buffer.from(base64Id, "base64").toString("hex");
1632 |         const agentName = domain.split(".")[0];
1633 |         return { agentName, agentId };
1634 |       }
1635 |     }
1636 | 
1637 |     const agentName = email.headers.get("x-agent-name");
1638 |     const agentId = email.headers.get("x-agent-id");
1639 |     if (agentName && agentId) {
1640 |       return { agentName, agentId };
1641 |     }
1642 | 
1643 |     return null;
1644 |   };
1645 | }
1646 | 
1647 | /**
1648 |  * Create a resolver that uses the email address to determine the agent to route the email to
1649 |  * @param defaultAgentName The default agent name to use if the email address does not contain a sub-address
1650 |  * @returns A function that resolves the agent to route the email to
1651 |  */
1652 | export function createAddressBasedEmailResolver<Env>(
1653 |   defaultAgentName: string
1654 | ): EmailResolver<Env> {
1655 |   return async (email: ForwardableEmailMessage, _env: Env) => {
1656 |     const emailMatch = email.to.match(/^([^+@]+)(?:\+([^@]+))?@(.+)$/);
1657 |     if (!emailMatch) {
1658 |       return null;
1659 |     }
1660 | 
1661 |     const [, localPart, subAddress] = emailMatch;
1662 | 
1663 |     if (subAddress) {
1664 |       return {
1665 |         agentName: localPart,
1666 |         agentId: subAddress
1667 |       };
1668 |     }
1669 | 
1670 |     // Option 2: Use defaultAgentName namespace, localPart as agentId
1671 |     // Common for catch-all email routing to a single EmailAgent namespace
1672 |     return {
1673 |       agentName: defaultAgentName,
1674 |       agentId: localPart
1675 |     };
1676 |   };
1677 | }
1678 | 
1679 | /**
1680 |  * Create a resolver that uses the agentName and agentId to determine the agent to route the email to
1681 |  * @param agentName The name of the agent to route the email to
1682 |  * @param agentId The id of the agent to route the email to
1683 |  * @returns A function that resolves the agent to route the email to
1684 |  */
1685 | export function createCatchAllEmailResolver<Env>(
1686 |   agentName: string,
1687 |   agentId: string
1688 | ): EmailResolver<Env> {
1689 |   return async () => ({ agentName, agentId });
1690 | }
1691 | 
1692 | export type EmailRoutingOptions<Env> = AgentOptions<Env> & {
1693 |   resolver: EmailResolver<Env>;
1694 | };
1695 | 
1696 | // Cache the agent namespace map for email routing
1697 | // This maps both kebab-case and original names to namespaces
1698 | const agentMapCache = new WeakMap<
1699 |   Record<string, unknown>,
1700 |   Record<string, unknown>
1701 | >();
1702 | 
1703 | /**
1704 |  * Route an email to the appropriate Agent
1705 |  * @param email The email to route
1706 |  * @param env The environment containing the Agent bindings
1707 |  * @param options The options for routing the email
1708 |  * @returns A promise that resolves when the email has been routed
1709 |  */
1710 | export async function routeAgentEmail<Env>(
1711 |   email: ForwardableEmailMessage,
1712 |   env: Env,
1713 |   options: EmailRoutingOptions<Env>
1714 | ): Promise<void> {
1715 |   const routingInfo = await options.resolver(email, env);
1716 | 
1717 |   if (!routingInfo) {
1718 |     console.warn("No routing information found for email, dropping message");
1719 |     return;
1720 |   }
1721 | 
1722 |   // Build a map that includes both original names and kebab-case versions
1723 |   if (!agentMapCache.has(env as Record<string, unknown>)) {
1724 |     const map: Record<string, unknown> = {};
1725 |     for (const [key, value] of Object.entries(env as Record<string, unknown>)) {
1726 |       if (
1727 |         value &&
1728 |         typeof value === "object" &&
1729 |         "idFromName" in value &&
1730 |         typeof value.idFromName === "function"
1731 |       ) {
1732 |         // Add both the original name and kebab-case version
1733 |         map[key] = value;
1734 |         map[camelCaseToKebabCase(key)] = value;
1735 |       }
1736 |     }
1737 |     agentMapCache.set(env as Record<string, unknown>, map);
1738 |   }
1739 | 
1740 |   const agentMap = agentMapCache.get(env as Record<string, unknown>)!;
1741 |   const namespace = agentMap[routingInfo.agentName];
1742 | 
1743 |   if (!namespace) {
1744 |     // Provide helpful error message listing available agents
1745 |     const availableAgents = Object.keys(agentMap)
1746 |       .filter((key) => !key.includes("-")) // Show only original names, not kebab-case duplicates
1747 |       .join(", ");
1748 |     throw new Error(
1749 |       `Agent namespace '${routingInfo.agentName}' not found in environment. Available agents: ${availableAgents}`
1750 |     );
1751 |   }
1752 | 
1753 |   const agent = await getAgentByName(
1754 |     namespace as unknown as AgentNamespace<Agent<Env>>,
1755 |     routingInfo.agentId
1756 |   );
1757 | 
1758 |   // let's make a serialisable version of the email
1759 |   const serialisableEmail: AgentEmail = {
1760 |     getRaw: async () => {
1761 |       const reader = email.raw.getReader();
1762 |       const chunks: Uint8Array[] = [];
1763 | 
1764 |       let done = false;
1765 |       while (!done) {
1766 |         const { value, done: readerDone } = await reader.read();
1767 |         done = readerDone;
1768 |         if (value) {
1769 |           chunks.push(value);
1770 |         }
1771 |       }
1772 | 
1773 |       const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
1774 |       const combined = new Uint8Array(totalLength);
1775 |       let offset = 0;
1776 |       for (const chunk of chunks) {
1777 |         combined.set(chunk, offset);
1778 |         offset += chunk.length;
1779 |       }
1780 | 
1781 |       return combined;
1782 |     },
1783 |     headers: email.headers,
1784 |     rawSize: email.rawSize,
1785 |     setReject: (reason: string) => {
1786 |       email.setReject(reason);
1787 |     },
1788 |     forward: (rcptTo: string, headers?: Headers) => {
1789 |       return email.forward(rcptTo, headers);
1790 |     },
1791 |     reply: (options: { from: string; to: string; raw: string }) => {
1792 |       return email.reply(
1793 |         new EmailMessage(options.from, options.to, options.raw)
1794 |       );
1795 |     },
1796 |     from: email.from,
1797 |     to: email.to
1798 |   };
1799 | 
1800 |   await agent._onEmail(serialisableEmail);
1801 | }
1802 | 
1803 | export type AgentEmail = {
1804 |   from: string;
1805 |   to: string;
1806 |   getRaw: () => Promise<Uint8Array>;
1807 |   headers: Headers;
1808 |   rawSize: number;
1809 |   setReject: (reason: string) => void;
1810 |   forward: (rcptTo: string, headers?: Headers) => Promise<void>;
1811 |   reply: (options: { from: string; to: string; raw: string }) => Promise<void>;
1812 | };
1813 | 
1814 | export type EmailSendOptions = {
1815 |   to: string;
1816 |   subject: string;
1817 |   body: string;
1818 |   contentType?: string;
1819 |   headers?: Record<string, string>;
1820 |   includeRoutingHeaders?: boolean;
1821 |   agentName?: string;
1822 |   agentId?: string;
1823 |   domain?: string;
1824 | };
1825 | 
1826 | /**
1827 |  * Get or create an Agent by name
1828 |  * @template Env Environment type containing bindings
1829 |  * @template T Type of the Agent class
1830 |  * @param namespace Agent namespace
1831 |  * @param name Name of the Agent instance
1832 |  * @param options Options for Agent creation
1833 |  * @returns Promise resolving to an Agent instance stub
1834 |  */
1835 | export async function getAgentByName<Env, T extends Agent<Env>>(
1836 |   namespace: AgentNamespace<T>,
1837 |   name: string,
1838 |   options?: {
1839 |     jurisdiction?: DurableObjectJurisdiction;
1840 |     locationHint?: DurableObjectLocationHint;
1841 |   }
1842 | ) {
1843 |   return getServerByName<Env, T>(namespace, name, options);
1844 | }
1845 | 
1846 | /**
1847 |  * A wrapper for streaming responses in callable methods
1848 |  */
1849 | export class StreamingResponse {
1850 |   private _connection: Connection;
1851 |   private _id: string;
1852 |   private _closed = false;
1853 | 
1854 |   constructor(connection: Connection, id: string) {
1855 |     this._connection = connection;
1856 |     this._id = id;
1857 |   }
1858 | 
1859 |   /**
1860 |    * Send a chunk of data to the client
1861 |    * @param chunk The data to send
1862 |    */
1863 |   send(chunk: unknown) {
1864 |     if (this._closed) {
1865 |       throw new Error("StreamingResponse is already closed");
1866 |     }
1867 |     const response: RPCResponse = {
1868 |       done: false,
1869 |       id: this._id,
1870 |       result: chunk,
1871 |       success: true,
1872 |       type: "rpc"
1873 |     };
1874 |     this._connection.send(JSON.stringify(response));
1875 |   }
1876 | 
1877 |   /**
1878 |    * End the stream and send the final chunk (if any)
1879 |    * @param finalChunk Optional final chunk of data to send
1880 |    */
1881 |   end(finalChunk?: unknown) {
1882 |     if (this._closed) {
1883 |       throw new Error("StreamingResponse is already closed");
1884 |     }
1885 |     this._closed = true;
1886 |     const response: RPCResponse = {
1887 |       done: true,
1888 |       id: this._id,
1889 |       result: finalChunk,
1890 |       success: true,
1891 |       type: "rpc"
1892 |     };
1893 |     this._connection.send(JSON.stringify(response));
1894 |   }
1895 | }
1896 | 


--------------------------------------------------------------------------------
/packages/agents/src/mcp/client-connection.ts:
--------------------------------------------------------------------------------
  1 | import { Client } from "@modelcontextprotocol/sdk/client/index.js";
  2 | import type { SSEClientTransportOptions } from "@modelcontextprotocol/sdk/client/sse.js";
  3 | import type { StreamableHTTPClientTransportOptions } from "@modelcontextprotocol/sdk/client/streamableHttp.js";
  4 | import {
  5 |   // type ClientCapabilities,
  6 |   type ListPromptsResult,
  7 |   type ListResourceTemplatesResult,
  8 |   type ListResourcesResult,
  9 |   type ListToolsResult,
 10 |   // type Notification,
 11 |   type Prompt,
 12 |   PromptListChangedNotificationSchema,
 13 |   type Resource,
 14 |   ResourceListChangedNotificationSchema,
 15 |   type ResourceTemplate,
 16 |   type ServerCapabilities,
 17 |   type Tool,
 18 |   ToolListChangedNotificationSchema
 19 | } from "@modelcontextprotocol/sdk/types.js";
 20 | import type { AgentsOAuthProvider } from "./do-oauth-client-provider";
 21 | import { SSEEdgeClientTransport } from "./sse-edge";
 22 | import { StreamableHTTPEdgeClientTransport } from "./streamable-http-edge";
 23 | 
 24 | export type MCPTransportOptions = (
 25 |   | SSEClientTransportOptions
 26 |   | StreamableHTTPClientTransportOptions
 27 | ) & {
 28 |   authProvider?: AgentsOAuthProvider;
 29 |   type?: "sse" | "streamable-http";
 30 | };
 31 | 
 32 | export class MCPClientConnection {
 33 |   client: Client;
 34 |   connectionState:
 35 |     | "authenticating"
 36 |     | "connecting"
 37 |     | "ready"
 38 |     | "discovering"
 39 |     | "failed" = "connecting";
 40 |   instructions?: string;
 41 |   tools: Tool[] = [];
 42 |   prompts: Prompt[] = [];
 43 |   resources: Resource[] = [];
 44 |   resourceTemplates: ResourceTemplate[] = [];
 45 |   serverCapabilities: ServerCapabilities | undefined;
 46 | 
 47 |   constructor(
 48 |     public url: URL,
 49 |     info: ConstructorParameters<typeof Client>[0],
 50 |     public options: {
 51 |       transport: MCPTransportOptions;
 52 |       client: ConstructorParameters<typeof Client>[1];
 53 |     } = { client: {}, transport: {} }
 54 |   ) {
 55 |     this.client = new Client(info, options.client);
 56 |   }
 57 | 
 58 |   /**
 59 |    * Initialize a client connection
 60 |    *
 61 |    * @param code Optional OAuth code to initialize the connection with if auth hasn't been initialized
 62 |    * @returns
 63 |    */
 64 |   async init(code?: string) {
 65 |     try {
 66 |       const transportType = this.options.transport.type || "streamable-http";
 67 |       const transport =
 68 |         transportType === "streamable-http"
 69 |           ? new StreamableHTTPEdgeClientTransport(
 70 |               this.url,
 71 |               this.options.transport as StreamableHTTPClientTransportOptions
 72 |             )
 73 |           : new SSEEdgeClientTransport(
 74 |               this.url,
 75 |               this.options.transport as SSEClientTransportOptions
 76 |             );
 77 | 
 78 |       if (code) {
 79 |         await transport.finishAuth(code);
 80 |       }
 81 | 
 82 |       await this.client.connect(transport);
 83 |       // biome-ignore lint/suspicious/noExplicitAny: allow for the error check here
 84 |     } catch (e: any) {
 85 |       if (e.toString().includes("Unauthorized")) {
 86 |         // unauthorized, we should wait for the user to authenticate
 87 |         this.connectionState = "authenticating";
 88 |         return;
 89 |       }
 90 |       this.connectionState = "failed";
 91 |       throw e;
 92 |     }
 93 | 
 94 |     this.connectionState = "discovering";
 95 | 
 96 |     this.serverCapabilities = await this.client.getServerCapabilities();
 97 |     if (!this.serverCapabilities) {
 98 |       throw new Error("The MCP Server failed to return server capabilities");
 99 |     }
100 | 
101 |     const [instructions, tools, resources, prompts, resourceTemplates] =
102 |       await Promise.all([
103 |         this.client.getInstructions(),
104 |         this.registerTools(),
105 |         this.registerResources(),
106 |         this.registerPrompts(),
107 |         this.registerResourceTemplates()
108 |       ]);
109 | 
110 |     this.instructions = instructions;
111 |     this.tools = tools;
112 |     this.resources = resources;
113 |     this.prompts = prompts;
114 |     this.resourceTemplates = resourceTemplates;
115 | 
116 |     this.connectionState = "ready";
117 |   }
118 | 
119 |   /**
120 |    * Notification handler registration
121 |    */
122 |   async registerTools(): Promise<Tool[]> {
123 |     if (!this.serverCapabilities || !this.serverCapabilities.tools) {
124 |       return [];
125 |     }
126 | 
127 |     if (this.serverCapabilities.tools.listChanged) {
128 |       this.client.setNotificationHandler(
129 |         ToolListChangedNotificationSchema,
130 |         async (_notification) => {
131 |           this.tools = await this.fetchTools();
132 |         }
133 |       );
134 |     }
135 | 
136 |     return this.fetchTools();
137 |   }
138 | 
139 |   async registerResources(): Promise<Resource[]> {
140 |     if (!this.serverCapabilities || !this.serverCapabilities.resources) {
141 |       return [];
142 |     }
143 | 
144 |     if (this.serverCapabilities.resources.listChanged) {
145 |       this.client.setNotificationHandler(
146 |         ResourceListChangedNotificationSchema,
147 |         async (_notification) => {
148 |           this.resources = await this.fetchResources();
149 |         }
150 |       );
151 |     }
152 | 
153 |     return this.fetchResources();
154 |   }
155 | 
156 |   async registerPrompts(): Promise<Prompt[]> {
157 |     if (!this.serverCapabilities || !this.serverCapabilities.prompts) {
158 |       return [];
159 |     }
160 | 
161 |     if (this.serverCapabilities.prompts.listChanged) {
162 |       this.client.setNotificationHandler(
163 |         PromptListChangedNotificationSchema,
164 |         async (_notification) => {
165 |           this.prompts = await this.fetchPrompts();
166 |         }
167 |       );
168 |     }
169 | 
170 |     return this.fetchPrompts();
171 |   }
172 | 
173 |   async registerResourceTemplates(): Promise<ResourceTemplate[]> {
174 |     if (!this.serverCapabilities || !this.serverCapabilities.resources) {
175 |       return [];
176 |     }
177 | 
178 |     return this.fetchResourceTemplates();
179 |   }
180 | 
181 |   async fetchTools() {
182 |     let toolsAgg: Tool[] = [];
183 |     let toolsResult: ListToolsResult = { tools: [] };
184 |     do {
185 |       toolsResult = await this.client
186 |         .listTools({
187 |           cursor: toolsResult.nextCursor
188 |         })
189 |         .catch(capabilityErrorHandler({ tools: [] }, "tools/list"));
190 |       toolsAgg = toolsAgg.concat(toolsResult.tools);
191 |     } while (toolsResult.nextCursor);
192 |     return toolsAgg;
193 |   }
194 | 
195 |   async fetchResources() {
196 |     let resourcesAgg: Resource[] = [];
197 |     let resourcesResult: ListResourcesResult = { resources: [] };
198 |     do {
199 |       resourcesResult = await this.client
200 |         .listResources({
201 |           cursor: resourcesResult.nextCursor
202 |         })
203 |         .catch(capabilityErrorHandler({ resources: [] }, "resources/list"));
204 |       resourcesAgg = resourcesAgg.concat(resourcesResult.resources);
205 |     } while (resourcesResult.nextCursor);
206 |     return resourcesAgg;
207 |   }
208 | 
209 |   async fetchPrompts() {
210 |     let promptsAgg: Prompt[] = [];
211 |     let promptsResult: ListPromptsResult = { prompts: [] };
212 |     do {
213 |       promptsResult = await this.client
214 |         .listPrompts({
215 |           cursor: promptsResult.nextCursor
216 |         })
217 |         .catch(capabilityErrorHandler({ prompts: [] }, "prompts/list"));
218 |       promptsAgg = promptsAgg.concat(promptsResult.prompts);
219 |     } while (promptsResult.nextCursor);
220 |     return promptsAgg;
221 |   }
222 | 
223 |   async fetchResourceTemplates() {
224 |     let templatesAgg: ResourceTemplate[] = [];
225 |     let templatesResult: ListResourceTemplatesResult = {
226 |       resourceTemplates: []
227 |     };
228 |     do {
229 |       templatesResult = await this.client
230 |         .listResourceTemplates({
231 |           cursor: templatesResult.nextCursor
232 |         })
233 |         .catch(
234 |           capabilityErrorHandler(
235 |             { resourceTemplates: [] },
236 |             "resources/templates/list"
237 |           )
238 |         );
239 |       templatesAgg = templatesAgg.concat(templatesResult.resourceTemplates);
240 |     } while (templatesResult.nextCursor);
241 |     return templatesAgg;
242 |   }
243 | }
244 | 
245 | function capabilityErrorHandler<T>(empty: T, method: string) {
246 |   return (e: { code: number }) => {
247 |     // server is badly behaved and returning invalid capabilities. This commonly occurs for resource templates
248 |     if (e.code === -32601) {
249 |       console.error(
250 |         `The server advertised support for the capability ${method.split("/")[0]}, but returned "Method not found" for '${method}'.`
251 |       );
252 |       return empty;
253 |     }
254 |     throw e;
255 |   };
256 | }
257 | 


--------------------------------------------------------------------------------
/packages/agents/src/mcp/client.ts:
--------------------------------------------------------------------------------
  1 | import type { Client } from "@modelcontextprotocol/sdk/client/index.js";
  2 | import type { RequestOptions } from "@modelcontextprotocol/sdk/shared/protocol.js";
  3 | import type {
  4 |   CallToolRequest,
  5 |   CallToolResultSchema,
  6 |   CompatibilityCallToolResultSchema,
  7 |   GetPromptRequest,
  8 |   Prompt,
  9 |   ReadResourceRequest,
 10 |   Resource,
 11 |   ResourceTemplate,
 12 |   Tool
 13 | } from "@modelcontextprotocol/sdk/types.js";
 14 | import { type ToolSet, jsonSchema } from "ai";
 15 | import { nanoid } from "nanoid";
 16 | import {
 17 |   MCPClientConnection,
 18 |   type MCPTransportOptions
 19 | } from "./client-connection";
 20 | 
 21 | /**
 22 |  * Utility class that aggregates multiple MCP clients into one
 23 |  */
 24 | export class MCPClientManager {
 25 |   public mcpConnections: Record<string, MCPClientConnection> = {};
 26 |   private _callbackUrls: string[] = [];
 27 | 
 28 |   /**
 29 |    * @param _name Name of the MCP client
 30 |    * @param _version Version of the MCP Client
 31 |    * @param auth Auth paramters if being used to create a DurableObjectOAuthClientProvider
 32 |    */
 33 |   constructor(
 34 |     private _name: string,
 35 |     private _version: string
 36 |   ) {}
 37 | 
 38 |   /**
 39 |    * Connect to and register an MCP server
 40 |    *
 41 |    * @param transportConfig Transport config
 42 |    * @param clientConfig Client config
 43 |    * @param capabilities Client capabilities (i.e. if the client supports roots/sampling)
 44 |    */
 45 |   async connect(
 46 |     url: string,
 47 |     options: {
 48 |       // Allows you to reconnect to a server (in the case of an auth reconnect)
 49 |       reconnect?: {
 50 |         // server id
 51 |         id: string;
 52 |         oauthClientId?: string;
 53 |         oauthCode?: string;
 54 |       };
 55 |       // we're overriding authProvider here because we want to be able to access the auth URL
 56 |       transport?: MCPTransportOptions;
 57 |       client?: ConstructorParameters<typeof Client>[1];
 58 |     } = {}
 59 |   ): Promise<{
 60 |     id: string;
 61 |     authUrl?: string;
 62 |     clientId?: string;
 63 |   }> {
 64 |     const id = options.reconnect?.id ?? nanoid(8);
 65 | 
 66 |     if (!options.transport?.authProvider) {
 67 |       console.warn(
 68 |         "No authProvider provided in the transport options. This client will only support unauthenticated remote MCP Servers"
 69 |       );
 70 |     } else {
 71 |       options.transport.authProvider.serverId = id;
 72 |       // reconnect with auth
 73 |       if (options.reconnect?.oauthClientId) {
 74 |         options.transport.authProvider.clientId =
 75 |           options.reconnect?.oauthClientId;
 76 |       }
 77 |     }
 78 | 
 79 |     this.mcpConnections[id] = new MCPClientConnection(
 80 |       new URL(url),
 81 |       {
 82 |         name: this._name,
 83 |         version: this._version
 84 |       },
 85 |       {
 86 |         client: options.client ?? {},
 87 |         transport: options.transport ?? {}
 88 |       }
 89 |     );
 90 | 
 91 |     await this.mcpConnections[id].init(options.reconnect?.oauthCode);
 92 | 
 93 |     const authUrl = options.transport?.authProvider?.authUrl;
 94 |     if (authUrl && options.transport?.authProvider?.redirectUrl) {
 95 |       this._callbackUrls.push(
 96 |         options.transport.authProvider.redirectUrl.toString()
 97 |       );
 98 |       return {
 99 |         authUrl,
100 |         clientId: options.transport?.authProvider?.clientId,
101 |         id
102 |       };
103 |     }
104 | 
105 |     return {
106 |       id
107 |     };
108 |   }
109 | 
110 |   isCallbackRequest(req: Request): boolean {
111 |     return (
112 |       req.method === "GET" &&
113 |       !!this._callbackUrls.find((url) => {
114 |         return req.url.startsWith(url);
115 |       })
116 |     );
117 |   }
118 | 
119 |   async handleCallbackRequest(req: Request) {
120 |     const url = new URL(req.url);
121 |     const urlMatch = this._callbackUrls.find((url) => {
122 |       return req.url.startsWith(url);
123 |     });
124 |     if (!urlMatch) {
125 |       throw new Error(
126 |         `No callback URI match found for the request url: ${req.url}. Was the request matched with \`isCallbackRequest()\`?`
127 |       );
128 |     }
129 |     const code = url.searchParams.get("code");
130 |     const clientId = url.searchParams.get("state");
131 |     const urlParams = urlMatch.split("/");
132 |     const serverId = urlParams[urlParams.length - 1];
133 |     if (!code) {
134 |       throw new Error("Unauthorized: no code provided");
135 |     }
136 |     if (!clientId) {
137 |       throw new Error("Unauthorized: no state provided");
138 |     }
139 | 
140 |     if (this.mcpConnections[serverId] === undefined) {
141 |       throw new Error(`Could not find serverId: ${serverId}`);
142 |     }
143 | 
144 |     if (this.mcpConnections[serverId].connectionState !== "authenticating") {
145 |       throw new Error(
146 |         "Failed to authenticate: the client isn't in the `authenticating` state"
147 |       );
148 |     }
149 | 
150 |     const conn = this.mcpConnections[serverId];
151 |     if (!conn.options.transport.authProvider) {
152 |       throw new Error(
153 |         "Trying to finalize authentication for a server connection without an authProvider"
154 |       );
155 |     }
156 | 
157 |     conn.options.transport.authProvider.clientId = clientId;
158 |     conn.options.transport.authProvider.serverId = serverId;
159 | 
160 |     // reconnect to server with authorization
161 |     const serverUrl = conn.url.toString();
162 |     await this.connect(serverUrl, {
163 |       reconnect: {
164 |         id: serverId,
165 |         oauthClientId: clientId,
166 |         oauthCode: code
167 |       },
168 |       ...conn.options
169 |     });
170 | 
171 |     if (this.mcpConnections[serverId].connectionState === "authenticating") {
172 |       throw new Error("Failed to authenticate: client failed to initialize");
173 |     }
174 | 
175 |     return { serverId };
176 |   }
177 | 
178 |   /**
179 |    * @returns namespaced list of tools
180 |    */
181 |   listTools(): NamespacedData["tools"] {
182 |     return getNamespacedData(this.mcpConnections, "tools");
183 |   }
184 | 
185 |   /**
186 |    * @returns a set of tools that you can use with the AI SDK
187 |    */
188 |   unstable_getAITools(): ToolSet {
189 |     return Object.fromEntries(
190 |       getNamespacedData(this.mcpConnections, "tools").map((tool) => {
191 |         return [
192 |           `${tool.serverId}_${tool.name}`,
193 |           {
194 |             description: tool.description,
195 |             execute: async (args) => {
196 |               const result = await this.callTool({
197 |                 arguments: args,
198 |                 name: tool.name,
199 |                 serverId: tool.serverId
200 |               });
201 |               if (result.isError) {
202 |                 // @ts-expect-error TODO we should fix this
203 |                 throw new Error(result.content[0].text);
204 |               }
205 |               return result;
206 |             },
207 |             parameters: jsonSchema(tool.inputSchema)
208 |           }
209 |         ];
210 |       })
211 |     );
212 |   }
213 | 
214 |   /**
215 |    * Closes all connections to MCP servers
216 |    */
217 |   async closeAllConnections() {
218 |     return Promise.all(
219 |       Object.values(this.mcpConnections).map(async (connection) => {
220 |         await connection.client.close();
221 |       })
222 |     );
223 |   }
224 | 
225 |   /**
226 |    * Closes a connection to an MCP server
227 |    * @param id The id of the connection to close
228 |    */
229 |   async closeConnection(id: string) {
230 |     if (!this.mcpConnections[id]) {
231 |       throw new Error(`Connection with id "${id}" does not exist.`);
232 |     }
233 |     await this.mcpConnections[id].client.close();
234 |     delete this.mcpConnections[id];
235 |   }
236 | 
237 |   /**
238 |    * @returns namespaced list of prompts
239 |    */
240 |   listPrompts(): NamespacedData["prompts"] {
241 |     return getNamespacedData(this.mcpConnections, "prompts");
242 |   }
243 | 
244 |   /**
245 |    * @returns namespaced list of tools
246 |    */
247 |   listResources(): NamespacedData["resources"] {
248 |     return getNamespacedData(this.mcpConnections, "resources");
249 |   }
250 | 
251 |   /**
252 |    * @returns namespaced list of resource templates
253 |    */
254 |   listResourceTemplates(): NamespacedData["resourceTemplates"] {
255 |     return getNamespacedData(this.mcpConnections, "resourceTemplates");
256 |   }
257 | 
258 |   /**
259 |    * Namespaced version of callTool
260 |    */
261 |   callTool(
262 |     params: CallToolRequest["params"] & { serverId: string },
263 |     resultSchema?:
264 |       | typeof CallToolResultSchema
265 |       | typeof CompatibilityCallToolResultSchema,
266 |     options?: RequestOptions
267 |   ) {
268 |     const unqualifiedName = params.name.replace(`${params.serverId}.`, "");
269 |     return this.mcpConnections[params.serverId].client.callTool(
270 |       {
271 |         ...params,
272 |         name: unqualifiedName
273 |       },
274 |       resultSchema,
275 |       options
276 |     );
277 |   }
278 | 
279 |   /**
280 |    * Namespaced version of readResource
281 |    */
282 |   readResource(
283 |     params: ReadResourceRequest["params"] & { serverId: string },
284 |     options: RequestOptions
285 |   ) {
286 |     return this.mcpConnections[params.serverId].client.readResource(
287 |       params,
288 |       options
289 |     );
290 |   }
291 | 
292 |   /**
293 |    * Namespaced version of getPrompt
294 |    */
295 |   getPrompt(
296 |     params: GetPromptRequest["params"] & { serverId: string },
297 |     options: RequestOptions
298 |   ) {
299 |     return this.mcpConnections[params.serverId].client.getPrompt(
300 |       params,
301 |       options
302 |     );
303 |   }
304 | }
305 | 
306 | type NamespacedData = {
307 |   tools: (Tool & { serverId: string })[];
308 |   prompts: (Prompt & { serverId: string })[];
309 |   resources: (Resource & { serverId: string })[];
310 |   resourceTemplates: (ResourceTemplate & { serverId: string })[];
311 | };
312 | 
313 | export function getNamespacedData<T extends keyof NamespacedData>(
314 |   mcpClients: Record<string, MCPClientConnection>,
315 |   type: T
316 | ): NamespacedData[T] {
317 |   const sets = Object.entries(mcpClients).map(([name, conn]) => {
318 |     return { data: conn[type], name };
319 |   });
320 | 
321 |   const namespacedData = sets.flatMap(({ name: serverId, data }) => {
322 |     return data.map((item) => {
323 |       return {
324 |         ...item,
325 |         // we add a serverId so we can easily pull it out and send the tool call to the right server
326 |         serverId
327 |       };
328 |     });
329 |   });
330 | 
331 |   return namespacedData as NamespacedData[T]; // Type assertion needed due to TS limitations with conditional return types
332 | }
333 | 


--------------------------------------------------------------------------------
/packages/agents/src/mcp/do-oauth-client-provider.ts:
--------------------------------------------------------------------------------
  1 | import type { OAuthClientProvider } from "@modelcontextprotocol/sdk/client/auth.js";
  2 | import type {
  3 |   OAuthClientInformation,
  4 |   OAuthClientInformationFull,
  5 |   OAuthClientMetadata,
  6 |   OAuthTokens
  7 | } from "@modelcontextprotocol/sdk/shared/auth.js";
  8 | 
  9 | // A slight extension to the standard OAuthClientProvider interface because `redirectToAuthorization` doesn't give us the interface we need
 10 | // This allows us to track authentication for a specific server and associated dynamic client registration
 11 | export interface AgentsOAuthProvider extends OAuthClientProvider {
 12 |   authUrl: string | undefined;
 13 |   clientId: string | undefined;
 14 |   serverId: string | undefined;
 15 | }
 16 | 
 17 | export class DurableObjectOAuthClientProvider implements AgentsOAuthProvider {
 18 |   private _authUrl_: string | undefined;
 19 |   private _serverId_: string | undefined;
 20 |   private _clientId_: string | undefined;
 21 | 
 22 |   constructor(
 23 |     public storage: DurableObjectStorage,
 24 |     public clientName: string,
 25 |     public baseRedirectUrl: string
 26 |   ) {}
 27 | 
 28 |   get clientMetadata(): OAuthClientMetadata {
 29 |     return {
 30 |       client_name: this.clientName,
 31 |       client_uri: "example.com",
 32 |       grant_types: ["authorization_code", "refresh_token"],
 33 |       redirect_uris: [this.redirectUrl],
 34 |       response_types: ["code"],
 35 |       token_endpoint_auth_method: "none"
 36 |     };
 37 |   }
 38 | 
 39 |   get redirectUrl() {
 40 |     return `${this.baseRedirectUrl}/${this.serverId}`;
 41 |   }
 42 | 
 43 |   get clientId() {
 44 |     if (!this._clientId_) {
 45 |       throw new Error("Trying to access clientId before it was set");
 46 |     }
 47 |     return this._clientId_;
 48 |   }
 49 | 
 50 |   set clientId(clientId_: string) {
 51 |     this._clientId_ = clientId_;
 52 |   }
 53 | 
 54 |   get serverId() {
 55 |     if (!this._serverId_) {
 56 |       throw new Error("Trying to access serverId before it was set");
 57 |     }
 58 |     return this._serverId_;
 59 |   }
 60 | 
 61 |   set serverId(serverId_: string) {
 62 |     this._serverId_ = serverId_;
 63 |   }
 64 | 
 65 |   keyPrefix(clientId: string) {
 66 |     return `/${this.clientName}/${this.serverId}/${clientId}`;
 67 |   }
 68 | 
 69 |   clientInfoKey(clientId: string) {
 70 |     return `${this.keyPrefix(clientId)}/client_info/`;
 71 |   }
 72 | 
 73 |   async clientInformation(): Promise<OAuthClientInformation | undefined> {
 74 |     if (!this._clientId_) {
 75 |       return undefined;
 76 |     }
 77 |     return (
 78 |       (await this.storage.get<OAuthClientInformation>(
 79 |         this.clientInfoKey(this.clientId)
 80 |       )) ?? undefined
 81 |     );
 82 |   }
 83 | 
 84 |   async saveClientInformation(
 85 |     clientInformation: OAuthClientInformationFull
 86 |   ): Promise<void> {
 87 |     await this.storage.put(
 88 |       this.clientInfoKey(clientInformation.client_id),
 89 |       clientInformation
 90 |     );
 91 |     this.clientId = clientInformation.client_id;
 92 |   }
 93 | 
 94 |   tokenKey(clientId: string) {
 95 |     return `${this.keyPrefix(clientId)}/token`;
 96 |   }
 97 | 
 98 |   async tokens(): Promise<OAuthTokens | undefined> {
 99 |     if (!this._clientId_) {
100 |       return undefined;
101 |     }
102 |     return (
103 |       (await this.storage.get<OAuthTokens>(this.tokenKey(this.clientId))) ??
104 |       undefined
105 |     );
106 |   }
107 | 
108 |   async saveTokens(tokens: OAuthTokens): Promise<void> {
109 |     await this.storage.put(this.tokenKey(this.clientId), tokens);
110 |   }
111 | 
112 |   get authUrl() {
113 |     return this._authUrl_;
114 |   }
115 | 
116 |   /**
117 |    * Because this operates on the server side (but we need browser auth), we send this url back to the user
118 |    * and require user interact to initiate the redirect flow
119 |    */
120 |   async redirectToAuthorization(authUrl: URL): Promise<void> {
121 |     // We want to track the client ID in state here because the typescript SSE client sometimes does
122 |     // a dynamic client registration AFTER generating this redirect URL.
123 |     const client_id = authUrl.searchParams.get("client_id");
124 |     if (client_id) {
125 |       authUrl.searchParams.append("state", client_id);
126 |     }
127 |     this._authUrl_ = authUrl.toString();
128 |   }
129 | 
130 |   codeVerifierKey(clientId: string) {
131 |     return `${this.keyPrefix(clientId)}/code_verifier`;
132 |   }
133 | 
134 |   async saveCodeVerifier(verifier: string): Promise<void> {
135 |     await this.storage.put(this.codeVerifierKey(this.clientId), verifier);
136 |   }
137 | 
138 |   async codeVerifier(): Promise<string> {
139 |     const codeVerifier = await this.storage.get<string>(
140 |       this.codeVerifierKey(this.clientId)
141 |     );
142 |     if (!codeVerifier) {
143 |       throw new Error("No code verifier found");
144 |     }
145 |     return codeVerifier;
146 |   }
147 | }
148 | 


--------------------------------------------------------------------------------
/packages/agents/src/mcp/index.ts:
--------------------------------------------------------------------------------
   1 | import { DurableObject } from "cloudflare:workers";
   2 | import type { Server } from "@modelcontextprotocol/sdk/server/index.js";
   3 | import type { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
   4 | import type { Transport } from "@modelcontextprotocol/sdk/shared/transport.js";
   5 | import type { JSONRPCMessage } from "@modelcontextprotocol/sdk/types.js";
   6 | import {
   7 |   InitializeRequestSchema,
   8 |   JSONRPCMessageSchema,
   9 |   isJSONRPCError,
  10 |   isJSONRPCNotification,
  11 |   isJSONRPCRequest,
  12 |   isJSONRPCResponse
  13 | } from "@modelcontextprotocol/sdk/types.js";
  14 | import type { Connection, WSMessage } from "../";
  15 | import { Agent } from "../index";
  16 | 
  17 | const MAXIMUM_MESSAGE_SIZE_BYTES = 4 * 1024 * 1024; // 4MB
  18 | 
  19 | // CORS helper functions
  20 | function corsHeaders(_request: Request, corsOptions: CORSOptions = {}) {
  21 |   const origin = "*";
  22 |   return {
  23 |     "Access-Control-Allow-Headers":
  24 |       corsOptions.headers ||
  25 |       "Content-Type, mcp-session-id, mcp-protocol-version",
  26 |     "Access-Control-Allow-Methods": corsOptions.methods || "GET, POST, OPTIONS",
  27 |     "Access-Control-Allow-Origin": corsOptions.origin || origin,
  28 |     "Access-Control-Expose-Headers":
  29 |       corsOptions.exposeHeaders || "mcp-session-id",
  30 |     "Access-Control-Max-Age": (corsOptions.maxAge || 86400).toString()
  31 |   };
  32 | }
  33 | 
  34 | function isDurableObjectNamespace(
  35 |   namespace: unknown
  36 | ): namespace is DurableObjectNamespace<McpAgent> {
  37 |   return (
  38 |     typeof namespace === "object" &&
  39 |     namespace !== null &&
  40 |     "newUniqueId" in namespace &&
  41 |     typeof namespace.newUniqueId === "function" &&
  42 |     "idFromName" in namespace &&
  43 |     typeof namespace.idFromName === "function"
  44 |   );
  45 | }
  46 | 
  47 | function handleCORS(
  48 |   request: Request,
  49 |   corsOptions?: CORSOptions
  50 | ): Response | null {
  51 |   if (request.method === "OPTIONS") {
  52 |     return new Response(null, { headers: corsHeaders(request, corsOptions) });
  53 |   }
  54 | 
  55 |   return null;
  56 | }
  57 | 
  58 | interface CORSOptions {
  59 |   origin?: string;
  60 |   methods?: string;
  61 |   headers?: string;
  62 |   maxAge?: number;
  63 |   exposeHeaders?: string;
  64 | }
  65 | 
  66 | class McpSSETransport implements Transport {
  67 |   onclose?: () => void;
  68 |   onerror?: (error: Error) => void;
  69 |   onmessage?: (message: JSONRPCMessage) => void;
  70 |   sessionId?: string;
  71 | 
  72 |   private _getWebSocket: () => WebSocket | null;
  73 |   private _started = false;
  74 |   constructor(getWebSocket: () => WebSocket | null) {
  75 |     this._getWebSocket = getWebSocket;
  76 |   }
  77 | 
  78 |   async start() {
  79 |     // The transport does not manage the WebSocket connection since it's terminated
  80 |     // by the Durable Object in order to allow hibernation. There's nothing to initialize.
  81 |     if (this._started) {
  82 |       throw new Error("Transport already started");
  83 |     }
  84 |     this._started = true;
  85 |   }
  86 | 
  87 |   async send(message: JSONRPCMessage) {
  88 |     if (!this._started) {
  89 |       throw new Error("Transport not started");
  90 |     }
  91 |     const websocket = this._getWebSocket();
  92 |     if (!websocket) {
  93 |       throw new Error("WebSocket not connected");
  94 |     }
  95 |     try {
  96 |       websocket.send(JSON.stringify(message));
  97 |     } catch (error) {
  98 |       this.onerror?.(error as Error);
  99 |       throw error;
 100 |     }
 101 |   }
 102 | 
 103 |   async close() {
 104 |     // Similar to start, the only thing to do is to pass the event on to the server
 105 |     this.onclose?.();
 106 |   }
 107 | }
 108 | 
 109 | type TransportType = "sse" | "streamable-http" | "unset";
 110 | 
 111 | class McpStreamableHttpTransport implements Transport {
 112 |   onclose?: () => void;
 113 |   onerror?: (error: Error) => void;
 114 |   onmessage?: (message: JSONRPCMessage) => void;
 115 |   sessionId?: string;
 116 | 
 117 |   // TODO: If there is an open connection to send server-initiated messages
 118 |   // back, we should use that connection
 119 |   private _getWebSocketForGetRequest: () => WebSocket | null;
 120 | 
 121 |   // Get the appropriate websocket connection for a given message id
 122 |   private _getWebSocketForMessageID: (id: string) => WebSocket | null;
 123 | 
 124 |   // Notify the server that a response has been sent for a given message id
 125 |   // so that it may clean up it's mapping of message ids to connections
 126 |   // once they are no longer needed
 127 |   private _notifyResponseIdSent: (id: string) => void;
 128 | 
 129 |   private _started = false;
 130 |   constructor(
 131 |     getWebSocketForMessageID: (id: string) => WebSocket | null,
 132 |     notifyResponseIdSent: (id: string | number) => void
 133 |   ) {
 134 |     this._getWebSocketForMessageID = getWebSocketForMessageID;
 135 |     this._notifyResponseIdSent = notifyResponseIdSent;
 136 |     // TODO
 137 |     this._getWebSocketForGetRequest = () => null;
 138 |   }
 139 | 
 140 |   async start() {
 141 |     // The transport does not manage the WebSocket connection since it's terminated
 142 |     // by the Durable Object in order to allow hibernation. There's nothing to initialize.
 143 |     if (this._started) {
 144 |       throw new Error("Transport already started");
 145 |     }
 146 |     this._started = true;
 147 |   }
 148 | 
 149 |   async send(message: JSONRPCMessage) {
 150 |     if (!this._started) {
 151 |       throw new Error("Transport not started");
 152 |     }
 153 | 
 154 |     let websocket: WebSocket | null = null;
 155 | 
 156 |     if (isJSONRPCResponse(message) || isJSONRPCError(message)) {
 157 |       websocket = this._getWebSocketForMessageID(message.id.toString());
 158 |       if (!websocket) {
 159 |         throw new Error(
 160 |           `Could not find WebSocket for message id: ${message.id}`
 161 |         );
 162 |       }
 163 |     } else if (isJSONRPCRequest(message)) {
 164 |       // requests originating from the server must be sent over the
 165 |       // the connection created by a GET request
 166 |       websocket = this._getWebSocketForGetRequest();
 167 |     } else if (isJSONRPCNotification(message)) {
 168 |       // notifications do not have an id
 169 |       // but do have a relatedRequestId field
 170 |       // so that they can be sent to the correct connection
 171 |       websocket = null;
 172 |     }
 173 | 
 174 |     try {
 175 |       websocket?.send(JSON.stringify(message));
 176 |       if (isJSONRPCResponse(message)) {
 177 |         this._notifyResponseIdSent(message.id.toString());
 178 |       }
 179 |     } catch (error) {
 180 |       this.onerror?.(error as Error);
 181 |       throw error;
 182 |     }
 183 |   }
 184 | 
 185 |   async close() {
 186 |     // Similar to start, the only thing to do is to pass the event on to the server
 187 |     this.onclose?.();
 188 |   }
 189 | }
 190 | 
 191 | type MaybePromise<T> = T | Promise<T>;
 192 | 
 193 | export abstract class McpAgent<
 194 |   Env = unknown,
 195 |   State = unknown,
 196 |   Props extends Record<string, unknown> = Record<string, unknown>
 197 | > extends DurableObject<Env> {
 198 |   private _status: "zero" | "starting" | "started" = "zero";
 199 |   private _transport?: Transport;
 200 |   private _transportType: TransportType = "unset";
 201 |   private _requestIdToConnectionId: Map<string | number, string> = new Map();
 202 | 
 203 |   /**
 204 |    * Since McpAgent's _aren't_ yet real "Agents", let's only expose a couple of the methods
 205 |    * to the outer class: initialState/state/setState/onStateUpdate/sql
 206 |    */
 207 |   private _agent: Agent<Env, State>;
 208 | 
 209 |   get mcp() {
 210 |     return this._agent.mcp;
 211 |   }
 212 | 
 213 |   protected constructor(ctx: DurableObjectState, env: Env) {
 214 |     super(ctx, env);
 215 |     const self = this;
 216 | 
 217 |     this._agent = new (class extends Agent<Env, State> {
 218 |       static options = {
 219 |         hibernate: true
 220 |       };
 221 | 
 222 |       onStateUpdate(state: State | undefined, source: Connection | "server") {
 223 |         return self.onStateUpdate(state, source);
 224 |       }
 225 | 
 226 |       async onMessage(
 227 |         connection: Connection,
 228 |         message: WSMessage
 229 |       ): Promise<void> {
 230 |         return self.onMessage(connection, message);
 231 |       }
 232 |     })(ctx, env);
 233 |   }
 234 | 
 235 |   /**
 236 |    * Agents API allowlist
 237 |    */
 238 |   initialState!: State;
 239 |   get state() {
 240 |     return this._agent.state;
 241 |   }
 242 |   sql<T = Record<string, string | number | boolean | null>>(
 243 |     strings: TemplateStringsArray,
 244 |     ...values: (string | number | boolean | null)[]
 245 |   ) {
 246 |     return this._agent.sql<T>(strings, ...values);
 247 |   }
 248 | 
 249 |   setState(state: State) {
 250 |     return this._agent.setState(state);
 251 |   }
 252 |   // biome-ignore lint/correctness/noUnusedFunctionParameters: overriden later
 253 |   onStateUpdate(state: State | undefined, source: Connection | "server") {
 254 |     // override this to handle state updates
 255 |   }
 256 |   async onStart() {
 257 |     const self = this;
 258 | 
 259 |     this._agent = new (class extends Agent<Env, State> {
 260 |       initialState: State = self.initialState;
 261 |       static options = {
 262 |         hibernate: true
 263 |       };
 264 | 
 265 |       onStateUpdate(state: State | undefined, source: Connection | "server") {
 266 |         return self.onStateUpdate(state, source);
 267 |       }
 268 | 
 269 |       async onMessage(connection: Connection, event: WSMessage) {
 270 |         return self.onMessage(connection, event);
 271 |       }
 272 |     })(this.ctx, this.env);
 273 | 
 274 |     this.props = (await this.ctx.storage.get("props")) as Props;
 275 |     this._transportType = (await this.ctx.storage.get(
 276 |       "transportType"
 277 |     )) as TransportType;
 278 |     await this._init(this.props);
 279 | 
 280 |     const server = await this.server;
 281 | 
 282 |     // Connect to the MCP server
 283 |     if (this._transportType === "sse") {
 284 |       this._transport = new McpSSETransport(() => this.getWebSocket());
 285 |       await server.connect(this._transport);
 286 |     } else if (this._transportType === "streamable-http") {
 287 |       this._transport = new McpStreamableHttpTransport(
 288 |         (id) => this.getWebSocketForResponseID(id),
 289 |         (id) => this._requestIdToConnectionId.delete(id)
 290 |       );
 291 |       await server.connect(this._transport);
 292 |     }
 293 |   }
 294 | 
 295 |   /**
 296 |    * McpAgent API
 297 |    */
 298 |   abstract server: MaybePromise<McpServer | Server>;
 299 |   props!: Props;
 300 |   initRun = false;
 301 | 
 302 |   abstract init(): Promise<void>;
 303 | 
 304 |   async _init(props: Props) {
 305 |     await this.ctx.storage.put("props", props ?? {});
 306 |     if (!this.ctx.storage.get("transportType")) {
 307 |       await this.ctx.storage.put("transportType", "unset");
 308 |     }
 309 |     this.props = props;
 310 |     if (!this.initRun) {
 311 |       this.initRun = true;
 312 |       await this.init();
 313 |     }
 314 |   }
 315 | 
 316 |   async setInitialized() {
 317 |     await this.ctx.storage.put("initialized", true);
 318 |   }
 319 | 
 320 |   async isInitialized() {
 321 |     return (await this.ctx.storage.get("initialized")) === true;
 322 |   }
 323 | 
 324 |   private async _initialize(): Promise<void> {
 325 |     await this.ctx.blockConcurrencyWhile(async () => {
 326 |       this._status = "starting";
 327 |       await this.onStart();
 328 |       this._status = "started";
 329 |     });
 330 |   }
 331 | 
 332 |   // Allow the worker to fetch a websocket connection to the agent
 333 |   async fetch(request: Request): Promise<Response> {
 334 |     if (this._status !== "started") {
 335 |       // This means the server "woke up" after hibernation
 336 |       // so we need to hydrate it again
 337 |       await this._initialize();
 338 |     }
 339 | 
 340 |     // Only handle WebSocket upgrade requests
 341 |     if (request.headers.get("Upgrade") !== "websocket") {
 342 |       return new Response("Expected WebSocket Upgrade request", {
 343 |         status: 400
 344 |       });
 345 |     }
 346 | 
 347 |     // This request does not come from the user. The worker generates this
 348 |     // request to generate a websocket connection to the agent.
 349 |     const url = new URL(request.url);
 350 |     // This is not the path that the user requested, but the path that the worker
 351 |     // generated. We'll use this path to determine which transport to use.
 352 |     const path = url.pathname;
 353 |     const server = await this.server;
 354 | 
 355 |     switch (path) {
 356 |       case "/sse": {
 357 |         // For SSE connections, we can only have one open connection per session
 358 |         // If we get an upgrade while already connected, we should error
 359 |         const websockets = this.ctx.getWebSockets();
 360 |         if (websockets.length > 0) {
 361 |           return new Response("Websocket already connected", { status: 400 });
 362 |         }
 363 | 
 364 |         // This session must always use the SSE transporo
 365 |         await this.ctx.storage.put("transportType", "sse");
 366 |         this._transportType = "sse";
 367 | 
 368 |         if (!this._transport) {
 369 |           this._transport = new McpSSETransport(() => this.getWebSocket());
 370 |           await server.connect(this._transport);
 371 |         }
 372 | 
 373 |         // Defer to the Agent's fetch method to handle the WebSocket connection
 374 |         return this._agent.fetch(request);
 375 |       }
 376 |       case "/streamable-http": {
 377 |         if (!this._transport) {
 378 |           this._transport = new McpStreamableHttpTransport(
 379 |             (id) => this.getWebSocketForResponseID(id),
 380 |             (id) => this._requestIdToConnectionId.delete(id)
 381 |           );
 382 |           await server.connect(this._transport);
 383 |         }
 384 | 
 385 |         // This session must always use the streamable-http transport
 386 |         await this.ctx.storage.put("transportType", "streamable-http");
 387 |         this._transportType = "streamable-http";
 388 | 
 389 |         return this._agent.fetch(request);
 390 |       }
 391 |       default:
 392 |         return new Response(
 393 |           "Internal Server Error: Expected /sse or /streamable-http path",
 394 |           {
 395 |             status: 500
 396 |           }
 397 |         );
 398 |     }
 399 |   }
 400 | 
 401 |   getWebSocket() {
 402 |     const websockets = this.ctx.getWebSockets();
 403 |     if (websockets.length === 0) {
 404 |       return null;
 405 |     }
 406 |     return websockets[0];
 407 |   }
 408 | 
 409 |   getWebSocketForResponseID(id: string): WebSocket | null {
 410 |     const connectionId = this._requestIdToConnectionId.get(id);
 411 |     if (connectionId === undefined) {
 412 |       return null;
 413 |     }
 414 |     return this._agent.getConnection(connectionId) ?? null;
 415 |   }
 416 | 
 417 |   // All messages received here. This is currently never called
 418 |   async onMessage(connection: Connection, event: WSMessage) {
 419 |     // Since we address the DO via both the protocol and the session id,
 420 |     // this should never happen, but let's enforce it just in case
 421 |     if (this._transportType !== "streamable-http") {
 422 |       const err = new Error(
 423 |         "Internal Server Error: Expected streamable-http protocol"
 424 |       );
 425 |       this._transport?.onerror?.(err);
 426 |       return;
 427 |     }
 428 | 
 429 |     let message: JSONRPCMessage;
 430 |     try {
 431 |       // Ensure event is a string
 432 |       const data =
 433 |         typeof event === "string" ? event : new TextDecoder().decode(event);
 434 |       message = JSONRPCMessageSchema.parse(JSON.parse(data));
 435 |     } catch (error) {
 436 |       this._transport?.onerror?.(error as Error);
 437 |       return;
 438 |     }
 439 | 
 440 |     // We need to map every incoming message to the connection that it came in on
 441 |     // so that we can send relevant responses and notifications back on the same connection
 442 |     if (isJSONRPCRequest(message)) {
 443 |       this._requestIdToConnectionId.set(message.id.toString(), connection.id);
 444 |     }
 445 | 
 446 |     this._transport?.onmessage?.(message);
 447 |   }
 448 | 
 449 |   // All messages received over SSE after the initial connection has been established
 450 |   // will be passed here
 451 |   async onSSEMcpMessage(
 452 |     _sessionId: string,
 453 |     request: Request
 454 |   ): Promise<Error | null> {
 455 |     if (this._status !== "started") {
 456 |       // This means the server "woke up" after hibernation
 457 |       // so we need to hydrate it again
 458 |       await this._initialize();
 459 |     }
 460 | 
 461 |     // Since we address the DO via both the protocol and the session id,
 462 |     // this should never happen, but let's enforce it just in case
 463 |     if (this._transportType !== "sse") {
 464 |       return new Error("Internal Server Error: Expected SSE protocol");
 465 |     }
 466 | 
 467 |     try {
 468 |       const message = await request.json();
 469 |       let parsedMessage: JSONRPCMessage;
 470 |       try {
 471 |         parsedMessage = JSONRPCMessageSchema.parse(message);
 472 |       } catch (error) {
 473 |         this._transport?.onerror?.(error as Error);
 474 |         throw error;
 475 |       }
 476 | 
 477 |       this._transport?.onmessage?.(parsedMessage);
 478 |       return null;
 479 |     } catch (error) {
 480 |       console.error("Error forwarding message to SSE:", error);
 481 |       this._transport?.onerror?.(error as Error);
 482 |       return error as Error;
 483 |     }
 484 |   }
 485 | 
 486 |   // Delegate all websocket events to the underlying agent
 487 |   async webSocketMessage(
 488 |     ws: WebSocket,
 489 |     event: ArrayBuffer | string
 490 |   ): Promise<void> {
 491 |     if (this._status !== "started") {
 492 |       // This means the server "woke up" after hibernation
 493 |       // so we need to hydrate it again
 494 |       await this._initialize();
 495 |     }
 496 |     return await this._agent.webSocketMessage(ws, event);
 497 |   }
 498 | 
 499 |   // WebSocket event handlers for hibernation support
 500 |   async webSocketError(ws: WebSocket, error: unknown): Promise<void> {
 501 |     if (this._status !== "started") {
 502 |       // This means the server "woke up" after hibernation
 503 |       // so we need to hydrate it again
 504 |       await this._initialize();
 505 |     }
 506 |     return await this._agent.webSocketError(ws, error);
 507 |   }
 508 | 
 509 |   async webSocketClose(
 510 |     ws: WebSocket,
 511 |     code: number,
 512 |     reason: string,
 513 |     wasClean: boolean
 514 |   ): Promise<void> {
 515 |     if (this._status !== "started") {
 516 |       // This means the server "woke up" after hibernation
 517 |       // so we need to hydrate it again
 518 |       await this._initialize();
 519 |     }
 520 |     return await this._agent.webSocketClose(ws, code, reason, wasClean);
 521 |   }
 522 | 
 523 |   static mount(
 524 |     path: string,
 525 |     {
 526 |       binding = "MCP_OBJECT",
 527 |       corsOptions
 528 |     }: {
 529 |       binding?: string;
 530 |       corsOptions?: CORSOptions;
 531 |     } = {}
 532 |   ) {
 533 |     return McpAgent.serveSSE(path, { binding, corsOptions });
 534 |   }
 535 | 
 536 |   static serveSSE(
 537 |     path: string,
 538 |     {
 539 |       binding = "MCP_OBJECT",
 540 |       corsOptions
 541 |     }: {
 542 |       binding?: string;
 543 |       corsOptions?: CORSOptions;
 544 |     } = {}
 545 |   ) {
 546 |     let pathname = path;
 547 |     if (path === "/") {
 548 |       pathname = "/*";
 549 |     }
 550 |     const basePattern = new URLPattern({ pathname });
 551 |     const messagePattern = new URLPattern({ pathname: `${pathname}/message` });
 552 | 
 553 |     return {
 554 |       async fetch<Env>(
 555 |         this: void,
 556 |         request: Request,
 557 |         env: Env,
 558 |         ctx: ExecutionContext
 559 |       ): Promise<Response> {
 560 |         // Handle CORS preflight
 561 |         const corsResponse = handleCORS(request, corsOptions);
 562 |         if (corsResponse) return corsResponse;
 563 | 
 564 |         const url = new URL(request.url);
 565 |         const bindingValue = env[binding as keyof typeof env] as unknown;
 566 | 
 567 |         // Ensure we have a binding of some sort
 568 |         if (bindingValue == null || typeof bindingValue !== "object") {
 569 |           console.error(
 570 |             `Could not find McpAgent binding for ${binding}. Did you update your wrangler configuration?`
 571 |           );
 572 |           return new Response("Invalid binding", { status: 500 });
 573 |         }
 574 | 
 575 |         // Ensure that the binding is to a DurableObject
 576 |         if (!isDurableObjectNamespace(bindingValue)) {
 577 |           return new Response("Invalid binding", { status: 500 });
 578 |         }
 579 | 
 580 |         const namespace =
 581 |           bindingValue satisfies DurableObjectNamespace<McpAgent>;
 582 | 
 583 |         // Handle initial SSE connection
 584 |         if (request.method === "GET" && basePattern.test(url)) {
 585 |           // Use a session ID if one is passed in, or create a unique
 586 |           // session ID for this connection
 587 |           const sessionId =
 588 |             url.searchParams.get("sessionId") ||
 589 |             namespace.newUniqueId().toString();
 590 | 
 591 |           // Create a Transform Stream for SSE
 592 |           const { readable, writable } = new TransformStream();
 593 |           const writer = writable.getWriter();
 594 |           const encoder = new TextEncoder();
 595 | 
 596 |           // Send the endpoint event
 597 |           const endpointUrl = new URL(request.url);
 598 |           endpointUrl.pathname = encodeURI(`${pathname}/message`);
 599 |           endpointUrl.searchParams.set("sessionId", sessionId);
 600 |           const relativeUrlWithSession =
 601 |             endpointUrl.pathname + endpointUrl.search + endpointUrl.hash;
 602 |           const endpointMessage = `event: endpoint\ndata: ${relativeUrlWithSession}\n\n`;
 603 |           writer.write(encoder.encode(endpointMessage));
 604 | 
 605 |           // Get the Durable Object
 606 |           const id = namespace.idFromName(`sse:${sessionId}`);
 607 |           const doStub = namespace.get(id);
 608 | 
 609 |           // Initialize the object
 610 |           await doStub._init(ctx.props);
 611 | 
 612 |           // Connect to the Durable Object via WebSocket
 613 |           const upgradeUrl = new URL(request.url);
 614 |           // enforce that the path that the DO receives is always /sse
 615 |           upgradeUrl.pathname = "/sse";
 616 |           const existingHeaders: Record<string, string> = {};
 617 |           request.headers.forEach((value, key) => {
 618 |             existingHeaders[key] = value;
 619 |           });
 620 |           const response = await doStub.fetch(
 621 |             new Request(upgradeUrl, {
 622 |               headers: {
 623 |                 ...existingHeaders,
 624 |                 Upgrade: "websocket",
 625 |                 // Required by PartyServer
 626 |                 "x-partykit-room": sessionId
 627 |               }
 628 |             })
 629 |           );
 630 | 
 631 |           // Get the WebSocket
 632 |           const ws = response.webSocket;
 633 |           if (!ws) {
 634 |             console.error("Failed to establish WebSocket connection");
 635 |             await writer.close();
 636 |             return new Response("Failed to establish WebSocket connection", {
 637 |               status: 500
 638 |             });
 639 |           }
 640 | 
 641 |           // Accept the WebSocket
 642 |           ws.accept();
 643 | 
 644 |           // Handle messages from the Durable Object
 645 |           ws.addEventListener("message", (event) => {
 646 |             async function onMessage(event: MessageEvent) {
 647 |               try {
 648 |                 const message = JSON.parse(event.data);
 649 | 
 650 |                 // validate that the message is a valid JSONRPC message
 651 |                 const result = JSONRPCMessageSchema.safeParse(message);
 652 |                 if (!result.success) {
 653 |                   // The message was not a valid JSONRPC message, so we will drop it
 654 |                   // PartyKit will broadcast state change messages to all connected clients
 655 |                   // and we need to filter those out so they are not passed to MCP clients
 656 |                   return;
 657 |                 }
 658 | 
 659 |                 // Send the message as an SSE event
 660 |                 const messageText = `event: message\ndata: ${JSON.stringify(result.data)}\n\n`;
 661 |                 await writer.write(encoder.encode(messageText));
 662 |               } catch (error) {
 663 |                 console.error("Error forwarding message to SSE:", error);
 664 |               }
 665 |             }
 666 |             onMessage(event).catch(console.error);
 667 |           });
 668 | 
 669 |           // Handle WebSocket errors
 670 |           ws.addEventListener("error", (error) => {
 671 |             async function onError(_error: Event) {
 672 |               try {
 673 |                 await writer.close();
 674 |               } catch (_e) {
 675 |                 // Ignore errors when closing
 676 |               }
 677 |             }
 678 |             onError(error).catch(console.error);
 679 |           });
 680 | 
 681 |           // Handle WebSocket closure
 682 |           ws.addEventListener("close", () => {
 683 |             async function onClose() {
 684 |               try {
 685 |                 await writer.close();
 686 |               } catch (error) {
 687 |                 console.error("Error closing SSE connection:", error);
 688 |               }
 689 |             }
 690 |             onClose().catch(console.error);
 691 |           });
 692 | 
 693 |           // Return the SSE response
 694 |           return new Response(readable, {
 695 |             headers: {
 696 |               "Cache-Control": "no-cache",
 697 |               Connection: "keep-alive",
 698 |               "Content-Type": "text/event-stream",
 699 |               ...corsHeaders(request, corsOptions)
 700 |             }
 701 |           });
 702 |         }
 703 | 
 704 |         // Handle incoming MCP messages. These will be passed to McpAgent
 705 |         // but the response will be sent back via the open SSE connection
 706 |         // so we only need to return a 202 Accepted response for success
 707 |         if (request.method === "POST" && messagePattern.test(url)) {
 708 |           const sessionId = url.searchParams.get("sessionId");
 709 |           if (!sessionId) {
 710 |             return new Response(
 711 |               `Missing sessionId. Expected POST to ${pathname} to initiate new one`,
 712 |               { status: 400 }
 713 |             );
 714 |           }
 715 | 
 716 |           const contentType = request.headers.get("content-type") || "";
 717 |           if (!contentType.includes("application/json")) {
 718 |             return new Response(`Unsupported content-type: ${contentType}`, {
 719 |               status: 400
 720 |             });
 721 |           }
 722 | 
 723 |           // check if the request body is too large
 724 |           const contentLength = Number.parseInt(
 725 |             request.headers.get("content-length") || "0",
 726 |             10
 727 |           );
 728 |           if (contentLength > MAXIMUM_MESSAGE_SIZE_BYTES) {
 729 |             return new Response(
 730 |               `Request body too large: ${contentLength} bytes`,
 731 |               {
 732 |                 status: 400
 733 |               }
 734 |             );
 735 |           }
 736 | 
 737 |           // Get the Durable Object
 738 |           const id = namespace.idFromName(`sse:${sessionId}`);
 739 |           const doStub = namespace.get(id);
 740 | 
 741 |           // Forward the request to the Durable Object
 742 |           const error = await doStub.onSSEMcpMessage(sessionId, request);
 743 | 
 744 |           if (error) {
 745 |             return new Response(error.message, {
 746 |               headers: {
 747 |                 "Cache-Control": "no-cache",
 748 |                 Connection: "keep-alive",
 749 |                 "Content-Type": "text/event-stream",
 750 |                 ...corsHeaders(request, corsOptions)
 751 |               },
 752 |               status: 400
 753 |             });
 754 |           }
 755 | 
 756 |           return new Response("Accepted", {
 757 |             headers: {
 758 |               "Cache-Control": "no-cache",
 759 |               Connection: "keep-alive",
 760 |               "Content-Type": "text/event-stream",
 761 |               ...corsHeaders(request, corsOptions)
 762 |             },
 763 |             status: 202
 764 |           });
 765 |         }
 766 | 
 767 |         return new Response("Not Found", { status: 404 });
 768 |       }
 769 |     };
 770 |   }
 771 | 
 772 |   static serve(
 773 |     path: string,
 774 |     {
 775 |       binding = "MCP_OBJECT",
 776 |       corsOptions
 777 |     }: { binding?: string; corsOptions?: CORSOptions } = {}
 778 |   ) {
 779 |     let pathname = path;
 780 |     if (path === "/") {
 781 |       pathname = "/*";
 782 |     }
 783 |     const basePattern = new URLPattern({ pathname });
 784 | 
 785 |     return {
 786 |       async fetch<Env>(
 787 |         this: void,
 788 |         request: Request,
 789 |         env: Env,
 790 |         ctx: ExecutionContext
 791 |       ): Promise<Response> {
 792 |         // Handle CORS preflight
 793 |         const corsResponse = handleCORS(request, corsOptions);
 794 |         if (corsResponse) {
 795 |           return corsResponse;
 796 |         }
 797 | 
 798 |         const url = new URL(request.url);
 799 |         const bindingValue = env[binding as keyof typeof env] as unknown;
 800 | 
 801 |         // Ensure we have a binding of some sort
 802 |         if (bindingValue == null || typeof bindingValue !== "object") {
 803 |           console.error(
 804 |             `Could not find McpAgent binding for ${binding}. Did you update your wrangler configuration?`
 805 |           );
 806 |           return new Response("Invalid binding", { status: 500 });
 807 |         }
 808 | 
 809 |         // Ensure that the binding is to a DurableObject
 810 |         if (!isDurableObjectNamespace(bindingValue)) {
 811 |           return new Response("Invalid binding", { status: 500 });
 812 |         }
 813 | 
 814 |         const namespace =
 815 |           bindingValue satisfies DurableObjectNamespace<McpAgent>;
 816 | 
 817 |         if (request.method === "POST" && basePattern.test(url)) {
 818 |           // validate the Accept header
 819 |           const acceptHeader = request.headers.get("accept");
 820 |           // The client MUST include an Accept header, listing both application/json and text/event-stream as supported content types.
 821 |           if (
 822 |             !acceptHeader?.includes("application/json") ||
 823 |             !acceptHeader.includes("text/event-stream")
 824 |           ) {
 825 |             const body = JSON.stringify({
 826 |               error: {
 827 |                 code: -32000,
 828 |                 message:
 829 |                   "Not Acceptable: Client must accept both application/json and text/event-stream"
 830 |               },
 831 |               id: null,
 832 |               jsonrpc: "2.0"
 833 |             });
 834 |             return new Response(body, { status: 406 });
 835 |           }
 836 | 
 837 |           const ct = request.headers.get("content-type");
 838 |           if (!ct || !ct.includes("application/json")) {
 839 |             const body = JSON.stringify({
 840 |               error: {
 841 |                 code: -32000,
 842 |                 message:
 843 |                   "Unsupported Media Type: Content-Type must be application/json"
 844 |               },
 845 |               id: null,
 846 |               jsonrpc: "2.0"
 847 |             });
 848 |             return new Response(body, { status: 415 });
 849 |           }
 850 | 
 851 |           // Check content length against maximum allowed size
 852 |           const contentLength = Number.parseInt(
 853 |             request.headers.get("content-length") ?? "0",
 854 |             10
 855 |           );
 856 |           if (contentLength > MAXIMUM_MESSAGE_SIZE_BYTES) {
 857 |             const body = JSON.stringify({
 858 |               error: {
 859 |                 code: -32000,
 860 |                 message: `Request body too large. Maximum size is ${MAXIMUM_MESSAGE_SIZE_BYTES} bytes`
 861 |               },
 862 |               id: null,
 863 |               jsonrpc: "2.0"
 864 |             });
 865 |             return new Response(body, { status: 413 });
 866 |           }
 867 | 
 868 |           let sessionId = request.headers.get("mcp-session-id");
 869 |           let rawMessage: unknown;
 870 | 
 871 |           try {
 872 |             rawMessage = await request.json();
 873 |           } catch (_error) {
 874 |             const body = JSON.stringify({
 875 |               error: {
 876 |                 code: -32700,
 877 |                 message: "Parse error: Invalid JSON"
 878 |               },
 879 |               id: null,
 880 |               jsonrpc: "2.0"
 881 |             });
 882 |             return new Response(body, { status: 400 });
 883 |           }
 884 | 
 885 |           // Make sure the message is an array to simplify logic
 886 |           let arrayMessage: unknown[];
 887 |           if (Array.isArray(rawMessage)) {
 888 |             arrayMessage = rawMessage;
 889 |           } else {
 890 |             arrayMessage = [rawMessage];
 891 |           }
 892 | 
 893 |           let messages: JSONRPCMessage[] = [];
 894 | 
 895 |           // Try to parse each message as JSON RPC. Fail if any message is invalid
 896 |           for (const msg of arrayMessage) {
 897 |             if (!JSONRPCMessageSchema.safeParse(msg).success) {
 898 |               const body = JSON.stringify({
 899 |                 error: {
 900 |                   code: -32700,
 901 |                   message: "Parse error: Invalid JSON-RPC message"
 902 |                 },
 903 |                 id: null,
 904 |                 jsonrpc: "2.0"
 905 |               });
 906 |               return new Response(body, { status: 400 });
 907 |             }
 908 |           }
 909 | 
 910 |           messages = arrayMessage.map((msg) => JSONRPCMessageSchema.parse(msg));
 911 | 
 912 |           // Before we pass the messages to the agent, there's another error condition we need to enforce
 913 |           // Check if this is an initialization request
 914 |           // https://spec.modelcontextprotocol.io/specification/2025-03-26/basic/lifecycle/
 915 |           const isInitializationRequest = messages.some(
 916 |             (msg) => InitializeRequestSchema.safeParse(msg).success
 917 |           );
 918 | 
 919 |           if (isInitializationRequest && sessionId) {
 920 |             const body = JSON.stringify({
 921 |               error: {
 922 |                 code: -32600,
 923 |                 message:
 924 |                   "Invalid Request: Initialization requests must not include a sessionId"
 925 |               },
 926 |               id: null,
 927 |               jsonrpc: "2.0"
 928 |             });
 929 |             return new Response(body, { status: 400 });
 930 |           }
 931 | 
 932 |           // The initialization request must be the only request in the batch
 933 |           if (isInitializationRequest && messages.length > 1) {
 934 |             const body = JSON.stringify({
 935 |               error: {
 936 |                 code: -32600,
 937 |                 message:
 938 |                   "Invalid Request: Only one initialization request is allowed"
 939 |               },
 940 |               id: null,
 941 |               jsonrpc: "2.0"
 942 |             });
 943 |             return new Response(body, { status: 400 });
 944 |           }
 945 | 
 946 |           // If an Mcp-Session-Id is returned by the server during initialization,
 947 |           // clients using the Streamable HTTP transport MUST include it
 948 |           // in the Mcp-Session-Id header on all of their subsequent HTTP requests.
 949 |           if (!isInitializationRequest && !sessionId) {
 950 |             const body = JSON.stringify({
 951 |               error: {
 952 |                 code: -32000,
 953 |                 message: "Bad Request: Mcp-Session-Id header is required"
 954 |               },
 955 |               id: null,
 956 |               jsonrpc: "2.0"
 957 |             });
 958 |             return new Response(body, { status: 400 });
 959 |           }
 960 | 
 961 |           // If we don't have a sessionId, we are serving an initialization request
 962 |           // and need to generate a new sessionId
 963 |           sessionId = sessionId ?? namespace.newUniqueId().toString();
 964 | 
 965 |           // fetch the agent DO
 966 |           const id = namespace.idFromName(`streamable-http:${sessionId}`);
 967 |           const doStub = namespace.get(id);
 968 |           const isInitialized = await doStub.isInitialized();
 969 | 
 970 |           if (isInitializationRequest) {
 971 |             await doStub._init(ctx.props);
 972 |             await doStub.setInitialized();
 973 |           } else if (!isInitialized) {
 974 |             // if we have gotten here, then a session id that was never initialized
 975 |             // was provided
 976 |             const body = JSON.stringify({
 977 |               error: {
 978 |                 code: -32001,
 979 |                 message: "Session not found"
 980 |               },
 981 |               id: null,
 982 |               jsonrpc: "2.0"
 983 |             });
 984 |             return new Response(body, { status: 404 });
 985 |           }
 986 | 
 987 |           // We've evaluated all the error conditions! Now it's time to establish
 988 |           // all the streams
 989 | 
 990 |           // Create a Transform Stream for SSE
 991 |           const { readable, writable } = new TransformStream();
 992 |           const writer = writable.getWriter();
 993 |           const encoder = new TextEncoder();
 994 | 
 995 |           // Connect to the Durable Object via WebSocket
 996 |           const upgradeUrl = new URL(request.url);
 997 |           upgradeUrl.pathname = "/streamable-http";
 998 |           const existingHeaders: Record<string, string> = {};
 999 |           request.headers.forEach((value, key) => {
1000 |             existingHeaders[key] = value;
1001 |           });
1002 |           const response = await doStub.fetch(
1003 |             new Request(upgradeUrl, {
1004 |               headers: {
1005 |                 ...existingHeaders,
1006 |                 Upgrade: "websocket",
1007 |                 // Required by PartyServer
1008 |                 "x-partykit-room": sessionId
1009 |               }
1010 |             })
1011 |           );
1012 | 
1013 |           // Get the WebSocket
1014 |           const ws = response.webSocket;
1015 |           if (!ws) {
1016 |             console.error("Failed to establish WebSocket connection");
1017 | 
1018 |             await writer.close();
1019 |             const body = JSON.stringify({
1020 |               error: {
1021 |                 code: -32001,
1022 |                 message: "Failed to establish WebSocket connection"
1023 |               },
1024 |               id: null,
1025 |               jsonrpc: "2.0"
1026 |             });
1027 |             return new Response(body, { status: 500 });
1028 |           }
1029 | 
1030 |           // Keep track of the request ids that we have sent to the server
1031 |           // so that we can close the connection once we have received
1032 |           // all the responses
1033 |           const requestIds: Set<string | number> = new Set();
1034 | 
1035 |           // Accept the WebSocket
1036 |           ws.accept();
1037 | 
1038 |           // Handle messages from the Durable Object
1039 |           ws.addEventListener("message", (event) => {
1040 |             async function onMessage(event: MessageEvent) {
1041 |               try {
1042 |                 const data =
1043 |                   typeof event.data === "string"
1044 |                     ? event.data
1045 |                     : new TextDecoder().decode(event.data);
1046 |                 const message = JSON.parse(data);
1047 | 
1048 |                 // validate that the message is a valid JSONRPC message
1049 |                 const result = JSONRPCMessageSchema.safeParse(message);
1050 |                 if (!result.success) {
1051 |                   // The message was not a valid JSONRPC message, so we will drop it
1052 |                   // PartyKit will broadcast state change messages to all connected clients
1053 |                   // and we need to filter those out so they are not passed to MCP clients
1054 |                   return;
1055 |                 }
1056 | 
1057 |                 // If the message is a response or an error, remove the id from the set of
1058 |                 // request ids
1059 |                 if (
1060 |                   isJSONRPCResponse(result.data) ||
1061 |                   isJSONRPCError(result.data)
1062 |                 ) {
1063 |                   requestIds.delete(result.data.id);
1064 |                 }
1065 | 
1066 |                 // Send the message as an SSE event
1067 |                 const messageText = `event: message\ndata: ${JSON.stringify(result.data)}\n\n`;
1068 |                 await writer.write(encoder.encode(messageText));
1069 | 
1070 |                 // If we have received all the responses, close the connection
1071 |                 if (requestIds.size === 0) {
1072 |                   ws!.close();
1073 |                 }
1074 |               } catch (error) {
1075 |                 console.error("Error forwarding message to SSE:", error);
1076 |               }
1077 |             }
1078 |             onMessage(event).catch(console.error);
1079 |           });
1080 | 
1081 |           // Handle WebSocket errors
1082 |           ws.addEventListener("error", (error) => {
1083 |             async function onError(_error: Event) {
1084 |               try {
1085 |                 await writer.close();
1086 |               } catch (_e) {
1087 |                 // Ignore errors when closing
1088 |               }
1089 |             }
1090 |             onError(error).catch(console.error);
1091 |           });
1092 | 
1093 |           // Handle WebSocket closure
1094 |           ws.addEventListener("close", () => {
1095 |             async function onClose() {
1096 |               try {
1097 |                 await writer.close();
1098 |               } catch (error) {
1099 |                 console.error("Error closing SSE connection:", error);
1100 |               }
1101 |             }
1102 |             onClose().catch(console.error);
1103 |           });
1104 | 
1105 |           // If there are no requests, we send the messages to the agent and acknowledge the request with a 202
1106 |           // since we don't expect any responses back through this connection
1107 |           const hasOnlyNotificationsOrResponses = messages.every(
1108 |             (msg) => isJSONRPCNotification(msg) || isJSONRPCResponse(msg)
1109 |           );
1110 |           if (hasOnlyNotificationsOrResponses) {
1111 |             for (const message of messages) {
1112 |               ws.send(JSON.stringify(message));
1113 |             }
1114 | 
1115 |             // closing the websocket will also close the SSE connection
1116 |             ws.close();
1117 | 
1118 |             return new Response(null, {
1119 |               headers: corsHeaders(request, corsOptions),
1120 |               status: 202
1121 |             });
1122 |           }
1123 | 
1124 |           for (const message of messages) {
1125 |             if (isJSONRPCRequest(message)) {
1126 |               // add each request id that we send off to a set
1127 |               // so that we can keep track of which requests we
1128 |               // still need a response for
1129 |               requestIds.add(message.id);
1130 |             }
1131 |             ws.send(JSON.stringify(message));
1132 |           }
1133 | 
1134 |           // Return the SSE response. We handle closing the stream in the ws "message"
1135 |           // handler
1136 |           return new Response(readable, {
1137 |             headers: {
1138 |               "Cache-Control": "no-cache",
1139 |               Connection: "keep-alive",
1140 |               "Content-Type": "text/event-stream",
1141 |               "mcp-session-id": sessionId,
1142 |               ...corsHeaders(request, corsOptions)
1143 |             },
1144 |             status: 200
1145 |           });
1146 |         }
1147 | 
1148 |         // We don't yet support GET or DELETE requests
1149 |         const body = JSON.stringify({
1150 |           error: {
1151 |             code: -32000,
1152 |             message: "Method not allowed"
1153 |           },
1154 |           id: null,
1155 |           jsonrpc: "2.0"
1156 |         });
1157 |         return new Response(body, { status: 405 });
1158 |       }
1159 |     };
1160 |   }
1161 | }
1162 | 
1163 | // Export client transport classes
1164 | export { SSEEdgeClientTransport } from "./sse-edge";
1165 | export { StreamableHTTPEdgeClientTransport } from "./streamable-http-edge";
1166 | 


--------------------------------------------------------------------------------
/packages/agents/src/mcp/sse-edge.ts:
--------------------------------------------------------------------------------
 1 | import type { OAuthClientProvider } from "@modelcontextprotocol/sdk/client/auth.js";
 2 | import {
 3 |   SSEClientTransport,
 4 |   type SSEClientTransportOptions
 5 | } from "@modelcontextprotocol/sdk/client/sse.js";
 6 | 
 7 | export class SSEEdgeClientTransport extends SSEClientTransport {
 8 |   private authProvider: OAuthClientProvider | undefined;
 9 |   /**
10 |    * Creates a new EdgeSSEClientTransport, which overrides fetch to be compatible with the CF workers environment
11 |    */
12 |   constructor(url: URL, options: SSEClientTransportOptions) {
13 |     const fetchOverride: typeof fetch = async (
14 |       fetchUrl: RequestInfo | URL,
15 |       fetchInit: RequestInit = {}
16 |     ) => {
17 |       // add auth headers
18 |       const headers = await this.authHeaders();
19 |       const workerOptions = {
20 |         ...fetchInit,
21 |         headers: {
22 |           ...options.requestInit?.headers,
23 |           ...fetchInit?.headers,
24 |           ...headers
25 |         }
26 |       };
27 | 
28 |       // Remove unsupported properties
29 |       delete workerOptions.mode;
30 | 
31 |       // Call the original fetch with fixed options
32 |       return (
33 |         (options.eventSourceInit?.fetch?.(
34 |           fetchUrl as URL | string,
35 |           // @ts-expect-error Expects FetchLikeInit from EventSource but is compatible with RequestInit
36 |           workerOptions
37 |         ) as Promise<Response>) || fetch(fetchUrl, workerOptions)
38 |       );
39 |     };
40 | 
41 |     super(url, {
42 |       ...options,
43 |       eventSourceInit: {
44 |         ...options.eventSourceInit,
45 |         fetch: fetchOverride
46 |       }
47 |     });
48 |     this.authProvider = options.authProvider;
49 |   }
50 | 
51 |   async authHeaders() {
52 |     if (this.authProvider) {
53 |       const tokens = await this.authProvider.tokens();
54 |       if (tokens) {
55 |         return {
56 |           Authorization: `Bearer ${tokens.access_token}`
57 |         };
58 |       }
59 |     }
60 |   }
61 | }
62 | 


--------------------------------------------------------------------------------
/packages/agents/src/mcp/streamable-http-edge.ts:
--------------------------------------------------------------------------------
 1 | import type { OAuthClientProvider } from "@modelcontextprotocol/sdk/client/auth.js";
 2 | import {
 3 |   StreamableHTTPClientTransport,
 4 |   type StreamableHTTPClientTransportOptions
 5 | } from "@modelcontextprotocol/sdk/client/streamableHttp.js";
 6 | 
 7 | export class StreamableHTTPEdgeClientTransport extends StreamableHTTPClientTransport {
 8 |   private authProvider: OAuthClientProvider | undefined;
 9 | 
10 |   /**
11 |    * Creates a new StreamableHTTPEdgeClientTransport, which overrides fetch to be compatible with the CF workers environment
12 |    */
13 |   constructor(url: URL, options: StreamableHTTPClientTransportOptions) {
14 |     const fetchOverride: typeof fetch = async (
15 |       fetchUrl: RequestInfo | URL,
16 |       fetchInit: RequestInit = {}
17 |     ) => {
18 |       // add auth headers
19 |       const headers = await this.authHeaders();
20 |       const workerOptions = {
21 |         ...fetchInit,
22 |         headers: {
23 |           ...options.requestInit?.headers,
24 |           ...fetchInit?.headers,
25 |           ...headers
26 |         }
27 |       };
28 | 
29 |       // Remove unsupported properties
30 |       delete workerOptions.mode;
31 | 
32 |       // Call the original fetch with fixed options
33 |       return (
34 |         // @ts-expect-error Custom fetch function for Cloudflare Workers compatibility
35 |         (options.requestInit?.fetch?.(
36 |           fetchUrl as URL | string,
37 |           workerOptions
38 |         ) as Promise<Response>) || fetch(fetchUrl, workerOptions)
39 |       );
40 |     };
41 | 
42 |     super(url, {
43 |       ...options,
44 |       requestInit: {
45 |         ...options.requestInit,
46 |         // @ts-expect-error Custom fetch override for Cloudflare Workers
47 |         fetch: fetchOverride
48 |       }
49 |     });
50 |     this.authProvider = options.authProvider;
51 |   }
52 | 
53 |   async authHeaders() {
54 |     if (this.authProvider) {
55 |       const tokens = await this.authProvider.tokens();
56 |       if (tokens) {
57 |         return {
58 |           Authorization: `Bearer ${tokens.access_token}`
59 |         };
60 |       }
61 |     }
62 |   }
63 | }
64 | 


--------------------------------------------------------------------------------
/packages/agents/src/observability/index.ts:
--------------------------------------------------------------------------------
  1 | import type { Message } from "ai";
  2 | import type { Schedule } from "../index";
  3 | import { getCurrentAgent } from "../index";
  4 | 
  5 | type BaseEvent<
  6 |   T extends string,
  7 |   Payload extends Record<string, unknown> = {}
  8 | > = {
  9 |   type: T;
 10 |   /**
 11 |    * The unique identifier for the event
 12 |    */
 13 |   id: string;
 14 |   /**
 15 |    * The message to display in the logs for this event, should the implementation choose to display
 16 |    * a human-readable message.
 17 |    */
 18 |   displayMessage: string;
 19 |   /**
 20 |    * The payload of the event
 21 |    */
 22 |   payload: Payload;
 23 |   /**
 24 |    * The timestamp of the event in milliseconds since epoch
 25 |    */
 26 |   timestamp: number;
 27 | };
 28 | 
 29 | /**
 30 |  * The type of events that can be emitted by an Agent
 31 |  */
 32 | export type ObservabilityEvent =
 33 |   | BaseEvent<
 34 |       "state:update",
 35 |       {
 36 |         state: unknown;
 37 |         previousState: unknown;
 38 |       }
 39 |     >
 40 |   | BaseEvent<
 41 |       "rpc",
 42 |       {
 43 |         method: string;
 44 |         args: unknown[];
 45 |         streaming?: boolean;
 46 |         success: boolean;
 47 |       }
 48 |     >
 49 |   | BaseEvent<
 50 |       "message:request" | "message:response",
 51 |       {
 52 |         message: Message[];
 53 |       }
 54 |     >
 55 |   | BaseEvent<"message:clear">
 56 |   | BaseEvent<
 57 |       "schedule:create" | "schedule:execute" | "schedule:cancel",
 58 |       Schedule<unknown>
 59 |     >
 60 |   | BaseEvent<"destroy">
 61 |   | BaseEvent<
 62 |       "connect",
 63 |       {
 64 |         connectionId: string;
 65 |       }
 66 |     >;
 67 | 
 68 | export interface Observability {
 69 |   /**
 70 |    * Emit an event for the Agent's observability implementation to handle.
 71 |    * @param event - The event to emit
 72 |    * @param ctx - The execution context of the invocation
 73 |    */
 74 |   emit(event: ObservabilityEvent, ctx: DurableObjectState): void;
 75 | }
 76 | 
 77 | /**
 78 |  * A generic observability implementation that logs events to the console.
 79 |  */
 80 | export const genericObservability: Observability = {
 81 |   emit(event) {
 82 |     // In local mode, we display a pretty-print version of the event for easier debugging.
 83 |     if (isLocalMode()) {
 84 |       console.log(event.displayMessage);
 85 |       return;
 86 |     }
 87 | 
 88 |     console.log(event);
 89 |   }
 90 | };
 91 | 
 92 | let localMode = false;
 93 | 
 94 | function isLocalMode() {
 95 |   if (localMode) {
 96 |     return true;
 97 |   }
 98 |   const { request } = getCurrentAgent();
 99 |   if (!request) {
100 |     return false;
101 |   }
102 | 
103 |   const url = new URL(request.url);
104 |   localMode = url.hostname === "localhost";
105 |   return localMode;
106 | }
107 | 


--------------------------------------------------------------------------------
/packages/agents/src/react-tests/use-agent-chat.test.tsx:
--------------------------------------------------------------------------------
 1 | import { StrictMode, Suspense, act } from "react";
 2 | import { describe, expect, it, vi } from "vitest";
 3 | import { render } from "vitest-browser-react";
 4 | import { useAgentChat } from "../ai-react";
 5 | import type { useAgent } from "../react";
 6 | 
 7 | // mock the @ai-sdk/react package
 8 | vi.mock("@ai-sdk/react", () => ({
 9 |   useChat: vi.fn((args) => ({
10 |     messages: args.initialMessages,
11 |     setMessages: vi.fn()
12 |   }))
13 | }));
14 | 
15 | /**
16 |  * Unit tests for the hook functionality which mock the network
17 |  * layer and @ai-sdk dependencies.
18 |  */
19 | describe("useAgentChat", () => {
20 |   it("should cache initial message responses across re-renders", async () => {
21 |     // mocking the agent with a subset of fields used in useAgentChat
22 |     const mockAgent: ReturnType<typeof useAgent> = {
23 |       _pkurl: "ws://localhost:3000",
24 |       _url: "ws://localhost:3000",
25 |       addEventListener: vi.fn(),
26 |       id: "fake-agent",
27 |       name: "fake-agent",
28 |       removeEventListener: vi.fn(),
29 |       send: vi.fn()
30 |       // biome-ignore lint/suspicious/noExplicitAny: tests
31 |     } as any;
32 | 
33 |     const testMessages = [
34 |       { content: "Hi", id: "1", role: "user" as const },
35 |       { content: "Hello", id: "2", role: "assistant" as const }
36 |     ];
37 |     const getInitialMessages = vi.fn(() => Promise.resolve(testMessages));
38 | 
39 |     // We can observe how many times Suspense was triggered with this component.
40 |     const suspenseRendered = vi.fn();
41 |     const SuspenseObserver = () => {
42 |       suspenseRendered();
43 |       return "Suspended";
44 |     };
45 | 
46 |     const TestComponent = () => {
47 |       const chat = useAgentChat({
48 |         agent: mockAgent,
49 |         getInitialMessages
50 |       });
51 | 
52 |       // NOTE: this only works because of how @ai-sdk/react is mocked to use
53 |       // the initialMessages prop as the messages state in the mock return value.
54 |       return <div data-testid="messages">{JSON.stringify(chat.messages)}</div>;
55 |     };
56 | 
57 |     // wrapping in act is required to resolve the suspense boundary during
58 |     // initial render.
59 |     const screen = await act(() =>
60 |       render(<TestComponent />, {
61 |         wrapper: ({ children }) => (
62 |           <StrictMode>
63 |             <Suspense fallback={<SuspenseObserver />}>{children}</Suspense>
64 |           </StrictMode>
65 |         )
66 |       })
67 |     );
68 | 
69 |     // wait for Suspense to resolve
70 |     await expect
71 |       .element(screen.getByTestId("messages"))
72 |       .toHaveTextContent(JSON.stringify(testMessages));
73 | 
74 |     // the component fetches the initial messages and suspends on first render
75 |     expect(getInitialMessages).toHaveBeenCalledTimes(1);
76 |     expect(suspenseRendered).toHaveBeenCalled();
77 | 
78 |     // reset our Suspense observer
79 |     suspenseRendered.mockClear();
80 | 
81 |     await screen.rerender(<TestComponent />);
82 | 
83 |     await expect
84 |       .element(screen.getByTestId("messages"))
85 |       .toHaveTextContent(JSON.stringify(testMessages));
86 | 
87 |     // since the initial messages are cached, the getInitialMessages function is not called again
88 |     // and the component does not suspend
89 |     expect(getInitialMessages).toHaveBeenCalledTimes(1);
90 |     expect(suspenseRendered).not.toHaveBeenCalled();
91 |   });
92 | });
93 | 


--------------------------------------------------------------------------------
/packages/agents/src/react-tests/vitest.config.ts:
--------------------------------------------------------------------------------
 1 | import { defineConfig } from "vitest/config";
 2 | 
 3 | export default defineConfig({
 4 |   test: {
 5 |     browser: {
 6 |       enabled: true,
 7 |       instances: [
 8 |         {
 9 |           browser: "chromium",
10 |           headless: true
11 |         }
12 |       ],
13 |       provider: "playwright"
14 |     },
15 |     clearMocks: true
16 |   }
17 | });
18 | 


--------------------------------------------------------------------------------
/packages/agents/src/react.tsx:
--------------------------------------------------------------------------------
  1 | import type { PartySocket } from "partysocket";
  2 | import { usePartySocket } from "partysocket/react";
  3 | import { useCallback, useRef } from "react";
  4 | import type { Agent, MCPServersState, RPCRequest, RPCResponse } from "./";
  5 | import type { StreamOptions } from "./client";
  6 | import type { Method, RPCMethod } from "./serializable";
  7 | 
  8 | /**
  9 |  * Convert a camelCase string to a kebab-case string
 10 |  * @param str The string to convert
 11 |  * @returns The kebab-case string
 12 |  */
 13 | function camelCaseToKebabCase(str: string): string {
 14 |   // If string is all uppercase, convert to lowercase
 15 |   if (str === str.toUpperCase() && str !== str.toLowerCase()) {
 16 |     return str.toLowerCase().replace(/_/g, "-");
 17 |   }
 18 | 
 19 |   // Otherwise handle camelCase to kebab-case
 20 |   let kebabified = str.replace(
 21 |     /[A-Z]/g,
 22 |     (letter) => `-${letter.toLowerCase()}`
 23 |   );
 24 |   kebabified = kebabified.startsWith("-") ? kebabified.slice(1) : kebabified;
 25 |   // Convert any remaining underscores to hyphens and remove trailing -'s
 26 |   return kebabified.replace(/_/g, "-").replace(/-$/, "");
 27 | }
 28 | 
 29 | /**
 30 |  * Options for the useAgent hook
 31 |  * @template State Type of the Agent's state
 32 |  */
 33 | export type UseAgentOptions<State = unknown> = Omit<
 34 |   Parameters<typeof usePartySocket>[0],
 35 |   "party" | "room"
 36 | > & {
 37 |   /** Name of the agent to connect to */
 38 |   agent: string;
 39 |   /** Name of the specific Agent instance */
 40 |   name?: string;
 41 |   /** Called when the Agent's state is updated */
 42 |   onStateUpdate?: (state: State, source: "server" | "client") => void;
 43 |   /** Called when MCP server state is updated */
 44 |   onMcpUpdate?: (mcpServers: MCPServersState) => void;
 45 | };
 46 | 
 47 | type AllOptional<T> = T extends [infer A, ...infer R]
 48 |   ? undefined extends A
 49 |     ? AllOptional<R>
 50 |     : false
 51 |   : true; // no params means optional by default
 52 | 
 53 | type RPCMethods<T> = {
 54 |   [K in keyof T as T[K] extends RPCMethod<T[K]> ? K : never]: RPCMethod<T[K]>;
 55 | };
 56 | 
 57 | type OptionalParametersMethod<T extends RPCMethod> =
 58 |   AllOptional<Parameters<T>> extends true ? T : never;
 59 | 
 60 | // all methods of the Agent, excluding the ones that are declared in the base Agent class
 61 | // biome-ignore lint: suppressions/parse
 62 | type AgentMethods<T> = Omit<RPCMethods<T>, keyof Agent<any, any>>;
 63 | 
 64 | type OptionalAgentMethods<T> = {
 65 |   [K in keyof AgentMethods<T> as AgentMethods<T>[K] extends OptionalParametersMethod<
 66 |     AgentMethods<T>[K]
 67 |   >
 68 |     ? K
 69 |     : never]: OptionalParametersMethod<AgentMethods<T>[K]>;
 70 | };
 71 | 
 72 | type RequiredAgentMethods<T> = Omit<
 73 |   AgentMethods<T>,
 74 |   keyof OptionalAgentMethods<T>
 75 | >;
 76 | 
 77 | type AgentPromiseReturnType<T, K extends keyof AgentMethods<T>> =
 78 |   // biome-ignore lint: suppressions/parse
 79 |   ReturnType<AgentMethods<T>[K]> extends Promise<any>
 80 |     ? ReturnType<AgentMethods<T>[K]>
 81 |     : Promise<ReturnType<AgentMethods<T>[K]>>;
 82 | 
 83 | type OptionalArgsAgentMethodCall<AgentT> = <
 84 |   K extends keyof OptionalAgentMethods<AgentT>
 85 | >(
 86 |   method: K,
 87 |   args?: Parameters<OptionalAgentMethods<AgentT>[K]>,
 88 |   streamOptions?: StreamOptions
 89 | ) => AgentPromiseReturnType<AgentT, K>;
 90 | 
 91 | type RequiredArgsAgentMethodCall<AgentT> = <
 92 |   K extends keyof RequiredAgentMethods<AgentT>
 93 | >(
 94 |   method: K,
 95 |   args: Parameters<RequiredAgentMethods<AgentT>[K]>,
 96 |   streamOptions?: StreamOptions
 97 | ) => AgentPromiseReturnType<AgentT, K>;
 98 | 
 99 | type AgentMethodCall<AgentT> = OptionalArgsAgentMethodCall<AgentT> &
100 |   RequiredArgsAgentMethodCall<AgentT>;
101 | 
102 | type UntypedAgentMethodCall = <T = unknown>(
103 |   method: string,
104 |   args?: unknown[],
105 |   streamOptions?: StreamOptions
106 | ) => Promise<T>;
107 | 
108 | type AgentStub<T> = {
109 |   [K in keyof AgentMethods<T>]: (
110 |     ...args: Parameters<AgentMethods<T>[K]>
111 |   ) => AgentPromiseReturnType<AgentMethods<T>, K>;
112 | };
113 | 
114 | // we neet to use Method instead of RPCMethod here for retro-compatibility
115 | type UntypedAgentStub = Record<string, Method>;
116 | 
117 | /**
118 |  * React hook for connecting to an Agent
119 |  * @template State Type of the Agent's state
120 |  * @template Agent Type of the Agent
121 |  * @param options Connection options
122 |  * @returns WebSocket connection with setState and call methods
123 |  */
124 | export function useAgent<State = unknown>(
125 |   options: UseAgentOptions<State>
126 | ): PartySocket & {
127 |   agent: string;
128 |   name: string;
129 |   setState: (state: State) => void;
130 |   call: UntypedAgentMethodCall;
131 |   stub: UntypedAgentStub;
132 | };
133 | export function useAgent<
134 |   AgentT extends {
135 |     get state(): State;
136 |   },
137 |   State
138 | >(
139 |   options: UseAgentOptions<State>
140 | ): PartySocket & {
141 |   agent: string;
142 |   name: string;
143 |   setState: (state: State) => void;
144 |   call: AgentMethodCall<AgentT>;
145 |   stub: AgentStub<AgentT>;
146 | };
147 | export function useAgent<State>(
148 |   options: UseAgentOptions<unknown>
149 | ): PartySocket & {
150 |   agent: string;
151 |   name: string;
152 |   setState: (state: State) => void;
153 |   call: UntypedAgentMethodCall | AgentMethodCall<unknown>;
154 |   stub: UntypedAgentStub;
155 | } {
156 |   const agentNamespace = camelCaseToKebabCase(options.agent);
157 |   // Keep track of pending RPC calls
158 |   const pendingCallsRef = useRef(
159 |     new Map<
160 |       string,
161 |       {
162 |         resolve: (value: unknown) => void;
163 |         reject: (error: Error) => void;
164 |         stream?: StreamOptions;
165 |       }
166 |     >()
167 |   );
168 | 
169 |   // TODO: if options.query is a function, then use
170 |   // "use()" to get the value and pass it
171 |   // as a query parameter to usePartySocket
172 |   const agent = usePartySocket({
173 |     party: agentNamespace,
174 |     prefix: "agents",
175 |     room: options.name || "default",
176 |     ...options,
177 |     onMessage: (message) => {
178 |       if (typeof message.data === "string") {
179 |         let parsedMessage: Record<string, unknown>;
180 |         try {
181 |           parsedMessage = JSON.parse(message.data);
182 |         } catch (_error) {
183 |           // silently ignore invalid messages for now
184 |           // TODO: log errors with log levels
185 |           return options.onMessage?.(message);
186 |         }
187 |         if (parsedMessage.type === "cf_agent_state") {
188 |           options.onStateUpdate?.(parsedMessage.state as State, "server");
189 |           return;
190 |         }
191 |         if (parsedMessage.type === "cf_agent_mcp_servers") {
192 |           options.onMcpUpdate?.(parsedMessage.mcp as MCPServersState);
193 |           return;
194 |         }
195 |         if (parsedMessage.type === "rpc") {
196 |           const response = parsedMessage as RPCResponse;
197 |           const pending = pendingCallsRef.current.get(response.id);
198 |           if (!pending) return;
199 | 
200 |           if (!response.success) {
201 |             pending.reject(new Error(response.error));
202 |             pendingCallsRef.current.delete(response.id);
203 |             pending.stream?.onError?.(response.error);
204 |             return;
205 |           }
206 | 
207 |           // Handle streaming responses
208 |           if ("done" in response) {
209 |             if (response.done) {
210 |               pending.resolve(response.result);
211 |               pendingCallsRef.current.delete(response.id);
212 |               pending.stream?.onDone?.(response.result);
213 |             } else {
214 |               pending.stream?.onChunk?.(response.result);
215 |             }
216 |           } else {
217 |             // Non-streaming response
218 |             pending.resolve(response.result);
219 |             pendingCallsRef.current.delete(response.id);
220 |           }
221 |           return;
222 |         }
223 |       }
224 |       options.onMessage?.(message);
225 |     }
226 |   }) as PartySocket & {
227 |     agent: string;
228 |     name: string;
229 |     setState: (state: State) => void;
230 |     call: UntypedAgentMethodCall;
231 |     stub: UntypedAgentStub;
232 |   };
233 |   // Create the call method
234 |   const call = useCallback(
235 |     <T = unknown,>(
236 |       method: string,
237 |       args: unknown[] = [],
238 |       streamOptions?: StreamOptions
239 |     ): Promise<T> => {
240 |       return new Promise((resolve, reject) => {
241 |         const id = Math.random().toString(36).slice(2);
242 |         pendingCallsRef.current.set(id, {
243 |           reject,
244 |           resolve: resolve as (value: unknown) => void,
245 |           stream: streamOptions
246 |         });
247 | 
248 |         const request: RPCRequest = {
249 |           args,
250 |           id,
251 |           method,
252 |           type: "rpc"
253 |         };
254 | 
255 |         agent.send(JSON.stringify(request));
256 |       });
257 |     },
258 |     [agent]
259 |   );
260 | 
261 |   agent.setState = (state: State) => {
262 |     agent.send(JSON.stringify({ state, type: "cf_agent_state" }));
263 |     options.onStateUpdate?.(state, "client");
264 |   };
265 | 
266 |   agent.call = call;
267 |   agent.agent = agentNamespace;
268 |   agent.name = options.name || "default";
269 |   // biome-ignore lint: suppressions/parse
270 |   agent.stub = new Proxy<any>(
271 |     {},
272 |     {
273 |       get: (_target, method) => {
274 |         return (...args: unknown[]) => {
275 |           return call(method as string, args);
276 |         };
277 |       }
278 |     }
279 |   );
280 | 
281 |   // warn if agent isn't in lowercase
282 |   if (agent.agent !== agent.agent.toLowerCase()) {
283 |     console.warn(
284 |       `Agent name: ${agent.agent} should probably be in lowercase. Received: ${agent.agent}`
285 |     );
286 |   }
287 | 
288 |   return agent;
289 | }
290 | 


--------------------------------------------------------------------------------
/packages/agents/src/schedule.ts:
--------------------------------------------------------------------------------
 1 | import { z } from "zod";
 2 | 
 3 | export type Schedule = z.infer<typeof unstable_scheduleSchema>;
 4 | 
 5 | export function unstable_getSchedulePrompt(event: { date: Date }) {
 6 |   return `
 7 | [Schedule Parser Component]
 8 | 
 9 | Current time: ${event.date.toUTCString()}
10 | 
11 | This component parses natural language scheduling requests into a structured format. It extracts:
12 | 1. A clean task description (without timing information)
13 | 2. Scheduling details in one of these formats:
14 |    - scheduled: Specific date/time events
15 |    - delayed: Relative time delays (in seconds)
16 |    - cron: Recurring patterns
17 |    - no-schedule: Tasks without timing
18 | 
19 | Rules:
20 | - Task descriptions should be clean and focused on the action
21 | - Use numbers (0-6) for days in cron patterns (0=Sunday)
22 | - For recurring tasks, use standard cron syntax
23 | - For relative times, convert to seconds
24 | - For specific dates, use the current time as reference
25 | 
26 | Example outputs:
27 | {
28 |   "description": "meeting with team",
29 |   "when": {
30 |     "type": "scheduled",
31 |     "date": "tomorrow at 14:00"
32 |   }
33 | }
34 | 
35 | {
36 |   "description": "backup database",
37 |   "when": {
38 |     "type": "cron",
39 |     "cron": "0 0 * * *"
40 |   }
41 | }
42 | 
43 | {
44 |   "description": "send report",
45 |   "when": {
46 |     "type": "delayed",
47 |     "delayInSeconds": 1800
48 |   }
49 | }
50 | 
51 | [End Schedule Parser Component]
52 | `;
53 | }
54 | 
55 | export const unstable_scheduleSchema = z.object({
56 |   description: z.string().describe("A description of the task"),
57 |   when: z.object({
58 |     cron: z
59 |       .string()
60 |       .optional()
61 |       .describe(
62 |         "execute task on a recurring interval specified as cron syntax (only use if the type is cron)"
63 |       ),
64 |     date: z.coerce
65 |       .date()
66 |       .optional()
67 |       .describe(
68 |         "execute task at the specified date and time (only use if the type is scheduled)"
69 |       ),
70 |     delayInSeconds: z
71 |       .number()
72 |       .optional()
73 |       .describe(
74 |         "execute task after a delay in seconds (only use if the type is delayed)"
75 |       ),
76 |     type: z
77 |       .enum(["scheduled", "delayed", "cron", "no-schedule"])
78 |       .describe("The type of scheduling details")
79 |   })
80 | });
81 | 


--------------------------------------------------------------------------------
/packages/agents/src/serializable.ts:
--------------------------------------------------------------------------------
 1 | export type SerializableValue =
 2 |   | undefined
 3 |   | null
 4 |   | string
 5 |   | number
 6 |   | boolean
 7 |   | { [key: string]: SerializableValue }
 8 |   | SerializableValue[];
 9 | 
10 | export type SerializableReturnValue =
11 |   | SerializableValue
12 |   | void
13 |   | Promise<SerializableValue>
14 |   | Promise<void>;
15 | 
16 | type AllSerializableValues<A> = A extends [infer First, ...infer Rest]
17 |   ? First extends SerializableValue
18 |     ? AllSerializableValues<Rest>
19 |     : false
20 |   : true; // no params means serializable by default
21 | 
22 | // biome-ignore lint: suspicious/noExplicitAny
23 | export type Method = (...args: any[]) => any;
24 | 
25 | export type RPCMethod<T = Method> = T extends Method
26 |   ? T extends (...arg: infer A) => infer R
27 |     ? AllSerializableValues<A> extends true
28 |       ? R extends SerializableReturnValue
29 |         ? T
30 |         : never
31 |       : never
32 |     : never
33 |   : never;
34 | 


--------------------------------------------------------------------------------
/packages/agents/src/tests-d/example-stub.test-d.ts:
--------------------------------------------------------------------------------
 1 | import type { env } from "cloudflare:workers";
 2 | import { Agent, unstable_callable as callable } from "..";
 3 | import { useAgent } from "../react.tsx";
 4 | 
 5 | class MyAgent extends Agent<typeof env, {}> {
 6 |   @callable()
 7 |   sayHello(name?: string): string {
 8 |     return `Hello, ${name ?? "World"}!`;
 9 |   }
10 | 
11 |   @callable()
12 |   async perform(_task: string, _p1?: number): Promise<void> {
13 |     // do something
14 |   }
15 | 
16 |   // not decorated with @callable()
17 |   nonRpc(): void {
18 |     // do something
19 |   }
20 | }
21 | 
22 | // biome-ignore lint/correctness/useHookAtTopLevel: tests
23 | const { stub } = useAgent<MyAgent, {}>({ agent: "my-agent" });
24 | // return type is promisified
25 | stub.sayHello() satisfies Promise<string>;
26 | 
27 | // @ts-expect-error first argument is not a string
28 | await stub.sayHello(1);
29 | 
30 | await stub.perform("some task", 1);
31 | await stub.perform("another task");
32 | // @ts-expect-error requires parameters
33 | await stub.perform();
34 | 
35 | // we cannot exclude it because typescript doesn't have a way
36 | // to exclude based on decorators
37 | await stub.nonRpc();
38 | 
39 | // @ts-expect-error nonSerializable is not serializable
40 | await stub.nonSerializable("hello", new Date());
41 | 
42 | // biome-ignore lint/correctness/useHookAtTopLevel: tests
43 | const { stub: stub2 } = useAgent<Omit<MyAgent, "nonRpc">, {}>({
44 |   agent: "my-agent"
45 | });
46 | stub2.sayHello();
47 | // @ts-expect-error nonRpc excluded from useAgent
48 | stub2.nonRpc();
49 | 


--------------------------------------------------------------------------------
/packages/agents/src/tests-d/example.test-d.ts:
--------------------------------------------------------------------------------
 1 | import type { env } from "cloudflare:workers";
 2 | import { Agent, unstable_callable as callable } from "..";
 3 | import { useAgent } from "../react.tsx";
 4 | 
 5 | class MyAgent extends Agent<typeof env, {}> {
 6 |   @callable()
 7 |   sayHello(name?: string): string {
 8 |     return `Hello, ${name ?? "World"}!`;
 9 |   }
10 | 
11 |   @callable()
12 |   async perform(_task: string, _p1?: number): Promise<void> {
13 |     // do something
14 |   }
15 | 
16 |   // not decorated with @callable()
17 |   nonRpc(): void {
18 |     // do something
19 |   }
20 | }
21 | 
22 | // biome-ignore lint/correctness/useHookAtTopLevel: tests
23 | const agent = useAgent<MyAgent, {}>({ agent: "my-agent" });
24 | // return type is promisified
25 | agent.call("sayHello") satisfies Promise<string>;
26 | 
27 | // @ts-expect-error first argument is not a string
28 | await agent.call("sayHello", [1]);
29 | 
30 | await agent.call("perform", ["some task", 1]);
31 | await agent.call("perform", ["another task"]);
32 | // @ts-expect-error requires parameters
33 | await agent.call("perform");
34 | 
35 | // we cannot exclude it because typescript doesn't have a way
36 | // to exclude based on decorators
37 | await agent.call("nonRpc");
38 | 
39 | // @ts-expect-error nonSerializable is not serializable
40 | await agent.call("nonSerializable", ["hello", new Date()]);
41 | 
42 | // biome-ignore lint/correctness/useHookAtTopLevel: tests
43 | const agent2 = useAgent<Omit<MyAgent, "nonRpc">, {}>({ agent: "my-agent" });
44 | agent2.call("sayHello");
45 | // @ts-expect-error nonRpc excluded from useAgent
46 | agent2.call("nonRpc");
47 | 


--------------------------------------------------------------------------------
/packages/agents/src/tests-d/typed-use-agent.test-d.ts:
--------------------------------------------------------------------------------
 1 | import type { env } from "cloudflare:workers";
 2 | import { Agent } from "..";
 3 | import { useAgent } from "../react";
 4 | 
 5 | declare class A extends Agent<typeof env, {}> {
 6 |   prop: string;
 7 |   f1: () => number;
 8 |   f2: (a: string) => void;
 9 |   f3: (a: number, b: string) => Promise<string>;
10 |   f4: (a?: string) => void;
11 |   f5: (a: string | undefined) => void;
12 |   f6: () => Promise<void>;
13 |   f7: (a: string | undefined, b: number) => Promise<void>;
14 |   f8: (a: string | undefined, b?: number) => Promise<void>;
15 |   nonSerializableParams: (a: string, b: { c: Date }) => void;
16 |   nonSerializableReturn: (a: string) => Date;
17 | }
18 | 
19 | // @ts-expect-error state doesn't match type A state
20 | // biome-ignore lint/correctness/useHookAtTopLevel: tests
21 | const _a2 = useAgent<A, { foo: "bar" }>({
22 |   agent: "test"
23 | });
24 | 
25 | // biome-ignore lint/correctness/useHookAtTopLevel: tests
26 | const a1 = useAgent<A, {}>({
27 |   agent: "test"
28 | });
29 | 
30 | a1.call("f1") satisfies Promise<number>;
31 | // @ts-expect-error
32 | a1.call("f1", [1]) satisfies Promise<number>;
33 | 
34 | a1.call("f2", ["test"]) satisfies Promise<void>;
35 | // @ts-expect-error should receive a [string]
36 | a1.call("f2");
37 | // @ts-expect-error
38 | a1.call("f2", [1]);
39 | 
40 | a1.call("f3", [1, "test"]) satisfies Promise<string>;
41 | // @ts-expect-error should receive a [number, string]
42 | a1.call("f3") satisfies Promise<string>;
43 | // @ts-expect-error
44 | a1.call("f3", [1]) satisfies Promise<string>;
45 | 
46 | a1.call("f4") satisfies Promise<void>;
47 | a1.call("f4", []) satisfies Promise<void>;
48 | a1.call("f4", [undefined]) satisfies Promise<void>;
49 | 
50 | a1.call("f5") satisfies Promise<void>;
51 | // @ts-expect-error should receive a [string | undefined]
52 | a1.call("f5", []) satisfies Promise<void>;
53 | a1.call("f5", [undefined]) satisfies Promise<void>;
54 | 
55 | a1.call("f6") satisfies Promise<void>;
56 | 
57 | // @ts-expect-error should receive a [string | undefined, number]
58 | a1.call("f7") satisfies Promise<void>;
59 | a1.call("f7", [undefined, 1]) satisfies Promise<void>;
60 | 
61 | a1.call("f8") satisfies Promise<void>;
62 | a1.call("f8", [undefined, undefined]) satisfies Promise<void>;
63 | 
64 | // @ts-expect-error Date parameter not serializable
65 | a1.call("nonSerializableParams", ["test", { c: new Date() }]);
66 | // @ts-expect-error Date return not serializable
67 | a1.call("nonSerializableReturn", ["test"]);
68 | 


--------------------------------------------------------------------------------
/packages/agents/src/tests-d/untyped-use-agent-stub.test-d.ts:
--------------------------------------------------------------------------------
 1 | import type { env } from "cloudflare:workers";
 2 | import { Agent } from "..";
 3 | import { useAgent } from "../react";
 4 | 
 5 | declare class A extends Agent<typeof env, {}> {
 6 |   prop: string;
 7 |   fn: () => number;
 8 |   nonSerializableParams: (a: string, b: { c: Date }) => void;
 9 |   nonSerializableReturn: (a: string) => Date;
10 | }
11 | 
12 | // biome-ignore lint/correctness/useHookAtTopLevel: tests
13 | const { stub } = useAgent<{}>({
14 |   agent: "test"
15 | });
16 | 
17 | // ensure retro-compatibility with useAgent<State> API
18 | stub.fn();
19 | stub.fn(1);
20 | stub.foo(1, "bar");
21 | stub.nonSerializableParams("test", { c: new Date(), unexistent: "property" });
22 | stub.nonSerializableReturn("test");
23 | 


--------------------------------------------------------------------------------
/packages/agents/src/tests-d/untyped-use-agent.test-d.ts:
--------------------------------------------------------------------------------
 1 | import type { env } from "cloudflare:workers";
 2 | import { Agent } from "..";
 3 | import { useAgent } from "../react";
 4 | 
 5 | declare class A extends Agent<typeof env, {}> {
 6 |   prop: string;
 7 |   fn: () => number;
 8 |   nonSerializableParams: (a: string, b: { c: Date }) => void;
 9 |   nonSerializableReturn: (a: string) => Date;
10 | }
11 | 
12 | // biome-ignore lint/correctness/useHookAtTopLevel: tests
13 | const a1 = useAgent<{}>({
14 |   agent: "test"
15 | });
16 | 
17 | // ensure retro-compatibility with useAgent<State> API
18 | a1.call("fn");
19 | a1.call("fn", [1]);
20 | a1.call("fn", [1], { onDone: () => {} });
21 | a1.call("nonSerializableParams", [
22 |   "test",
23 |   { c: new Date(), unexistent: "property" }
24 | ]);
25 | a1.call("nonSerializableReturn", []);
26 | 


--------------------------------------------------------------------------------
/packages/agents/src/tests-d/use-agent-stub.test-d.ts:
--------------------------------------------------------------------------------
 1 | import type { env } from "cloudflare:workers";
 2 | import { Agent } from "..";
 3 | import { useAgent } from "../react";
 4 | 
 5 | declare class A extends Agent<typeof env, {}> {
 6 |   prop: string;
 7 |   f1: () => number;
 8 |   f2: (a: string) => void;
 9 |   f3: (a: number, b: string) => Promise<string>;
10 |   f4: (a?: string) => void;
11 |   f5: (a: string | undefined) => void;
12 |   f6: () => Promise<void>;
13 |   nonSerializableParams: (a: string, b: { c: Date }) => void;
14 |   nonSerializableReturn: (a: string) => Date;
15 | }
16 | 
17 | // biome-ignore lint/correctness/useHookAtTopLevel: tests
18 | const { stub } = useAgent<A, {}>({
19 |   agent: "test"
20 | });
21 | 
22 | stub.f1() satisfies Promise<number>;
23 | // @ts-expect-error
24 | stub.f1(1) satisfies Promise<number>;
25 | 
26 | stub.f2("test") satisfies Promise<void>;
27 | // @ts-expect-error should receive a [string]
28 | stub.f2();
29 | // @ts-expect-error
30 | stub.f2(1);
31 | 
32 | stub.f3(1, "test") satisfies Promise<string>;
33 | // @ts-expect-error should receive a [number, string]
34 | stub.f3() satisfies Promise<string>;
35 | // @ts-expect-error
36 | stub.f3(1) satisfies Promise<string>;
37 | 
38 | stub.f4() satisfies Promise<void>;
39 | stub.f4() satisfies Promise<void>;
40 | stub.f4(undefined) satisfies Promise<void>;
41 | 
42 | // @ts-expect-error should receive a [string | undefined]
43 | stub.f5() satisfies Promise<void>;
44 | stub.f5(undefined) satisfies Promise<void>;
45 | 
46 | stub.f6() satisfies Promise<void>;
47 | 
48 | // @ts-expect-error should not have base Agent methods
49 | stub.setState({ prop: "test" });
50 | 
51 | // @ts-expect-error Date parameter not serializable
52 | stub.nonSerializableParams("test", { c: new Date() });
53 | // @ts-expect-error Date return not serializable
54 | stub.nonSerializableReturn("test");
55 | 


--------------------------------------------------------------------------------
/packages/agents/src/tests/email-routing.test.ts:
--------------------------------------------------------------------------------
  1 | import { describe, expect, it } from "vitest";
  2 | import { env } from "cloudflare:test";
  3 | import {
  4 |   createAddressBasedEmailResolver,
  5 |   createHeaderBasedEmailResolver,
  6 |   createCatchAllEmailResolver,
  7 |   routeAgentEmail,
  8 |   getAgentByName
  9 | } from "../index";
 10 | import type { Env } from "./worker";
 11 | 
 12 | // Declare module to get proper typing for env
 13 | declare module "cloudflare:test" {
 14 |   interface ProvidedEnv extends Env {}
 15 | }
 16 | 
 17 | // Mock ForwardableEmailMessage
 18 | function createMockEmail(
 19 |   overrides: Partial<ForwardableEmailMessage> = {}
 20 | ): ForwardableEmailMessage {
 21 |   return {
 22 |     from: "sender@example.com",
 23 |     to: "recipient@example.com",
 24 |     headers: new Headers(),
 25 |     raw: new ReadableStream(),
 26 |     rawSize: 1024,
 27 |     setReject: () => {},
 28 |     forward: async () => {},
 29 |     reply: async () => {},
 30 |     ...overrides
 31 |   };
 32 | }
 33 | 
 34 | describe("Email Resolver Case Sensitivity", () => {
 35 |   describe("createAddressBasedEmailResolver", () => {
 36 |     it("should handle CamelCase agent names in email addresses", async () => {
 37 |       const resolver = createAddressBasedEmailResolver("default-agent");
 38 | 
 39 |       // Test with CamelCase agent name
 40 |       const email = createMockEmail({
 41 |         to: "CaseSensitiveAgent+InstanceName@domain.com"
 42 |       });
 43 | 
 44 |       const result = await resolver(email, {});
 45 |       expect(result).toEqual({
 46 |         agentName: "CaseSensitiveAgent",
 47 |         agentId: "InstanceName"
 48 |       });
 49 |     });
 50 | 
 51 |     it("should handle kebab-case agent names in email addresses", async () => {
 52 |       const resolver = createAddressBasedEmailResolver("default-agent");
 53 | 
 54 |       const email = createMockEmail({
 55 |         to: "case-sensitive-agent+instance-name@domain.com"
 56 |       });
 57 | 
 58 |       const result = await resolver(email, {});
 59 |       expect(result).toEqual({
 60 |         agentName: "case-sensitive-agent",
 61 |         agentId: "instance-name"
 62 |       });
 63 |     });
 64 | 
 65 |     it("should handle mixed case variations", async () => {
 66 |       const resolver = createAddressBasedEmailResolver("default-agent");
 67 | 
 68 |       const testCases = [
 69 |         "EmailAgent+test@domain.com",
 70 |         "email-agent+test@domain.com",
 71 |         "EMAILAGENT+test@domain.com",
 72 |         "Email-Agent+test@domain.com"
 73 |       ];
 74 | 
 75 |       for (const to of testCases) {
 76 |         const email = createMockEmail({ to });
 77 |         const result = await resolver(email, {});
 78 |         expect(result).toBeTruthy();
 79 |         expect(result?.agentId).toBe("test");
 80 |       }
 81 |     });
 82 | 
 83 |     it("should use default agent name when no sub-address is provided", async () => {
 84 |       const resolver = createAddressBasedEmailResolver("EmailAgent");
 85 | 
 86 |       const email = createMockEmail({
 87 |         to: "john.doe@domain.com"
 88 |       });
 89 | 
 90 |       const result = await resolver(email, {});
 91 |       expect(result).toEqual({
 92 |         agentName: "EmailAgent",
 93 |         agentId: "john.doe"
 94 |       });
 95 |     });
 96 |   });
 97 | 
 98 |   describe("createHeaderBasedEmailResolver", () => {
 99 |     it("should handle various case formats in message-id header", async () => {
100 |       const resolver = createHeaderBasedEmailResolver();
101 | 
102 |       const testCases = [
103 |         {
104 |           messageId: "<agent123@EmailAgent.domain.com>",
105 |           expectedName: "EmailAgent"
106 |         },
107 |         {
108 |           messageId: "<agent123@email-agent.domain.com>",
109 |           expectedName: "email-agent"
110 |         },
111 |         {
112 |           messageId: "<agent123@CaseSensitiveAgent.domain.com>",
113 |           expectedName: "CaseSensitiveAgent"
114 |         }
115 |       ];
116 | 
117 |       for (const { messageId, expectedName } of testCases) {
118 |         const headers = new Headers({ "message-id": messageId });
119 |         const email = createMockEmail({ headers });
120 | 
121 |         const result = await resolver(email, {});
122 |         expect(result).toEqual({
123 |           agentName: expectedName,
124 |           agentId: "agent123"
125 |         });
126 |       }
127 |     });
128 | 
129 |     it("should handle x-agent-name header with various cases", async () => {
130 |       const resolver = createHeaderBasedEmailResolver();
131 | 
132 |       const headers = new Headers({
133 |         "x-agent-name": "CaseSensitiveAgent",
134 |         "x-agent-id": "test-id"
135 |       });
136 | 
137 |       const email = createMockEmail({ headers });
138 |       const result = await resolver(email, {});
139 | 
140 |       expect(result).toEqual({
141 |         agentName: "CaseSensitiveAgent",
142 |         agentId: "test-id"
143 |       });
144 |     });
145 |   });
146 | 
147 |   describe("createCatchAllEmailResolver", () => {
148 |     it("should return the exact agent name provided", async () => {
149 |       const testCases = [
150 |         { agentName: "EmailAgent", agentId: "default" },
151 |         { agentName: "email-agent", agentId: "default" },
152 |         { agentName: "CaseSensitiveAgent", agentId: "test" }
153 |       ];
154 | 
155 |       for (const { agentName, agentId } of testCases) {
156 |         const resolver = createCatchAllEmailResolver(agentName, agentId);
157 |         const email = createMockEmail();
158 | 
159 |         const result = await resolver(email, {});
160 |         expect(result).toEqual({ agentName, agentId });
161 |       }
162 |     });
163 |   });
164 | 
165 |   describe("routeAgentEmail with case normalization", () => {
166 |     it("should route to correct agent regardless of case in resolver result", async () => {
167 |       // Test resolver returning different case formats
168 |       const testCases = [
169 |         { agentName: "EmailAgent", agentId: "test1" },
170 |         { agentName: "email-agent", agentId: "test2" },
171 |         { agentName: "CaseSensitiveAgent", agentId: "test3" },
172 |         { agentName: "case-sensitive-agent", agentId: "test4" }
173 |       ];
174 | 
175 |       for (const { agentName, agentId } of testCases) {
176 |         const resolver = async () => ({ agentName, agentId });
177 |         const email = createMockEmail();
178 | 
179 |         // Route the email using the real DurableObject bindings from test env
180 |         await routeAgentEmail(email, env, { resolver });
181 | 
182 |         // Since we can't easily inspect the agent's state in the test,
183 |         // we trust that if no error is thrown, routing succeeded
184 |         // The agent should have received the email regardless of case
185 |       }
186 |     });
187 | 
188 |     it("should throw helpful error when agent namespace not found", async () => {
189 |       const resolver = async () => ({
190 |         agentName: "NonExistentAgent",
191 |         agentId: "test"
192 |       });
193 |       const email = createMockEmail();
194 | 
195 |       await expect(routeAgentEmail(email, env, { resolver })).rejects.toThrow(
196 |         /Agent namespace 'NonExistentAgent' not found in environment/
197 |       );
198 |     });
199 | 
200 |     it("should handle real-world email routing scenario", async () => {
201 |       // Test with actual DurableObject from env
202 |       const userEmail = createMockEmail({
203 |         to: "UserNotificationAgent+user123@company.com",
204 |         from: "user@example.com"
205 |       });
206 | 
207 |       const resolver = createAddressBasedEmailResolver("default");
208 | 
209 |       // This should route to the UserNotificationAgent DurableObject
210 |       await routeAgentEmail(userEmail, env, { resolver });
211 | 
212 |       // Verify we can access the agent
213 |       const agent = await getAgentByName(env.UserNotificationAgent, "user123");
214 |       expect(agent).toBeDefined();
215 |     });
216 | 
217 |     it("should handle email replies with kebab-case in headers", async () => {
218 |       // Email reply with kebab-case in message-id
219 |       const headers = new Headers({
220 |         "message-id": "<reply123@email-agent.company.com>",
221 |         "in-reply-to": "<original@client.com>"
222 |       });
223 | 
224 |       const replyEmail = createMockEmail({ headers });
225 |       const resolver = createHeaderBasedEmailResolver();
226 | 
227 |       // This should route to EmailAgent even though the header uses kebab-case
228 |       await routeAgentEmail(replyEmail, env, { resolver });
229 |     });
230 |   });
231 | 
232 |   describe("Integration: Case sensitivity bug fix verification", () => {
233 |     it("should solve the original reported bug", async () => {
234 |       // Original bug: User had to use exact case "CaseSensitiveAgent+InstanceName@domain.com"
235 |       // Now all these variations should work:
236 | 
237 |       const testEmails = [
238 |         "CaseSensitiveAgent+bug-test@domain.com", // Original format that was required
239 |         "case-sensitive-agent+bug-test@domain.com", // Kebab-case format now also works
240 |         "EmailAgent+bug-test@domain.com", // CamelCase format
241 |         "email-agent+bug-test@domain.com" // Kebab-case format
242 |       ];
243 | 
244 |       const resolver = createAddressBasedEmailResolver("default");
245 | 
246 |       for (const to of testEmails) {
247 |         const email = createMockEmail({ to });
248 | 
249 |         // All variations should successfully route without error
250 |         await expect(
251 |           routeAgentEmail(email, env, { resolver })
252 |         ).resolves.not.toThrow();
253 |       }
254 |     });
255 |   });
256 | });
257 | 


--------------------------------------------------------------------------------
/packages/agents/src/tests/mcp/mcp-protocol.test.ts:
--------------------------------------------------------------------------------
  1 | import { createExecutionContext, env } from "cloudflare:test";
  2 | import { describe, expect, it } from "vitest";
  3 | import worker, { type Env } from "../worker";
  4 | import {
  5 |   TEST_MESSAGES,
  6 |   initializeStreamableHTTPServer,
  7 |   establishSSEConnection,
  8 |   sendPostRequest,
  9 |   readSSEEvent,
 10 |   parseSSEData,
 11 |   expectValidToolsList,
 12 |   expectValidGreetResult,
 13 |   expectValidPropsResult
 14 | } from "../shared/test-utils";
 15 | 
 16 | declare module "cloudflare:test" {
 17 |   interface ProvidedEnv extends Env {}
 18 | }
 19 | 
 20 | /**
 21 |  * Core MCP protocol tests that should work regardless of transport
 22 |  */
 23 | describe("MCP Protocol Core Functionality", () => {
 24 |   describe("Tool Operations", () => {
 25 |     it("should list available tools via streamable HTTP", async () => {
 26 |       const ctx = createExecutionContext();
 27 |       const sessionId = await initializeStreamableHTTPServer(ctx);
 28 | 
 29 |       const response = await sendPostRequest(
 30 |         ctx,
 31 |         "http://example.com/mcp",
 32 |         TEST_MESSAGES.toolsList,
 33 |         sessionId
 34 |       );
 35 | 
 36 |       expect(response.status).toBe(200);
 37 |       const sseText = await readSSEEvent(response);
 38 |       const result = parseSSEData(sseText);
 39 | 
 40 |       expectValidToolsList(result);
 41 |     });
 42 | 
 43 |     it("should list available tools via SSE", async () => {
 44 |       const ctx = createExecutionContext();
 45 |       const { sessionId, reader } = await establishSSEConnection(ctx);
 46 | 
 47 |       const toolsRequest = new Request(
 48 |         `http://example.com/sse/message?sessionId=${sessionId}`,
 49 |         {
 50 |           body: JSON.stringify(TEST_MESSAGES.toolsList),
 51 |           headers: { "Content-Type": "application/json" },
 52 |           method: "POST"
 53 |         }
 54 |       );
 55 | 
 56 |       const toolsResponse = await worker.fetch(toolsRequest, env, ctx);
 57 |       expect(toolsResponse.status).toBe(202);
 58 | 
 59 |       const { value } = await reader.read();
 60 |       const toolsEvent = new TextDecoder().decode(value);
 61 |       const result = JSON.parse(
 62 |         toolsEvent.split("\n")[1].replace("data: ", "")
 63 |       );
 64 | 
 65 |       expectValidToolsList(result);
 66 |     });
 67 | 
 68 |     it("should invoke greet tool via streamable HTTP", async () => {
 69 |       const ctx = createExecutionContext();
 70 |       const sessionId = await initializeStreamableHTTPServer(ctx);
 71 | 
 72 |       const response = await sendPostRequest(
 73 |         ctx,
 74 |         "http://example.com/mcp",
 75 |         TEST_MESSAGES.greetTool,
 76 |         sessionId
 77 |       );
 78 | 
 79 |       expect(response.status).toBe(200);
 80 |       const sseText = await readSSEEvent(response);
 81 |       const result = parseSSEData(sseText);
 82 | 
 83 |       expectValidGreetResult(result, "Test User");
 84 |     });
 85 | 
 86 |     it("should invoke greet tool via SSE", async () => {
 87 |       const ctx = createExecutionContext();
 88 |       const { sessionId, reader } = await establishSSEConnection(ctx);
 89 | 
 90 |       const greetRequest = new Request(
 91 |         `http://example.com/sse/message?sessionId=${sessionId}`,
 92 |         {
 93 |           body: JSON.stringify(TEST_MESSAGES.greetTool),
 94 |           headers: { "Content-Type": "application/json" },
 95 |           method: "POST"
 96 |         }
 97 |       );
 98 | 
 99 |       const greetResponse = await worker.fetch(greetRequest, env, ctx);
100 |       expect(greetResponse.status).toBe(202);
101 | 
102 |       const { value } = await reader.read();
103 |       const greetEvent = new TextDecoder().decode(value);
104 |       const result = JSON.parse(
105 |         greetEvent.split("\n")[1].replace("data: ", "")
106 |       );
107 | 
108 |       expectValidGreetResult(result, "Test User");
109 |     });
110 |   });
111 | 
112 |   describe("Props Passing", () => {
113 |     it("should pass props to agent via streamable HTTP", async () => {
114 |       const ctx = createExecutionContext();
115 |       const sessionId = await initializeStreamableHTTPServer(ctx);
116 | 
117 |       const response = await sendPostRequest(
118 |         ctx,
119 |         "http://example.com/mcp",
120 |         TEST_MESSAGES.propsTestTool,
121 |         sessionId
122 |       );
123 | 
124 |       expect(response.status).toBe(200);
125 |       const sseText = await readSSEEvent(response);
126 |       const result = parseSSEData(sseText);
127 | 
128 |       expectValidPropsResult(result);
129 |     });
130 | 
131 |     it("should pass props to agent via SSE", async () => {
132 |       const ctx = createExecutionContext();
133 |       const { sessionId, reader } = await establishSSEConnection(ctx);
134 | 
135 |       const propsRequest = new Request(
136 |         `http://example.com/sse/message?sessionId=${sessionId}`,
137 |         {
138 |           body: JSON.stringify(TEST_MESSAGES.propsTestTool),
139 |           headers: { "Content-Type": "application/json" },
140 |           method: "POST"
141 |         }
142 |       );
143 | 
144 |       const propsResponse = await worker.fetch(propsRequest, env, ctx);
145 |       expect(propsResponse.status).toBe(202);
146 | 
147 |       const { value } = await reader.read();
148 |       const propsEvent = new TextDecoder().decode(value);
149 |       const result = JSON.parse(
150 |         propsEvent.split("\n")[1].replace("data: ", "")
151 |       );
152 | 
153 |       expectValidPropsResult(result);
154 |     });
155 |   });
156 | });
157 | 


--------------------------------------------------------------------------------
/packages/agents/src/tests/mcp/transports/sse.test.ts:
--------------------------------------------------------------------------------
  1 | import { createExecutionContext, env } from "cloudflare:test";
  2 | import { describe, expect, it } from "vitest";
  3 | import worker, { type Env } from "../../worker";
  4 | import { establishSSEConnection } from "../../shared/test-utils";
  5 | 
  6 | declare module "cloudflare:test" {
  7 |   interface ProvidedEnv extends Env {}
  8 | }
  9 | 
 10 | /**
 11 |  * Tests specific to the SSE transport protocol
 12 |  */
 13 | describe("SSE Transport", () => {
 14 |   const baseUrl = "http://example.com/sse";
 15 | 
 16 |   describe("Connection Establishment", () => {
 17 |     it("should establish connection and return session endpoint", async () => {
 18 |       const ctx = createExecutionContext();
 19 | 
 20 |       const request = new Request(baseUrl);
 21 |       const sseStream = await worker.fetch(request, env, ctx);
 22 | 
 23 |       const reader = sseStream.body?.getReader();
 24 |       const { done, value } = await reader!.read();
 25 |       const event = new TextDecoder().decode(value);
 26 | 
 27 |       expect(done).toBe(false);
 28 | 
 29 |       const lines = event.split("\n");
 30 |       expect(lines[0]).toEqual("event: endpoint");
 31 |       expect(lines[1]).toMatch(/^data: \/sse\/message\?sessionId=.*$/);
 32 |     });
 33 |   });
 34 | 
 35 |   describe("Message Handling", () => {
 36 |     it("should accept messages and return 202 Accepted", async () => {
 37 |       const ctx = createExecutionContext();
 38 |       const { sessionId } = await establishSSEConnection(ctx);
 39 | 
 40 |       const toolsRequest = new Request(
 41 |         `${baseUrl}/message?sessionId=${sessionId}`,
 42 |         {
 43 |           body: JSON.stringify({
 44 |             id: "1",
 45 |             jsonrpc: "2.0",
 46 |             method: "tools/list"
 47 |           }),
 48 |           headers: { "Content-Type": "application/json" },
 49 |           method: "POST"
 50 |         }
 51 |       );
 52 | 
 53 |       const toolsResponse = await worker.fetch(toolsRequest, env, ctx);
 54 |       expect(toolsResponse.status).toBe(202);
 55 |       expect(toolsResponse.headers.get("Content-Type")).toBe(
 56 |         "text/event-stream"
 57 |       );
 58 |       expect(await toolsResponse.text()).toBe("Accepted");
 59 |     });
 60 | 
 61 |     it("should deliver responses via SSE stream", async () => {
 62 |       const ctx = createExecutionContext();
 63 |       const { sessionId, reader } = await establishSSEConnection(ctx);
 64 | 
 65 |       const toolsRequest = new Request(
 66 |         `${baseUrl}/message?sessionId=${sessionId}`,
 67 |         {
 68 |           body: JSON.stringify({
 69 |             id: "1",
 70 |             jsonrpc: "2.0",
 71 |             method: "tools/list"
 72 |           }),
 73 |           headers: { "Content-Type": "application/json" },
 74 |           method: "POST"
 75 |         }
 76 |       );
 77 | 
 78 |       await worker.fetch(toolsRequest, env, ctx);
 79 | 
 80 |       const { done, value } = await reader.read();
 81 |       expect(done).toBe(false);
 82 | 
 83 |       const toolsEvent = new TextDecoder().decode(value);
 84 |       const lines = toolsEvent.split("\n");
 85 |       expect(lines[0]).toEqual("event: message");
 86 | 
 87 |       const jsonResponse = JSON.parse(lines[1].replace("data: ", ""));
 88 |       expect(jsonResponse.jsonrpc).toBe("2.0");
 89 |       expect(jsonResponse.id).toBe("1");
 90 |       expect(jsonResponse.result.tools).toBeDefined();
 91 |     });
 92 |   });
 93 | 
 94 |   describe("Transport-specific Features", () => {
 95 |     it("should use separate endpoints for sending vs receiving", async () => {
 96 |       const ctx = createExecutionContext();
 97 |       const { sessionId } = await establishSSEConnection(ctx);
 98 | 
 99 |       // Sending uses POST to /sse/message
100 |       const sendEndpoint = `${baseUrl}/message?sessionId=${sessionId}`;
101 | 
102 |       // Receiving uses the initial SSE connection
103 |       const request = new Request(sendEndpoint, {
104 |         body: JSON.stringify({
105 |           id: "test",
106 |           jsonrpc: "2.0",
107 |           method: "tools/list"
108 |         }),
109 |         headers: { "Content-Type": "application/json" },
110 |         method: "POST"
111 |       });
112 | 
113 |       const response = await worker.fetch(request, env, ctx);
114 |       expect(response.status).toBe(202);
115 | 
116 |       // This demonstrates the SSE pattern: send via POST, receive via SSE
117 |       expect(response.headers.get("Content-Type")).toBe("text/event-stream");
118 |     });
119 |   });
120 | });
121 | 


--------------------------------------------------------------------------------
/packages/agents/src/tests/mcp/transports/streamable-http.test.ts:
--------------------------------------------------------------------------------
  1 | import { createExecutionContext, env } from "cloudflare:test";
  2 | import type { JSONRPCMessage } from "@modelcontextprotocol/sdk/types.js";
  3 | import { describe, expect, it } from "vitest";
  4 | import worker, { type Env } from "../../worker";
  5 | import {
  6 |   TEST_MESSAGES,
  7 |   initializeStreamableHTTPServer,
  8 |   sendPostRequest,
  9 |   expectErrorResponse
 10 | } from "../../shared/test-utils";
 11 | 
 12 | declare module "cloudflare:test" {
 13 |   interface ProvidedEnv extends Env {}
 14 | }
 15 | 
 16 | /**
 17 |  * Tests specific to the Streamable HTTP transport protocol
 18 |  */
 19 | describe("Streamable HTTP Transport", () => {
 20 |   const baseUrl = "http://example.com/mcp";
 21 | 
 22 |   describe("Session Management", () => {
 23 |     it("should initialize server and generate session ID", async () => {
 24 |       const ctx = createExecutionContext();
 25 | 
 26 |       const response = await sendPostRequest(
 27 |         ctx,
 28 |         baseUrl,
 29 |         TEST_MESSAGES.initialize
 30 |       );
 31 | 
 32 |       expect(response.status).toBe(200);
 33 |       expect(response.headers.get("content-type")).toBe("text/event-stream");
 34 |       expect(response.headers.get("mcp-session-id")).toBeDefined();
 35 |     });
 36 | 
 37 |     it("should reject initialization request with session ID", async () => {
 38 |       const ctx = createExecutionContext();
 39 | 
 40 |       // Send an initialization request with a session ID - this should fail
 41 |       const initWithSessionMessage = {
 42 |         ...TEST_MESSAGES.initialize,
 43 |         id: "init-with-session"
 44 |       };
 45 | 
 46 |       const response = await sendPostRequest(
 47 |         ctx,
 48 |         baseUrl,
 49 |         initWithSessionMessage,
 50 |         "some-session-id"
 51 |       );
 52 | 
 53 |       expect(response.status).toBe(400);
 54 |       const errorData = await response.json();
 55 |       expectErrorResponse(
 56 |         errorData,
 57 |         -32600,
 58 |         /Initialization requests must not include a sessionId/
 59 |       );
 60 |     });
 61 | 
 62 |     it("should reject batch with multiple initialization requests", async () => {
 63 |       const ctx = createExecutionContext();
 64 | 
 65 |       // Send multiple initialization requests in a batch - this should fail
 66 |       const batchInitMessages: JSONRPCMessage[] = [
 67 |         TEST_MESSAGES.initialize,
 68 |         {
 69 |           id: "init-2",
 70 |           jsonrpc: "2.0",
 71 |           method: "initialize",
 72 |           params: {
 73 |             clientInfo: { name: "test-client-2", version: "1.0" },
 74 |             protocolVersion: "2025-03-26"
 75 |           }
 76 |         }
 77 |       ];
 78 | 
 79 |       const response = await sendPostRequest(ctx, baseUrl, batchInitMessages);
 80 | 
 81 |       expect(response.status).toBe(400);
 82 |       const errorData = await response.json();
 83 |       expectErrorResponse(
 84 |         errorData,
 85 |         -32600,
 86 |         /Only one initialization request is allowed/
 87 |       );
 88 |     });
 89 | 
 90 |     it("should reject requests without valid session ID", async () => {
 91 |       const ctx = createExecutionContext();
 92 | 
 93 |       const response = await sendPostRequest(
 94 |         ctx,
 95 |         baseUrl,
 96 |         TEST_MESSAGES.toolsList
 97 |       );
 98 | 
 99 |       expect(response.status).toBe(400);
100 |       const errorData = await response.json();
101 |       expectErrorResponse(errorData, -32000, /Bad Request/);
102 |     });
103 | 
104 |     it("should reject invalid session ID", async () => {
105 |       const ctx = createExecutionContext();
106 | 
107 |       const response = await sendPostRequest(
108 |         ctx,
109 |         baseUrl,
110 |         TEST_MESSAGES.toolsList,
111 |         "invalid-session-id"
112 |       );
113 | 
114 |       expect(response.status).toBe(404);
115 |       const errorData = await response.json();
116 |       expectErrorResponse(errorData, -32001, /Session not found/);
117 |     });
118 |   });
119 | 
120 |   describe("HTTP Protocol Features", () => {
121 |     it("should reject POST requests without proper Accept header", async () => {
122 |       const ctx = createExecutionContext();
123 |       const sessionId = await initializeStreamableHTTPServer(ctx);
124 | 
125 |       const request = new Request(baseUrl, {
126 |         body: JSON.stringify(TEST_MESSAGES.toolsList),
127 |         headers: {
128 |           Accept: "application/json", // Missing text/event-stream
129 |           "Content-Type": "application/json",
130 |           "mcp-session-id": sessionId
131 |         },
132 |         method: "POST"
133 |       });
134 |       const response = await worker.fetch(request, env, ctx);
135 | 
136 |       expect(response.status).toBe(406);
137 |       const errorData = await response.json();
138 |       expectErrorResponse(
139 |         errorData,
140 |         -32000,
141 |         /Client must accept both application\/json and text\/event-stream/
142 |       );
143 |     });
144 | 
145 |     it("should reject unsupported Content-Type", async () => {
146 |       const ctx = createExecutionContext();
147 |       const sessionId = await initializeStreamableHTTPServer(ctx);
148 | 
149 |       const request = new Request(baseUrl, {
150 |         body: "This is plain text",
151 |         headers: {
152 |           Accept: "application/json, text/event-stream",
153 |           "Content-Type": "text/plain",
154 |           "mcp-session-id": sessionId
155 |         },
156 |         method: "POST"
157 |       });
158 |       const response = await worker.fetch(request, env, ctx);
159 | 
160 |       expect(response.status).toBe(415);
161 |       const errorData = await response.json();
162 |       expectErrorResponse(
163 |         errorData,
164 |         -32000,
165 |         /Content-Type must be application\/json/
166 |       );
167 |     });
168 | 
169 |     it("should handle invalid JSON data", async () => {
170 |       const ctx = createExecutionContext();
171 |       const sessionId = await initializeStreamableHTTPServer(ctx);
172 | 
173 |       const request = new Request(baseUrl, {
174 |         body: "This is not valid JSON",
175 |         headers: {
176 |           Accept: "application/json, text/event-stream",
177 |           "Content-Type": "application/json",
178 |           "mcp-session-id": sessionId
179 |         },
180 |         method: "POST"
181 |       });
182 |       const response = await worker.fetch(request, env, ctx);
183 | 
184 |       expect(response.status).toBe(400);
185 |       const errorData = await response.json();
186 |       expectErrorResponse(errorData, -32700, /Parse error/);
187 |     });
188 | 
189 |     it("should return 400 error for invalid JSON-RPC messages", async () => {
190 |       const ctx = createExecutionContext();
191 |       const sessionId = await initializeStreamableHTTPServer(ctx);
192 | 
193 |       const invalidMessage = { id: 1, method: "tools/list", params: {} };
194 |       const response = await sendPostRequest(
195 |         ctx,
196 |         baseUrl,
197 |         invalidMessage as JSONRPCMessage,
198 |         sessionId
199 |       );
200 | 
201 |       expect(response.status).toBe(400);
202 |       const errorData = await response.json();
203 |       expect(errorData).toMatchObject({
204 |         error: expect.anything(),
205 |         jsonrpc: "2.0"
206 |       });
207 |     });
208 |   });
209 | 
210 |   describe("Batch Operations", () => {
211 |     it("should reject batch initialization request", async () => {
212 |       const ctx = createExecutionContext();
213 | 
214 |       const batchInitMessages: JSONRPCMessage[] = [
215 |         TEST_MESSAGES.initialize,
216 |         {
217 |           id: "init-2",
218 |           jsonrpc: "2.0",
219 |           method: "initialize",
220 |           params: {
221 |             clientInfo: { name: "test-client-2", version: "1.0" },
222 |             protocolVersion: "2025-03-26"
223 |           }
224 |         }
225 |       ];
226 | 
227 |       const response = await sendPostRequest(ctx, baseUrl, batchInitMessages);
228 | 
229 |       expect(response.status).toBe(400);
230 |       const errorData = await response.json();
231 |       expectErrorResponse(
232 |         errorData,
233 |         -32600,
234 |         /Only one initialization request is allowed/
235 |       );
236 |     });
237 | 
238 |     it("should handle batch notification messages with 202 response", async () => {
239 |       const ctx = createExecutionContext();
240 |       const sessionId = await initializeStreamableHTTPServer(ctx);
241 | 
242 |       const batchNotifications: JSONRPCMessage[] = [
243 |         { jsonrpc: "2.0", method: "someNotification1", params: {} },
244 |         { jsonrpc: "2.0", method: "someNotification2", params: {} }
245 |       ];
246 |       const response = await sendPostRequest(
247 |         ctx,
248 |         baseUrl,
249 |         batchNotifications,
250 |         sessionId
251 |       );
252 | 
253 |       expect(response.status).toBe(202);
254 |     });
255 | 
256 |     it("should handle batch request messages with SSE stream", async () => {
257 |       const ctx = createExecutionContext();
258 |       const sessionId = await initializeStreamableHTTPServer(ctx);
259 | 
260 |       const batchRequests: JSONRPCMessage[] = [
261 |         { id: "req-1", jsonrpc: "2.0", method: "tools/list", params: {} },
262 |         {
263 |           id: "req-2",
264 |           jsonrpc: "2.0",
265 |           method: "tools/call",
266 |           params: { arguments: { name: "BatchUser" }, name: "greet" }
267 |         }
268 |       ];
269 |       const response = await sendPostRequest(
270 |         ctx,
271 |         baseUrl,
272 |         batchRequests,
273 |         sessionId
274 |       );
275 | 
276 |       expect(response.status).toBe(200);
277 |       expect(response.headers.get("content-type")).toBe("text/event-stream");
278 | 
279 |       const reader = response.body?.getReader();
280 |       const { value: value1 } = await reader!.read();
281 |       const text1 = new TextDecoder().decode(value1);
282 |       const { value: value2 } = await reader!.read();
283 |       const text2 = new TextDecoder().decode(value2);
284 | 
285 |       const combinedText = text1 + text2;
286 |       expect(combinedText).toContain('"id":"req-1"');
287 |       expect(combinedText).toContain('"tools"');
288 |       expect(combinedText).toContain('"id":"req-2"');
289 |       expect(combinedText).toContain("Hello, BatchUser");
290 |     });
291 |   });
292 | 
293 |   describe("Concurrent Requests", () => {
294 |     it("should route responses to correct connection", async () => {
295 |       const ctx = createExecutionContext();
296 |       const sessionId = await initializeStreamableHTTPServer(ctx);
297 | 
298 |       const message1: JSONRPCMessage = {
299 |         id: "req-1",
300 |         jsonrpc: "2.0",
301 |         method: "tools/list",
302 |         params: {}
303 |       };
304 | 
305 |       const message2: JSONRPCMessage = {
306 |         id: "req-2",
307 |         jsonrpc: "2.0",
308 |         method: "tools/call",
309 |         params: {
310 |           arguments: { name: "Connection2" },
311 |           name: "greet"
312 |         }
313 |       };
314 | 
315 |       const [response1, response2] = await Promise.all([
316 |         sendPostRequest(ctx, baseUrl, message1, sessionId),
317 |         sendPostRequest(ctx, baseUrl, message2, sessionId)
318 |       ]);
319 | 
320 |       const reader1 = response1.body?.getReader();
321 |       const reader2 = response2.body?.getReader();
322 | 
323 |       const { value: value1 } = await reader1!.read();
324 |       const text1 = new TextDecoder().decode(value1);
325 |       expect(text1).toContain('"id":"req-1"');
326 |       expect(text1).toContain('"tools"');
327 | 
328 |       const { value: value2 } = await reader2!.read();
329 |       const text2 = new TextDecoder().decode(value2);
330 |       expect(text2).toContain('"id":"req-2"');
331 |       expect(text2).toContain("Hello, Connection2");
332 |     });
333 |   });
334 | });
335 | 


--------------------------------------------------------------------------------
/packages/agents/src/tests/shared/test-utils.ts:
--------------------------------------------------------------------------------
  1 | import { env } from "cloudflare:test";
  2 | import type { JSONRPCMessage } from "@modelcontextprotocol/sdk/types.js";
  3 | import { expect } from "vitest";
  4 | import worker, { type Env } from "../worker";
  5 | 
  6 | declare module "cloudflare:test" {
  7 |   interface ProvidedEnv extends Env {}
  8 | }
  9 | 
 10 | /**
 11 |  * Common test messages for MCP protocol testing
 12 |  */
 13 | export const TEST_MESSAGES = {
 14 |   initialize: {
 15 |     id: "init-1",
 16 |     jsonrpc: "2.0",
 17 |     method: "initialize",
 18 |     params: {
 19 |       capabilities: {},
 20 |       clientInfo: { name: "test-client", version: "1.0" },
 21 |       protocolVersion: "2025-03-26"
 22 |     }
 23 |   } as JSONRPCMessage,
 24 | 
 25 |   toolsList: {
 26 |     id: "tools-1",
 27 |     jsonrpc: "2.0",
 28 |     method: "tools/list",
 29 |     params: {}
 30 |   } as JSONRPCMessage,
 31 | 
 32 |   greetTool: {
 33 |     id: "greet-1",
 34 |     jsonrpc: "2.0",
 35 |     method: "tools/call",
 36 |     params: {
 37 |       arguments: { name: "Test User" },
 38 |       name: "greet"
 39 |     }
 40 |   } as JSONRPCMessage,
 41 | 
 42 |   propsTestTool: {
 43 |     id: "props-1",
 44 |     jsonrpc: "2.0",
 45 |     method: "tools/call",
 46 |     params: {
 47 |       arguments: {},
 48 |       name: "getPropsTestValue"
 49 |     }
 50 |   } as JSONRPCMessage
 51 | };
 52 | 
 53 | /**
 54 |  * Helper to extract text from SSE response
 55 |  * Note: Can only be called once per response stream. For multiple reads,
 56 |  * get the reader manually and read multiple times.
 57 |  */
 58 | export async function readSSEEvent(response: Response): Promise<string> {
 59 |   const reader = response.body?.getReader();
 60 |   const { value } = await reader!.read();
 61 |   return new TextDecoder().decode(value);
 62 | }
 63 | 
 64 | /**
 65 |  * Helper to send JSON-RPC request via POST
 66 |  */
 67 | export async function sendPostRequest(
 68 |   ctx: ExecutionContext,
 69 |   baseUrl: string,
 70 |   message: JSONRPCMessage | JSONRPCMessage[],
 71 |   sessionId?: string
 72 | ): Promise<Response> {
 73 |   const headers: Record<string, string> = {
 74 |     Accept: "application/json, text/event-stream",
 75 |     "Content-Type": "application/json"
 76 |   };
 77 | 
 78 |   if (sessionId) {
 79 |     headers["mcp-session-id"] = sessionId;
 80 |   }
 81 | 
 82 |   const request = new Request(baseUrl, {
 83 |     body: JSON.stringify(message),
 84 |     headers,
 85 |     method: "POST"
 86 |   });
 87 | 
 88 |   return worker.fetch(request, env, ctx);
 89 | }
 90 | 
 91 | /**
 92 |  * Helper to validate JSON-RPC error responses
 93 |  */
 94 | export function expectErrorResponse(
 95 |   data: unknown,
 96 |   expectedCode: number,
 97 |   expectedMessagePattern: RegExp
 98 | ): void {
 99 |   expect(data).toMatchObject({
100 |     error: expect.objectContaining({
101 |       code: expectedCode,
102 |       message: expect.stringMatching(expectedMessagePattern)
103 |     }),
104 |     jsonrpc: "2.0"
105 |   });
106 | }
107 | 
108 | /**
109 |  * Helper to parse SSE event data
110 |  */
111 | export function parseSSEData(sseText: string): unknown {
112 |   const eventLines = sseText.split("\n");
113 |   const dataLine = eventLines.find((line) => line.startsWith("data:"));
114 |   if (!dataLine) {
115 |     throw new Error("No data line found in SSE event");
116 |   }
117 |   return JSON.parse(dataLine.substring(5));
118 | }
119 | 
120 | /**
121 |  * Helper to initialize server and get session ID for streamable HTTP
122 |  */
123 | export async function initializeStreamableHTTPServer(
124 |   ctx: ExecutionContext,
125 |   baseUrl = "http://example.com/mcp"
126 | ): Promise<string> {
127 |   const response = await sendPostRequest(
128 |     ctx,
129 |     baseUrl,
130 |     TEST_MESSAGES.initialize
131 |   );
132 | 
133 |   expect(response.status).toBe(200);
134 |   const sessionId = response.headers.get("mcp-session-id");
135 |   expect(sessionId).toBeDefined();
136 |   return sessionId as string;
137 | }
138 | 
139 | /**
140 |  * Helper to establish SSE connection and get session ID
141 |  */
142 | export async function establishSSEConnection(
143 |   ctx: ExecutionContext,
144 |   baseUrl = "http://example.com/sse"
145 | ): Promise<{
146 |   sessionId: string;
147 |   reader: ReadableStreamDefaultReader<Uint8Array>;
148 | }> {
149 |   const request = new Request(baseUrl);
150 |   const sseStream = await worker.fetch(request, env, ctx);
151 | 
152 |   const reader = sseStream.body?.getReader();
153 |   if (!reader) {
154 |     throw new Error("No reader available");
155 |   }
156 |   const { value } = await reader.read();
157 |   const event = new TextDecoder().decode(value);
158 | 
159 |   const lines = event.split("\n");
160 |   const sessionId = lines[1].split("=")[1];
161 |   expect(sessionId).toBeDefined();
162 | 
163 |   return { sessionId, reader };
164 | }
165 | 
166 | /**
167 |  * Common test assertions for tool listing results
168 |  */
169 | export function expectValidToolsList(result: unknown): void {
170 |   expect(result).toMatchObject({
171 |     jsonrpc: "2.0",
172 |     result: expect.objectContaining({
173 |       tools: expect.arrayContaining([
174 |         expect.objectContaining({
175 |           description: "A simple greeting tool",
176 |           name: "greet",
177 |           inputSchema: expect.objectContaining({
178 |             type: "object",
179 |             properties: expect.objectContaining({
180 |               name: expect.objectContaining({
181 |                 type: "string"
182 |               })
183 |             })
184 |           })
185 |         })
186 |       ])
187 |     })
188 |   });
189 | }
190 | 
191 | /**
192 |  * Common test assertions for greet tool results
193 |  */
194 | export function expectValidGreetResult(
195 |   result: unknown,
196 |   expectedName: string
197 | ): void {
198 |   expect(result).toMatchObject({
199 |     jsonrpc: "2.0",
200 |     result: {
201 |       content: [
202 |         {
203 |           text: `Hello, ${expectedName}!`,
204 |           type: "text"
205 |         }
206 |       ]
207 |     }
208 |   });
209 | }
210 | 
211 | /**
212 |  * Common test assertions for props test tool results
213 |  */
214 | export function expectValidPropsResult(result: unknown): void {
215 |   expect(result).toMatchObject({
216 |     jsonrpc: "2.0",
217 |     result: {
218 |       content: [
219 |         {
220 |           text: "123",
221 |           type: "text"
222 |         }
223 |       ]
224 |     }
225 |   });
226 | }
227 | 


--------------------------------------------------------------------------------
/packages/agents/src/tests/tsconfig.json:
--------------------------------------------------------------------------------
 1 | {
 2 |   "compilerOptions": {
 3 |     "types": [
 4 |       "@cloudflare/workers-types/experimental",
 5 |       "@cloudflare/vitest-pool-workers"
 6 |     ]
 7 |   },
 8 |   "extends": "../../../../tsconfig.base.json",
 9 |   "include": ["./**/*.ts"]
10 | }
11 | 


--------------------------------------------------------------------------------
/packages/agents/src/tests/vitest.config.ts:
--------------------------------------------------------------------------------
 1 | import { defineWorkersConfig } from "@cloudflare/vitest-pool-workers/config";
 2 | 
 3 | export default defineWorkersConfig({
 4 |   test: {
 5 |     deps: {
 6 |       optimizer: {
 7 |         ssr: {
 8 |           include: [
 9 |             // vitest can't seem to properly import
10 |             // `require('./path/to/anything.json')` files,
11 |             // which ajv uses (by way of @modelcontextprotocol/sdk)
12 |             // the workaround is to add the package to the include list
13 |             "ajv"
14 |           ]
15 |         }
16 |       }
17 |     },
18 |     poolOptions: {
19 |       workers: {
20 |         isolatedStorage: false,
21 |         singleWorker: true,
22 |         wrangler: {
23 |           configPath: "./wrangler.jsonc"
24 |         }
25 |       }
26 |     }
27 |   }
28 | });
29 | 


--------------------------------------------------------------------------------
/packages/agents/src/tests/worker.ts:
--------------------------------------------------------------------------------
  1 | import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
  2 | import type { CallToolResult } from "@modelcontextprotocol/sdk/types.js";
  3 | import { z } from "zod";
  4 | import { McpAgent } from "../mcp/index.ts";
  5 | import { Agent, type AgentEmail } from "../index.ts";
  6 | 
  7 | export type Env = {
  8 |   MCP_OBJECT: DurableObjectNamespace<McpAgent>;
  9 |   EmailAgent: DurableObjectNamespace<TestEmailAgent>;
 10 |   CaseSensitiveAgent: DurableObjectNamespace<TestCaseSensitiveAgent>;
 11 |   UserNotificationAgent: DurableObjectNamespace<TestUserNotificationAgent>;
 12 | };
 13 | 
 14 | type State = unknown;
 15 | 
 16 | type Props = {
 17 |   testValue: string;
 18 | };
 19 | 
 20 | export class TestMcpAgent extends McpAgent<Env, State, Props> {
 21 |   server = new McpServer(
 22 |     { name: "test-server", version: "1.0.0" },
 23 |     { capabilities: { logging: {} } }
 24 |   );
 25 | 
 26 |   async init() {
 27 |     this.server.tool(
 28 |       "greet",
 29 |       "A simple greeting tool",
 30 |       { name: z.string().describe("Name to greet") },
 31 |       async ({ name }): Promise<CallToolResult> => {
 32 |         return { content: [{ text: `Hello, ${name}!`, type: "text" }] };
 33 |       }
 34 |     );
 35 | 
 36 |     this.server.tool(
 37 |       "getPropsTestValue",
 38 |       {},
 39 |       async (): Promise<CallToolResult> => {
 40 |         return {
 41 |           content: [{ text: this.props.testValue, type: "text" }]
 42 |         };
 43 |       }
 44 |     );
 45 |   }
 46 | }
 47 | 
 48 | // Test email agents
 49 | export class TestEmailAgent extends Agent<Env> {
 50 |   emailsReceived: AgentEmail[] = [];
 51 | 
 52 |   async onEmail(email: AgentEmail) {
 53 |     this.emailsReceived.push(email);
 54 |   }
 55 | 
 56 |   // Override onError to avoid console.error which triggers queueMicrotask issues
 57 |   override onError(error: unknown): void {
 58 |     // Silently handle errors in tests
 59 |     throw error;
 60 |   }
 61 | }
 62 | 
 63 | export class TestCaseSensitiveAgent extends Agent<Env> {
 64 |   emailsReceived: AgentEmail[] = [];
 65 | 
 66 |   async onEmail(email: AgentEmail) {
 67 |     this.emailsReceived.push(email);
 68 |   }
 69 | 
 70 |   override onError(error: unknown): void {
 71 |     throw error;
 72 |   }
 73 | }
 74 | 
 75 | export class TestUserNotificationAgent extends Agent<Env> {
 76 |   emailsReceived: AgentEmail[] = [];
 77 | 
 78 |   async onEmail(email: AgentEmail) {
 79 |     this.emailsReceived.push(email);
 80 |   }
 81 | 
 82 |   override onError(error: unknown): void {
 83 |     throw error;
 84 |   }
 85 | }
 86 | 
 87 | export default {
 88 |   fetch(request: Request, env: Env, ctx: ExecutionContext) {
 89 |     const url = new URL(request.url);
 90 | 
 91 |     // set some props that should be passed init
 92 |     ctx.props = {
 93 |       testValue: "123"
 94 |     };
 95 | 
 96 |     if (url.pathname === "/sse" || url.pathname === "/sse/message") {
 97 |       return TestMcpAgent.serveSSE("/sse").fetch(request, env, ctx);
 98 |     }
 99 | 
100 |     if (url.pathname === "/mcp") {
101 |       return TestMcpAgent.serve("/mcp").fetch(request, env, ctx);
102 |     }
103 | 
104 |     return new Response("Not found", { status: 404 });
105 |   },
106 | 
107 |   async email(
108 |     _message: ForwardableEmailMessage,
109 |     _env: Env,
110 |     _ctx: ExecutionContext
111 |   ) {
112 |     // Bring this in when we write tests for the complete email handler flow
113 |   }
114 | };
115 | 


--------------------------------------------------------------------------------
/packages/agents/src/tests/wrangler.jsonc:
--------------------------------------------------------------------------------
 1 | {
 2 |   "compatibility_date": "2025-04-17",
 3 |   "compatibility_flags": ["nodejs_compat"],
 4 |   "durable_objects": {
 5 |     "bindings": [
 6 |       {
 7 |         "class_name": "TestMcpAgent",
 8 |         "name": "MCP_OBJECT"
 9 |       },
10 |       {
11 |         "class_name": "TestEmailAgent",
12 |         "name": "EmailAgent"
13 |       },
14 |       {
15 |         "class_name": "TestCaseSensitiveAgent",
16 |         "name": "CaseSensitiveAgent"
17 |       },
18 |       {
19 |         "class_name": "TestUserNotificationAgent",
20 |         "name": "UserNotificationAgent"
21 |       }
22 |     ]
23 |   },
24 |   "main": "worker.ts",
25 |   "migrations": [
26 |     {
27 |       "new_sqlite_classes": [
28 |         "TestMcpAgent",
29 |         "TestEmailAgent",
30 |         "TestCaseSensitiveAgent",
31 |         "TestUserNotificationAgent"
32 |       ],
33 |       "tag": "v1"
34 |     }
35 |   ]
36 | }
37 | 


--------------------------------------------------------------------------------
/packages/agents/tsconfig.json:
--------------------------------------------------------------------------------
1 | {
2 |   "exclude": ["src/tests/**/*.ts"],
3 |   "extends": "../../tsconfig.base.json"
4 | }
5 | 


--------------------------------------------------------------------------------